[toc]



# `BFS`搜索

## 洪水填充Flood Fill

> 下面这个没有没有就差一点点效率：
>
> 	可以在拓展的是否标重，**注意起点**

- `dfs`:栈不需自己写，实现起来容易一点点，但是无法求最短路，爆栈
- `bfs`：能求最短路

### 池塘计数（基础模板）

```
一块N*M的矩形土地，有一些土地被水淹了
每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。
每组相连的积水单元格集合可以看作是一片池塘。
每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。
约翰想知道形成多少片池塘？
```
![池塘计数.jpg](https://cdn.acwing.com/media/article/image/2023/08/23/246003_e00d871041-池塘计数.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
//简写
typedef pair<int,int> pii;
#define x first//名字 常量
#define y second
const int N=1010;
int n,m;
char g[N][N];
bool st[N][N];//bfs中看是否走过
//stl版
void bfs(int sx,int sy){
    queue<pii> q;
    q.push({sx,sy});
    st[sx][sy]=1;
    while(!q.empty()){
        auto t=q.front();
        q.pop();
        //八联通的遍历方法
        for(int i=t.x-1;i<=t.x+1;i++){
            for(int j=t.y-1;j<=t.y+1;j++){
                //只需特判一下中间
                if(i==t.x&&j==t.y) continue;
                //首先要在矩形内
                if(i<1||i>n||j<1||j>m) continue;
                //其次要是水且没遍历过
                if(g[i][j]=='.'||st[i][j])continue;
                q.push({i,j});
                st[i][j]=1;
            }
        }
    }
}   

//数组模拟版
/*
pii q[N*N];
    //避免整个矩形都是的情况
void bfs(int sx,int sy){
    int hh=0,tt=0;//队头队尾,这里按模板都是表示实际的位置
        //不过这里默认有一个
    //把对头队尾放着，相当于新建了一个队列
    q[tt]={sx,sy};
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=t.x-1;i<=t.x+1;i++){
            for(int j=t.y-1;j<=t.y+1;j++){
                if(i==t.x&&j==t.y) continue;
                if(i<1||i>n||j<1||j>m) continue;
                if(g[i][j]=='.'||st[i][j]) continue;
                q[++tt]={i,j};
                st[i][j]=1;
            }
        }
    }
}
*/
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%s",g[i]+1);
        //一般输入字符串不会出错，但是如果是一个字符小心
        //从第一个开始输入
    int cnt=0;//记录共有多少个水潭
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(g[i][j]=='W'&&!st[i][j]){
            //标记完这个水塘
                bfs(i,j);
                cnt++;
            }
        }
    }
    cout<<cnt;
    return 0;
}
```
```java
import java.util.*;
class Pair{
    int x,y;
    Pair(int x,int y){
        this.x=x;
        this.y=y;
    }
}
public class Main{
    static final int N=1010;
    static int n,m;
    static char[][] g=new char[N][N];
    
    static boolean[][] st=new boolean[N][N];
    static Queue<Pair> q=new LinkedList<>();//避免多次创建
    static void bfs(int sx,int sy){
        //第一次拓展到就能标记了
        q.add(new Pair(sx,sy));
        st[sx][sy]=true;
        //八联通遍历小技巧
        while(!q.isEmpty()){
            Pair t=q.remove();
            // System.out.println(t.x+" "+t.y);
            for(int i=-1;i<=1;++i){
                for(int j=-1;j<=1;++j){
                    int x=t.x+i,y=t.y+j;
                    if(x==t.x&&y==t.y) continue;//中间那一块
                    if(x<1||x>n||y<1||y>m) continue;
                    if(g[x][y]=='.'||st[x][y]) continue;
                    st[x][y]=true;
                    q.add(new Pair(x,y));
                }
            }
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        for(int i=1;i<=n;++i){
            char[] line=sc.next().toCharArray();
            for(int j=1;j<=m;++j){
                g[i][j]=line[j-1];
            }
        }
        
        //洪水填充算法
        int res=0;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                if(g[i][j]=='.'||st[i][j]) continue;//没水或者走过了
                bfs(i,j);
                // System.out.println();
                ++res;
            }
        }
        System.out.println(res);
    }
}
```



### 城堡问题(联通形态特殊)

（联通的特殊表示：引入二进制表示每个方格的状态，当相邻没有墙表示联通）

[1098. 城堡问题 - AcWing题库](https://www.acwing.com/problem/content/1100/)

        1   2   3   4   5   6   7  
       #############################
     1 #   |   #   |   #   |   |   #
       #####---#####---#---#####---#
     2 #   #   |   #   #   #   #   #
       #---#####---#####---#####---#
     3 #   |   |   #   #   #   #   #
       #---#########---#####---#---#
     4 #   #   |   |   |   |   #   #
       #############################
               (图 1)
    
       #  = Wall   
       |  = No wall
       -  = No wall
       方向：上北下南左西右东。
       
    上图输入：
    4 7 
    11 6 11 6 3 10 6 
    7 9 6 13 5 15 5 
    1 10 12 7 13 7 5 
    13 11 10 8 10 12 13 
    房间个数：5；最大房间面积：9；

每个方格区域可以有$0\sim4$面墙（方向：上北下南左西右东）
（每个方块中墙的特征由数字 P  来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P为该方块包含墙的数字之和。）

> 例如，如果一个方块的 P=3，
>    则 3 = 1 + 2，该方块包含西墙和北墙。
> 城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙

注意：墙体厚度忽略不计。
计算有多少个房间?最大的房间有多大?

**数据范围：**$1 \le m,n \le 50$,  $0 \le P \le 15$

----

![城堡问题.jpg](https://cdn.acwing.com/media/article/image/2023/08/24/246003_7cf00f8e42-城堡问题.jpg) 

（**注意：是从当前格子的视角出发**，如果是从拓展格子出发是需要换顺序的）

![城堡问题2.jpg](https://cdn.acwing.com/media/article/image/2023/08/24/246003_8260645a42-城堡问题2.jpg) 

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=60;
typedef pair<int,int> pii;
#define x first
#define y second
int n,m;
int g[N][N];
/*转为二进制的表示，1表示有墙
    低位到高位分别对应西北东南*/
int mx[4]={0,-1,0,1};
int my[4]={-1,0,1,0};
bool st[N][N];//判断是否走过
int bfs(int sx,int sy){//走完这个房间
                    //并返回面积
    queue<pii> q;
    q.push({sx,sy});
    st[sx][sy]=1;//标记走过只能在入队时（具体看笔记）
    int area=1;//能在被搜时统计，也能在入队时统计
    //为了避免一些没必要的麻烦，最好都只在入队时操作
    while(!q.empty()){
    //队头被搜时
        auto t=q.front();
        q.pop();
        for(int i=0;i<4;i++){//分别四个方向
            int x=t.x+mx[i],y=t.y+my[i];
            //是否能走
                //1.不在矩形内
            if(x<1||x>n||y<1||y>m) continue;
                //2.被走过
            if(st[x][y]) continue;
                //3.有墙
            if(g[t.x][t.y]>>i&1) continue;
                //这个方向是1，说明有墙
                //呜呜，注意是用当前格子来判断
            //入队时
            q.push({x,y});
            st[x][y]=1;
            area++;
        }
    }
    return area;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>g[i][j];
    //枚举所有位置，看是否有没走过的地方
    int cnt=0,area=0;//个数和最大面积
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(!st[i][j]){
                // cout<<i<<" "<<j<<endl;
                area=max(area,bfs(i,j));
                cnt++;
            }
        }
    }
    cout<<cnt<<endl<<area<<endl;
    return 0;
}
```

###  山峰和山谷(边界问题)

（判断拓展时候：引入对联通的边界进行特判）


----------

给定一个地图，地图被分为 $n \times n$ 的网格，
每个格子 $(i,j)$ 的高度 $w(i,j)$ 是给定的。
若两个格子有公共顶点，那么它们就是相邻的格子(八联通)
我们定义一个格子的集合 $S$ 为山峰（山谷）当且仅当：


1. $S$ 的所有格子都有相同的高度。
2. $S$ 的所有格子都连通。
3. 对于 $s$ 属于 $S$，与 $s$ 相邻的 $s’$ 不属于 $S$，都有 $w_s > w_{s’}$（山峰），或者 $w_s < w_{s’}$（山谷）。
4. 如果周围不存在相邻区域，则同时将其视为山峰和山谷。

如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。
求出山峰和山谷的数量？

例子：3个山谷，3个山峰![](https://cdn.acwing.com/media/article/image/2019/10/16/19_08db5e60ef-2.png)

**数据范围：**$1\le n \le 1000$,$0 \le w \le 10^9$


----------

```
本题需要判断与外围的关系：
    在求bfs的扩展情况时：
        把不合法去掉后
        特意判断一下联通块外围的情况
        （就是刚刚不符合联通块条件的那几个）
```
```c++
//只需额外多加一个判断边界周围的情况
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define x first
#define y second
const int N=1010;
int n,g[N][N];
pii q[N*N];//可能整个矩形都在
bool st[N][N];
void bfs(int sx,int sy,bool &has_higher,bool &has_lower){
        //这里用了取值符，传的是实参
    int hh=0,tt=0;
    q[0]={sx,sy};
    st[sx][sy]=1;//注意是入队时标记
    while(hh<=tt){
        auto t=q[hh++];
        //八联通图遍历
        for(int i=t.x-1;i<=t.x+1;i++){
            for(int j=t.y-1;j<=t.y+1;j++){
                //将中间判掉
                if(i==t.x&&j==t.y) continue;
                //不在矩形中
                if(i<1||i>n||j<1||j>n) continue;
                //到了联通块的周围(没有相等)
                if(g[i][j]!=g[t.x][t.y]){
                    //存在更高的
                    if(g[i][j]>g[t.x][t.y]) has_higher=1;
                    //存在更低的
                    if(g[i][j]<g[t.x][t.y]) has_lower=1;
                }else if(!st[i][j]){//相等且没被遍历过
                    q[++tt]={i,j};
                    st[i][j]=1;
                }
            }
        }
    }
} 
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&g[i][j]);
    int peak=0,valley=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(!st[i][j]){
                bool has_higher=0,has_lower=0;
                //是否有更高，更低的
                bfs(i,j,has_higher,has_lower);
                if(!has_higher) peak++;
                    //没有更高的说明是峰
                if(!has_lower) valley++;
                    //没有更低的说明是谷
            }
        }
    }
    printf("%d %d\n",peak,valley);
    return 0;
}
```

**注意：这个判断山峰和谷的办法**：没有更高为峰；没有更低为谷



## 最短路模型（条件：权值相等）

注意权值相等时才能用

### 迷宫问题（输出路径）

**输出路径**：需要能查询当前点对应的上一个点【key-value:能查询当前点就是将这个点当成键，上一个点和其它答案需要信息就是值】

> 如果只是坐标的话，用数组就能表示出来
>
> 但是如果字符串或者数字很大等等其他东西，数组不一定能表示，**这时需要使用字典数据结构**

从终点开始搜，避免翻转数组

```
给定一个n*n的二维数组：
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，
不能斜着走，要求编程序找出从左上角到右下角的最短路线。
数据保证至少存在一条从左上角走到右下角的路径。
```
![迷宫问题.jpg](https://cdn.acwing.com/media/article/image/2023/08/26/246003_62239f2044-迷宫问题.jpg) 
```c++
//bfs涉及到记录路径
/*由于bfs是由上一步而来，只能记录上一步从何而来。
  所以这里是从终点倒推回去，
  这样实际记录的就是下一步的*/
  
const int N=1010;
int n;
bool g[N][N];
pii q[N*N];//队列
pii pre[N][N];//记录上一步是啥
int mx[4]={1,0,-1,0};
int my[4]={0,1,0,-1};
void bfs(int sx,int sy){//以这个为起点
//初始化
    int hh=0,tt=0;
    q[0]={sx,sy};
    
    memset(pre,-1,sizeof pre);
        //将所有值都赋为-1
    pre[sx][sy]={0,0};
    while(hh<=tt){
        auto t=q[hh++];//取出队首
        for(int i=0;i<4;i++){
            int x=t.x+mx[i],y=t.y+my[i];
            if(x<0||x>=n||y<0||y>=n) continue;
            if(g[x][y]) continue;
            if(pre[x][y].x!=-1) continue;
                //已经搜过了
            q[++tt]={x,y};
            pre[x][y]=t;
        }
    }
}
int main(){
    cin>>n;
    //这题比较特殊，从(0,0)开始
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&g[i][j]);
    bfs(n-1,n-1);//从终点往回搜
    pii end(0,0);//现在的起点
        //等价于pii end={0,0};
    while(1){
        printf("%d %d\n",end.x,end.y);
        if(end.x==n-1&&end.y==n-1) break;//到达终点
        end=pre[end.x][end.y];//下一步
    }
    return 0;
}
```

### 武士风度的牛(记录步数)

需要记录步数

[AcWing 188. 武士风度的牛 - AcWing](https://www.acwing.com/activity/content/problem/content/1472/)

有一头牛叫Knight，**能像象棋中马那样走**，他的目标是吃一捆草。
给定一个$n*m$的农场地图，Knight的位置用 `K` 标记，
障碍的位置用 `*` 来标记，草的位置用 `H` 来标记。

确定 The Knight 要想吃到草，至少需要跳多少次。

>      						11 | . . . . . . . . . .
>      				     10 | . . . . * . . . . . 
>      				      9 | . . . . . . . . . . 
>      				      8 | . . . * . * . . . . 
>      				      7 | . . . . . . . * . . 
>      				      6 | . . * . . * . . . H 
>      				      5 | * . . . . . . . . . 
>      				      4 | . . . * . . . * . . 
>      				      3 | . K . . . . . . . . 
>      				      2 | . . . * . . . . . * 
>      				      1 | . . * . . . . * . . 
>      				      0 ----------------------
>      				                            1 
>      				        0 1 2 3 4 5 6 7 8 9 0 
>
>
>      			The Knight 可以按照下图中的 $A,B,C,D…$ 这条路径用 $5$ 次跳到草的地方（有可能其它路线的长度也是 $5$）：
>
>      			         11 | . . . . . . . . . .
>      			         10 | . . . . * . . . . .
>      			          9 | . . . . . . . . . .
>      			          8 | . . . * . * . . . .
>      			          7 | . . . . . . . * . .
>      			          6 | . . * . . * . . . F<
>      			          5 | * . B . . . . . . .
>      			          4 | . . . * C . . * E .
>      			          3 | .>A . . . . D . . .
>      			          2 | . . . * . . . . . *
>      			          1 | . . * . . . . * . .
>      			          0 ----------------------
>      			                                1
>      			            0 1 2 3 4 5 6 7 8 9 0

**注意：** 数据保证一定有解。

**数据范围**：$1 \le R,C \le 150$

----

![武士风度的牛.jpg](https://cdn.acwing.com/media/article/image/2023/08/27/246003_aa0eecf044-武士风度的牛.jpg) 
```c++
int n,m;
char g[N][N];
pii q[N*N];//队列
int dist[N][N];
//记录所对应的层数（步数），顺便标重
//偏量法：记录马的走法
int mx[8]={-2,-2,-1,1,2,2,1,-1};
int my[8]={-1,1,2,2,1,-1,-2,-2};
int bfs(){
    //找起点
    int sx,sy;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(g[i][j]=='K'){
                sx=i,sy=j;
                break;
            }
    
    memset(dist,-1,sizeof dist);
        //-1表示没走过
    int hh=0,tt=0;
    q[0]={sx,sy};
    dist[sx][sy]=0;
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<8;i++){
            int x=t.x+mx[i],y=t.y+my[i];
            //1.边界
            if(x<1||x>n||y<1||y>m) continue;
            //2.题目要求不能走
            if(g[x][y]=='*')    continue;
            //3.已经走过
            if(dist[x][y]!=-1) continue;
            //找到终点
            if(g[x][y]=='H') return dist[t.x][t.y]+1;
            q[++tt]={x,y};
            dist[x][y]=dist[t.x][t.y]+1;;
        }
    }
    return -1;//没找到
}
int main(){
    cin>>m>>n;
    //注意先输的是列数
    for(int i=1;i<=n;i++) cin>>(g[i]+1);
    cout<<bfs();
    return 0;
}
```



### 抓住那头牛（数轴搜索）

如果动态规划的方式，不能一个个来，要用到后面的数据，那么大概率不行了。
```
在一个数轴上，起点为n,终点为k
有两种移动方式：
    1.从X移动到 X−1或 X+1，每次移动花费一分钟
    2.从X移动到 2∗X，每次移动花费一分钟
最少花多少时间能到达?
```
**数据范围：**$0 \le N,K \le 10^5$

---

![抓住那头牛.jpg](https://cdn.acwing.com/media/article/image/2023/08/27/246003_ac1fd67844-抓住那头牛.jpg) 

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;//这里看个笔记吧
//只需对数轴bfs
    //不需要具体的范围，反正会返回第一个搜到的
    //但是那个乘2的情况，是要好好想一下的，否则会超
int n,k;//这里n是起点，k是终点
int q[N];//这里是推出来的
int dist[N];
int bfs(){
    memset(dist,-1,sizeof dist);
    int hh=0,tt=0;
    q[0]={n};
    dist[n]=0;
    while(hh<=tt){
        int t=q[hh++];
        // cout<<t<<endl;
        //找到了可以结束了
        if(t==k) return dist[k];
        //三种扩展形态
            //要在范围内且没走过
            //1.-1
        if(t-1>=0&&dist[t-1]==-1){
            dist[t-1]=dist[t]+1;
            q[++tt]=t-1;
        }
            //2.+1
        if(t+1<N&&dist[t+1]==-1){
            dist[t+1]=dist[t]+1;
            q[++tt]=t+1;
        }
            //2.*2
        if(t*2<N&&dist[t*2]==-1){
        //这里优化了
            dist[t*2]=dist[t]+1;
            q[++tt]=t*2;
        }
    }
    return -1;//找不到
}
int main(){
    cin>>n>>k;
    cout<<bfs();
    return 0;
}
```


# 多源BFS
## 矩阵距离
> 给定一个 $N$$N$ 行 $M$$M$ 列的 $01$$01$ 矩阵 $A$$A$，$A[i][j]$$A[i][j]$ 与 $A[k][l]$$A[k][l]$ 之间的曼哈顿距离定义为：$dist(A[i][j],A[k][l])=|i-k|+|j-l|$
>
> （就是这两个点只直走上下左右的距离）
>
> 输出一个 $N$$N$ 行 $M$$M$ 列的整数矩阵 $B$$B$，其中：$B[i][j]=min_{1≤x≤N,1≤y≤M,A[x][y]=1}⁡{dist(A[i][j],A[x][y])}$
>
> （其实就是求当前点到所有1的最小距离）

**数据范围：**$1 \le N,M \le 1000$

----------

![矩阵距离.jpg](https://cdn.acwing.com/media/article/image/2023/08/28/246003_a3defc4e45-矩阵距离.jpg) 
```c++
//多个起点的bfs

const int N=1010;
int n,m;
char g[N][N];
pii q[N*N];
int dist[N][N];//记录没有没有被搜过
                //以及距离起点的距离
int mx[4]={-1,0,1,0};
int my[4]={0,1,0,-1};
void bfs(){
    //初始化
    int hh=0,tt=-1;
    memset(dist,-1,sizeof dist);
    //找出所有起点
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(g[i][j]=='1'){
                 q[++tt]={i,j};
                 dist[i][j]=0;
            }
            

    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<4;i++){
            int x=t.x+mx[i],y=t.y+my[i];    
            //边界
            if(x<1||x>n||y<1||y>m) continue;
            //不能走和走过
            if(dist[x][y]!=-1) continue;
            q[++tt]={x,y};
            dist[x][y]=dist[t.x][t.y]+1;
        }
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%s",g[i]+1);
    bfs();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) printf("%d ",dist[i][j]);
        puts("");
    }
    return 0;
}
```




# 最小步数模型
## 魔板
1. 将整个状态看成一个点（用字符串配和map）来搜
2. 需要到起点的距离
3. 需要输出路径（注意这里不能倒着搜了）
4. bfs延展形式特殊


这是一张有 $8$ 个大小相同的格子的魔板：

```
1 2 3 4
8 7 6 5
```

我们知道魔板的每一个方格都有一种颜色。
这 $8$ 种颜色用前 $8$ 个正整数来表示。

可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。

对于上图的魔板状态，我们用序列 $(1,2,3,4,5,6,7,8)$ 来表示，这是基本状态。

这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：
A：交换上下两行；  
B：将最右边的一列插入到最左边；  
C：魔板中央对的4个数作顺时针旋转。

下面是对基本状态进行操作的示范：

A：

```
8 7 6 5
1 2 3 4
```

B：

```
4 1 2 3
5 8 7 6
```

C：

```
1 7 2 4
8 6 3 5
```
对于每种可能的状态，这三种基本操作都可以使用。
给你一个特殊状态，计算用最少的基本操作完成基本状态到特殊状态的转换，输出操作次数和基本操作序列。（都用字符串表示状态）
**注意**：数据保证一定有解。


----------

![最小步数模型.jpg](https://cdn.acwing.com/media/article/image/2023/08/31/246003_6d49e51e47-最小步数模型.jpg) 
```c++
/*由于可以不用换回原数组，就不用y总那样表示了
  直接用字符串来表示所有*/
//这里需要用字符串表示整个状态当作点来搜
#include<bits/stdc++.h>
using namespace std;
string op[3]={"87654321","41236785","17245368"};
    //分别对应三种操作，不过是直接对字符串进行
    //这里很巧妙的记录，操作后的与原数组对应的编号
    //但需要注意我们记入都从0开始，要-1
string move(string s,int k){
//对字符串s进行操作k,并返回操作结果
    string ans;
    for(int i=0;i<8;i++)
        ans+=s[op[k][i]-'1'];
        //注意，字符串记录是从0开始，所以还要-1
    return ans;
}

#define op first//操作,pair成员不用担心跟上面的重
#define ne second//下个状态是啥
/*具体需要几个未知（虽然能算），
  且为了简化代码，就不用数组模拟队列了*/
map<string,int> dist;//来记录每个状态距离起点的距离
map<string,pair<char,string> > pre;
        //记录上一步操作和从哪个变化过来
//1e4左右其实用哈希会更好
int bfs(string st,string ed){
//搜到终点就能结束了，返回走了几步
    if(st==ed) return 0;
    //千万别忘了，一开始就是起点的情况
    //初始化
    queue<string> q;
    q.push(st);
    dist[st]=0;
    while(!q.empty()){
        auto t=q.front();
        q.pop();
        //三种延展形态（操作）
        for(int i=0;i<3;i++){
            string s=move(t,i);//表示整个状态
            //是否重复走过
            if(dist.count(s)) continue;
            dist[s]=dist[t]+1;
            pre[s]={'A'+i,t};//操作和上一个状态
            q.push(s);
            if(s==ed) return dist[s];
        }
    }
    return -1;
}
int main(){
    string  st,ed;//初始为""
    //开始状态
    for(int i=0;i<8;i++) st+=i+'1';
    //结束状态
    for(int i=0;i<8;i++){
        char c;cin>>c;
        ed+=c;
    }
    int step=bfs(st,ed);
    cout<<step<<endl;
    string ans;
    /*这回从起点搜终点，由于每个点只能记录上一个点
      所以从终点往回搜，然后再倒回去就是正常了*/
    while(st!=ed){
        ans+=pre[ed].op;
        ed=pre[ed].ne;
    }
    reverse(ans.begin(),ans.end());
    if(ans[0]) cout<<ans<<endl;
    //别忘了起点就是终点的特殊情况
    return 0;
}
```






# 双端队列广搜
## 电路维修

题目看图

![双端队列1.jpg](https://cdn.acwing.com/media/article/image/2023/10/22/246003_44e12a9470-双端队列1.jpg) 
![双端队列2.jpg](https://cdn.acwing.com/media/article/image/2023/10/22/246003_8ce1203070-双端队列2.jpg) 

```c++
//由于边权只有0/1所以可以用双端队列广搜
        //各种性质的解释看证明
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define x first
#define y second
const int N=510,M=510;
int r,c;
char g[N][M];

int dist[N][M];//到这个点路径长，计算所需的最小旋转次数
bool st[N][M];//判断这条路是否走过（用这个点更新）

//下面的，按从左上开始按顺时针顺序一个一个对应
char cs[]="\\/\\/";//表示四个方向所对应的理想线路
            //这个需要'\'需要转义字符
int dx[4]={-1,-1,1,1};//要到哪个点
int dy[4]={-1,1,1,-1};
int ix[4]={-1,-1,0,0};//要到的那个点所对应的电线
int iy[4]={-1,0,0,-1};
int bfs(){
    //这里根据性质优化，没有其实也能过
        //和为奇数的点是走不到的
    if((r+c)&1) return 1e9;
    //初始化  (多组数据)
    memset(dist,100,sizeof dist);
    memset(st,0,sizeof st);
    deque<pii> q;//双端队列
    q.push_back({0,0});
    dist[0][0]=0;//起点为0，0
    //开始搜
    while(!q.empty()){
        auto t=q.front();
        q.pop_front();
        int x=t.x,y=t.y;//简化一下代码
        if(st[x][y]) continue;//前面走过的，肯定比后面小（区分更新）
        // printf("\n%d %d %d:\n",x,y,dist[x][y]);
        if(x==r&&y==c) return dist[r][c];//找到了，就能提早结束了
        st[x][y]=1;
        for(int i=0;i<4;i++){
            int a=x+dx[i],b=y+dy[i];
            if(a<0||a>r||b<0||b>c) continue;
            int ca=x+ix[i],cb=y+iy[i];
            int w=(g[ca][cb]!=cs[i]);//当跟理想的不符是就要移动
            // printf("%d %d %d %d\n",a,b,dist[a][b],dist[x][y]+w);
            if(dist[x][y]+w<dist[a][b]){
                //注意这里后面更新的不一定比前面大
                dist[a][b]=dist[x][y]+w;
                
                if(w) q.push_back({a,b}); //如果是1插在后面
                else  q.push_front({a,b});//如果是0插在前面
            }
        }
    }
    return dist[r][c];
}
int main(){
    int T;cin>>T;
    while(T--){
        scanf("%d %d",&r,&c);
        for(int i=0;i<r;i++) scanf("%s",g[i]);
        int t=bfs();
        if(t>1e7) printf("NO SOLUTION\n");
        else      printf("%d\n",t);
    }
    return 0;
}
```











## ==双向广搜==

(两个队列的版本)

[**190. 字串变换 - AcWing题库:**](https://www.acwing.com/problem/content/description/192/)

已知有两个字串 $A$, $B$(长度最多为20) 及一组字串变换的规则（至多 $6$ 个规则）:
$A_1 \to B_1$
$A_2 \to B_2$
…

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$、$A_2$ 可以变换为 $B_2…$。

> 例如：$A$＝`abcd` $B$＝`xyz`
> 变换规则为：
> `abc` $\to$ `xu`
> `ud` $\to$ `y`
> `y` $\to$ `yz`
> 则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：
> `abcd` $\to$ `xud` $\to$ `xy` $\to$ `xyz`
> 共进行了三次变换，使得 $A$ 变换为 $B$。

注意，一次变换只能变换一个子串，例如 $A$＝`aa` $B$＝`bb`

变换规则为：`a` $\to$ `b`
此时，不能将两个 `a` 在一步中全部转换为 `b`，而应当分两步完成。

---

### 详细分析:

#### 思路：
双向搜索，就是在起点搜索的过程，终点也在往回搜，从而达到优化的效果。
普通搜索：（绿色点为终点）

![](https://cdn.acwing.com/media/article/image/2022/11/06/109870_e1dbe5f05d-%E6%97%A0%E6%A0%87%E9%A2%98.png)

双向搜索：

![](https://cdn.acwing.com/media/article/image/2022/11/06/109870_eb7ea4c45d-.png)

#### **原则：需要一层层搜**,

二段性会影响答案

> 当存在二段性时
>
> ![一层层 (1).jpg](https://cdn.acwing.com/media/article/image/2024/02/17/246003_3e756ea4cd-一层层-(1).jpg)
>
> ![](https://img-blog.csdnimg.cn/6edc7cbc5ed9444580b127855200508e.png) 
>
> 假设你搜A，如果你先搜到了$y+1$，这时返回结果就是错的

#### **时间复杂度:**$O(2m^{n/2})$

> 每次有m种拓展（假设每次当前字符串，每个规则都刚好只有一种拓展），一共进行n步

	如果是单向时间复杂度为$O(m^n)$

#### 优化场景：

- 再什么拓展，总数也就那样的，一般都不需要

  像搜地图，还是什么最短路，拓展的总数也就那么点，用不用影响都不大

- 拓展总数可能非常大时，就需要了

  

#### 自己的猜想：

（不确定有没有问题）

**大前提：都是一层一层搜**

- 两个方向相遇的点，会在彼此的队列中

- 同时相遇的步数，刚好为step（就是进行了几次拓展）



```java
//双向广搜
//需要一层层搜，去取消二段性
//小优化：每次先搜拓展数量小的
//特判：起点就是终点

//这里会有点不一样，如果没找到返回的是-1，不是一个很大的数
/*猜测(主要是不会证)：
  一切的大前提：都是一层一层搜
  两个方向相遇的点，会在彼此的队列中
  同时相遇的步数，刚好为step（就是进行了几次拓展）*/
import java.util.*;

public class Main{
	static final int N = 10;
	static String A, B;
  //规则的正方向：a->b
	static int n = 0;// 记录规则数
	static String[] a = new String[N];
	static String[] b = new String[N];

	/**
	 * extend函数说明： 
	 * 功能：拓展当前队列的这一层 返回值：如果找到返回总步数，没找到返回-1或者返回一个不可能的数 
	 * extend(当前方向的队列,
	 * 		  当前方向拓展的集合及其搜过来的步数,另一个方向拓展的集合及其搜过来的步数 
	 * 		  操作a,操作b) 
	 * 		 【当前方向对应的变换规则为a->b】
	 */
	static int extend(Queue<String> q, Map<String, Integer> da, Map<String, Integer> db, String[] a, String[] b) {
		int d = da.get(q.peek());// 当前层对应的步数
		while (!q.isEmpty() && da.get(q.peek()) == d) {
			String t = q.remove();
			for (int i = 0; i < n; ++i) {
				// 先不断地找子串等于a[i]的来替换成b[i]
				int k = t.indexOf(a[i]);
				while (k != -1) {
					String x = t.substring(0, k) + b[i] + t.substring(k + a[i].length());// 字串变换
										//这里我真的服啦，a[i]和b[i]的大小不一定相同
					k=t.indexOf(a[i], k+1);//这一步千万别忘了，一定要往下走
					
					if (db.containsKey(x))
						return d + db.get(x) + 1;// 当前拓展找到了
					if (da.containsKey(x))
						continue;// 前面已经找到了
					// 没找到的情况
					da.put(x, d + 1);
					q.add(x);
				}
			}
		}
		return -1;
	}

	static int bfs() {// 返回步数，超过就返回-1
		if (A.equals(B))
			return 0;// 搜索一般都是特判下是否起点就是终点
		// 初始化
		Queue<String> qa = new LinkedList<>();// 正向当前层要搜的
		Queue<String> qb = new LinkedList<>();// 反向
		Map<String, Integer> da = new TreeMap<>();// 正向变过来这个字符串集合以及其步数
		Map<String, Integer> db = new TreeMap<>();// 反向
		qa.add(A);
		da.put(A, 0);
		qb.add(B);
		db.put(B, 0);
		// 双向搜
		// 当前循环具体搜哪个看的是数量小
		int step = 0;
		while (!qa.isEmpty() && !qb.isEmpty()) {
			int t;
			if (qa.size() < qb.size())
			    t = extend(qa, da, db, a, b);
			else
			    t = extend(qb, db, da, b, a);
			
			if (t != -1)
				return t;
			if (++step > 10)//运用猜测的性质，就是step几步，就是表示具体
				return t;
		}
		return -1;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		A = sc.next();
		B = sc.next();
		while (sc.hasNext()) {
			a[n] = sc.next();
			b[n] = sc.next();
			++n;
		}
		int res = bfs();
		if (res != -1)
			System.out.println(res);
		else
			System.out.println("NO ANSWER!");

	}
}
```

**注意：**（唉，全是写出来的bug）

1. 就是**查找字符串时，`pos`一定要注意移动**
1. 然后需要注意题目中的变换规则对应的字符串是不一定相同的



参考：

[参考代码](https://www.acwing.com/activity/content/code/content/2847595/)

[更深理解双向广搜](https://blog.csdn.net/weixin_72060925/article/details/128994885?ops_request_misc=%7B%22request%5Fid%22%3A%22170787862816800213093343%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=170787862816800213093343&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-128994885-null-null.nonecase&utm_term=双向&spm=1018.2226.3001.4450)

[图片来自的题解](https://www.acwing.com/solution/content/147506/)

###  不断查找字符串来替换

注意：`c++的s.find(要找的字符串【,int pos】)`和``java的s.indexOf(要找的字符串【,int pos】)``

1. **每次找完`pos`一定要`+1`**，不然会死循环

2. 两个字符传不一定相同：

   ```java
   				int k = t.indexOf(a[i]);
   				while (k != -1) {
   					String x = t.substring(0, k) + b[i] + t.substring(k + a[i].length());// 字串变换
   										//这里我真的服啦，a[i]和b[i]的大小不一定相同
   					k=t.indexOf(a[i], k+1);//这一步千万别忘了，一定要往下走
   					
   					代码在这写
   				}
   ```



## A*算法

估值函数：一定是需要满足小于实际情况

> 设计：
>
> 1. 哈曼顿距离（场景：上下左右四个方向移动）:
>
>    	$$f(i)=abs(i.x-ed.x)+abs(i.y-ed.y)$$
>
> 2. 对角线距离（场景：8个方向移动）
>
>    	$$f(i)=max(abs(i.x-ed.x),abs(i.y-ed.y))$$
>
> 3. 实际距离（场景：任意方向）
>
>    	$$f(i)=\sqrt{(i.x-ed.x)^2+(i.y-ed.y)^2}$$
>
> 4. 最短路

![Astar算法.jpg](https://cdn.acwing.com/media/article/image/2024/02/19/246003_edaf5052ce-Astar算法.jpg) 
![注意.jpg](https://cdn.acwing.com/media/article/image/2024/02/19/246003_08f60656ce-注意.jpg) 







**输出路径**：需要能查询当前点对应的上一个点【key-value:能查询当前点就是将这个点当成键，上一个点和其它答案需要信息就是值】

> 如果只是坐标的话，用数组就能表示出来
>
> 但是如果字符串或者数字很大等等其他东西，数组不一定能表示，**这时需要使用字典数据结构**



资料：《算法竞赛》这本书对这个算法的描述写得挺好（可以在看看）

参考：题解和oi-wiki

----

### 结点表示特殊&输出路径&一二维的转换

[179. 八数码 - AcWing题库](https://www.acwing.com/problem/content/181/)

在一个 $3×3$ 的网格中，$1 \sim 8$ 这 $8$ 个数字和一个 `x`
恰好不重不漏地分布在这 $3×3$ 的网格中。

例如：

    1 2 3
    x 4 6
    7 5 8

在游戏过程中，可以把 `x`
与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

    1 2 3
    4 5 6
    7 8 x

例如，示例中图形就可以通过让 `x`
先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

    1 2 3   1 2 3   1 2 3   1 2 3
    x 4 6   4 x 6   4 5 6   4 5 6
    7 5 8   7 5 8   7 x 8   7 8 x

把 `x` 与上下左右方向数字交换的行动记录为 `u`、`d`、`l`、`r`。

现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。(结果不唯一)

----

(下面那一堆分析，**都要好好看看**)

![八数码无解.jpg](https://cdn.acwing.com/media/article/image/2024/02/19/246003_2f07ef96ce-八数码无解.jpg) 

```java
//A*算法
	//八数码本身需要：用字符串表示整个状态;一维二维相互转换
/**
 * 本质就是起点最优(dijkstra)+终点最优(贪心最优搜索)的结合
 * A*算法要保证有解，不然复杂度还更高
 * 	(传统的bfs就是肆无忌惮的拓展，
 * 	会有特别的无效点，主要问题就是如何尽可能的去掉无效点)
 * 【符号表示  s:起点;x:当前点;e:终点;
 * 			  f(x):当前点到终点的估值函数;
 * 			  d(i->j):i到j的实际距离】
 * 大大前提：f(x)<=d(x->e)
 * 估值结果=实际（s->x）+估计(x->e)=d(s->x)+f(x)
 * 估值函数f(x)的编写：（这里也想了好久）
 * 		八数码能移动的只有四个方向，所以肯定是用曼哈顿距离
 * 		接下来就是要保证小于实际距离：
 * 			每个数字最终的目标就是回到原位，手段是靠上下左右移动
 * 			而这个数字要想移动，前面就必须要有空格，只能用空格来铺路
 * 			空格最多就只能让数字更近一步，这时空格来到了数字后面，空格还需在来到当前数字的前面
 * 			每个数字要回去，最终消耗肯定大于曼哈顿距离
 * 			（直接这么理解：就是数字要想回去，就必须用空格来铺路，最少最少都要移动曼哈顿距离）
 * 		所以当前点好终点距离的f(x)=所有数字回到原位的曼哈顿距离
 * 			(空格这里不管，全部回到原位了，自然就回去了)
 */
import java.util.*;
class Node{//搜的优先队列
	int d;//起点到终点的估计距离
	String s;//当前状态
	Node(int d,String s){
		this.d=d;
		this.s=s;
	}
	/*法一：//这里用法2：用匿名函数来初始化堆
	@Override
	public int compareTo(Node o) {//快捷键alt+s
		return d-o.d;//-可以助记为小于，java优先队列默认位小根堆
	}*/
}
public class Main{
	//A*算法
	static int f(String x) {//当前点到终点的估值函数
		int res=0;
		char[] cs=x.toCharArray();  
		//直接一维算了
		for(int i=0;i<cs.length;++i) {
			if(cs[i]=='x') continue;
			int t=cs[i]-'1';//从1开始的
			res+=Math.abs(i/3-t/3)+Math.abs(i%3-t%3);//先算行，在列
		}
		return res;
	}
	static String swap(String x,int i,int j) {//交换字符串i和j字符的位置
		StringBuilder y=new StringBuilder(x);
		char t=y.charAt(i);
		y.setCharAt(i,y.charAt(j));
		y.setCharAt(j, t);
		return y.toString();
	}
	/**
	 * A*算法
	 * @param st
	 * @return 路径
	 */
	static String bfs(String st) {
		//偏量法及其对应的四个方向
		int[] dx= {-1,0,1,0};
		int[] dy= {0,1,0,-1};
		String[] op= {"u","r","d","l"};
		
		Map<String,Integer> d=new TreeMap<>();//用当前字符串查询与起点的实际距离
		Map<String,String[]> pre=new TreeMap<>();//用当前字符串查询上一个点，及其变化而来的方向
		
		Queue<Node> q=new PriorityQueue<>((a,b)->{
			return a.d-b.d;//默认就是小根堆，也就是:前d<后d
		});
		String end="12345678x";
		
		q.add(new Node(f(st),st));
		d.put(st,0);
		while(!q.isEmpty()) {
			String t=q.remove().s;//当前字符串
			if(end.equals(t)) break;//只有搜到终点的时候还是最小的
			int step=d.get(t);//肯定是存在的
			int k=t.indexOf('x');
			int tx=k/3,ty=k%3;
			for(int i=0;i<4;++i) {
				int x=tx+dx[i],y=ty+dy[i];
				if(x<0||x>=3||y<0||y>=3) continue;//越界了
				String cur=swap(t,x*3+y,k);
				//step+1就是走到当前的距离
				if(d.containsKey(cur)&&d.get(cur)<=step+1) continue;//当没有比之前走的小
				q.add(new Node(step+1+f(cur),cur));
				d.put(cur,step+1);
				pre.put(cur,new String[]{t,op[i]});//注意这个数据的初始话方式
			}
		}
		//从终点开始搜
		StringBuilder res=new StringBuilder();//由于需要翻转用这个
		while(!end.equals(st)) {
			String[] t=pre.get(end);
			res.append(t[1]);
			end=t[0];
		}
		res.reverse();
		return res.toString();
	}
	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		String st="";
		for(int i=0;i<9;++i) 
			st+=sc.next();
		char[] cs=st.replace("x","").toCharArray();//去掉空格的st
		int cnt=0;//统计有多少逆序对
		for(int i=1;i<8;++i) 
			for(int j=0;j<i;++j) 
				if(cs[i]<cs[j]) ++cnt;
		if((cnt&1)==1) //如果为奇数就是无解
			System.out.println("unsolvable");
		else 
			System.out.println(bfs(st));
	}
}
```



### [第K短路](https://www.acwing.com/problem/content/description/180/)

给定一张 $N$ 个点（编号 $1,2……N$），$M$ 条边的有向图，求从起点 $S$ 到终点 $T$ 的第 $K$ 短路的长度，路径允许重复经过点或边。
**注意：** 每条最短路中至少要包含一条边。

**数据范围：**$1 \le S,T \le N \le 1000$,$0 \le M \le 10^4$,$1 \le K \le 1000$,$1 \le L \le 100$

---

优化：每个点走一次其实就是表示新生成了一条路径，第k短路，仅仅需要k条路径,后面的就不需要了(oi-wiki)。**所以每个点走了k次后就可以不入队了** 
```java
/**
 * A*算法：
 * 	本题的拓展特别多，如果你用像什么最短路算法，那样仅针对起点，肯定不行
 * 	因此使用A*算法针对起点和终点，来减少没用的拓展
 * 	
 * 	估计函数:从当前点到终点的估值
 * 		原则：小于等于实际的距离
 * 		这时可以用dijkstra,把终点作为搜起点，最后一定是小于等于实际值的
 * 
 * 	优化：每个点走一次其实就是表示新生成了一条路径，
 * 		  第k短路，仅仅需要k条路径,后面的就不需要了(oi-wiki)
 * 		  所以每个点走了k次后就可以不入队了 
 * 
 * 	只要是搜索，都要想想起点等于终点的情况
 */
import java.util.*;
public class Main{
		//拿最大值，算一下都不会爆int
	static int N=(int)1e3+10,M=(int)2e4+10;//还需要存反向的边
	static int n,m,S,T,K;
	//邻接表存边
	/*	h正向，rh逆向,存的是当前点的最后一条边,-1表示没有边
	 * 			rh用从终点往前搜
	 * 	ne表示同起点的上一条边
	 * 	e表示当前边的终点
	 * 	w表示边权
	 * 	idx下标分配器
	 * 
	 * 注意下：哪些存边，哪些存点
	 * */
	static int[] h=new int[N],rh=new int[N],e=new int[M],ne=new int[M],w=new int[M];
	static int idx;
	static void init() {
		//邻接表的
		Arrays.fill(h,-1);
		Arrays.fill(rh,-1);
		//最短路的
			//st默认为false
		Arrays.fill(dist,(int)1e9);
	}
	static void add(int[] h,int x,int y,int z) {//需要把表头信息传一下
		ne[idx]=h[x];w[idx]=z;e[idx]=y;h[x]=idx++;
	}
	//dijkstra初始化估值函数
	static int[] dist=new int[N];//由终点出发的最短路，同时也是估值函数
	static boolean[] st=new boolean[N];//判断这个点是否搜过
	static void dijkstra() {
		//int[]:存起点到这个点的距离,这个点
		Queue<int[]> q=new PriorityQueue<>((x,y)-> {
			return x[0]-y[0];//默认小根堆,让权值小的在前
		});
		dist[T]=0;
		q.add(new int[] {0,T});
		while(!q.isEmpty()) {
			int t=q.remove()[1];//只需要用到这个点
			if(st[t]) continue;//搜过了没必要搜了
			st[t]=true;
			for(int i=rh[t];i!=-1;i=ne[i]) {//搜以这个点为起点的所有边
				int d=dist[t]+w[i],y=e[i];
				if(dist[y]>d) {
					dist[y]=d;
					q.add(new int[] {d,y});
				}
			}
		}
	}
	//A*算法  从起点开始
	static int[] cnt=new int[N];//优化：用来记录当前点的遍历次数
	static int astar() {
		//int[]:预测的结果（实际(st->i)+估值(i->ed)）,实际(st->i),当前点i
		Queue<int[]> q=new PriorityQueue<>((x,y)->{
			return x[0]-y[0];
		});
		q.add(new int[] {dist[S],0,S});
		while(!q.isEmpty()) {
			int[] tmp=q.remove();
			int td=tmp[1],t=tmp[2];//t表示当前点，td表示起点到当前的实际距离
			++cnt[t];
			if(t==T&&cnt[t]==K) return td;
			//正向的
			for(int i=h[t];i!=-1;i=ne[i]) {
				int y=e[i];
				if(cnt[y]>K) continue;//这个点已经生成了k条路
				q.add(new int[] {td+w[i]+dist[y],td+w[i],y});
			}	
		}
		return -1;//没有找到的情况
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		init();
		n=sc.nextInt();m=sc.nextInt();
		for(int i=0;i<m;++i) {
			int x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();
			//有向边
			add(h,x,y,z);
			add(rh,y,x,z);//反向存边
		}
		S=sc.nextInt();T=sc.nextInt();K=sc.nextInt();
		if(S==T) ++K;//题目说了，每条最短路至少包含一条边，所以需要特判
		dijkstra();//从终点开始搜，构造估值函数
		System.out.println(astar());
	}
}
```





# `DFS`搜索

(下面这些好好看看)

![dfs概述.jpg](https://cdn.acwing.com/media/article/image/2024/02/22/246003_814a89f8d1-dfs概述.jpg)

注意问题：

- **有多组数据每次都不要忘记初始化**，尤其是那些标记数组

- ==需不需要恢复现场==

## `DFS`之连通性模型(内部搜索)

### [1112. 迷宫](https://www.acwing.com/problem/content/description/1114/)



迷宫可以看成是由 $n * n$的格点组成，每个格点只有2种状态，`.`和`#`，前者表示可以通行后者表示不能通行。

只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，想要从点A走到点B，问在不走出迷宫的情况下能不能办到。

如果起点或者终点有一个不能通行(为#)，则看成无法办到。

**注意** ：A、B不一定是两个不同的点。

**数据范围:**$1 \le n \le 100$

----


```java
//dfs实现
/**
 * 思路：本题就是判断下是否联通
 * 		bfs代码会长一点，还需要自己实现一个队列
 * 		dfs的特判起点和终点都可以放在起点
 */
import java.util.*;
public class Main{
	static final int N=110;
	static int n;
	static int xa,ya,xb,yb;
	static char[][] g=new char[N][N];
	
	static boolean[][] st=new boolean[N][N];//特判是否搜过
	static int[] dx= {-1,0,1,0};
	static int[] dy= {0,1,0,-1};
	static boolean dfs(int x,int y) {
		if(g[x][y]=='#') return false;
		if(x==xb&&y==yb) return true;
		st[x][y]=true;
		for(int i=0;i<4;++i) {
			int a=x+dx[i],b=y+dy[i];
			if(a<0||a>=n||b<0||b>=n) continue;
			if(st[a][b]) continue;
			
			if(dfs(a,b)) return true;
		}
		return false;//都走不到终点
		
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int k=sc.nextInt();
		while(k-- >0) {
			//初始化
			n=sc.nextInt();
			for(int i=0;i<n;++i) {
				char[] cs=sc.next().toCharArray();
				for(int j=0;j<n;++j) {
					g[i][j]=cs[j];
					st[i][j]=false;//别忘记了
				}
			}
			xa=sc.nextInt();
			ya=sc.nextInt();
			xb=sc.nextInt();
			yb=sc.nextInt();
//			Arrays.fill(st,false);//别忘了//注意不能针对二维数组
			if(dfs(xa,ya)) 
				System.out.println("YES");
			else 
				System.out.println("NO");	
		}		
	}
}
```



### `dfs`版洪水填充

[1113. 红与黑 - AcWing题库](https://www.acwing.com/problem/content/1115/)

有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。
你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。
请写一个程序，计算你总共能够到达多少块黑色的瓷砖。(先输入列数)
**数据范围**：1≤行和列≤20

---

```java
//dfs实现flood fill
import java.util.*;
public class Main{
	static final int N=30;
	static int n,m;
	static char[][] g=new char[N][N];
	
	static int sx,sy;
	static boolean[][] st=new boolean[N][N];//判断是否填充过
	static int[] dx= {-1,0,1,0};
	static int[] dy= {0,1,0,-1};
	static int dfs(int x,int y) {
		//题目说了第一个起点是黑的，现在就在拓展时判断就行
		st[x][y]=true;
		int ans=1;
		for(int i=0;i<4;++i) {
			int a=x+dx[i],b=y+dy[i];
			if(a<0||a>=n||b<0||b>=m) continue;
			if(st[a][b]||g[a][b]=='#') continue;
			ans+=dfs(a,b);
		}
		return ans;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		//多组数据别忘记所有的初始化,尤其是st数组
		while(true) {
			//这题比较坑，先输入列的
			m=sc.nextInt();
			n=sc.nextInt();
			if(n==0&&m==0) break;
			for(int i=0;i<n;++i) {
				char[] cs=sc.next().toCharArray();
				for(int j=0;j<m;++j) {
					g[i][j]=cs[j];
					st[i][j]=false;//别忘了
					if(g[i][j]=='@') {
						sx=i;
						sy=j;
					}
				}
			}
			System.out.println(dfs(sx,sy));
		}
	}
}
```



[AcWing 1402. 星空之夜（每日一题） - AcWing](https://www.acwing.com/activity/content/problem/content/9798/1/Java/)

### 洪水填充+联通块的哈希 （联通点的存储，好好看一下）

一个星群是指一组非空的在水平，垂直或对角线方向相邻的星星的集合。
如果两个星群的形状、包含星星的数目相同，那么无论它们的朝向如何，都认为它们是相似的。
通常星群可能有 $8$ 种朝向，如下图所示：
![](https://cdn.acwing.com/media/article/image/2020/03/03/19_6107c0e05d-starry-1.gif)
现在，我们用一个二维 $01$ 矩阵来表示夜空，如果一个位置上的数字是 $1$，那么说明这个位置上有一个星星，否则这个位置上的数字应该是 $0$。
给定一个夜空二维矩阵，请你将其中的所有星群用小写字母进行标记，标记时相似星群用同一字母，不相似星群用不同字母。
标注星群就是指将星群中所有的 $1$ 替换为小写字母。

输出：用最小字典序输出

样例：

输入：

```
23				宽
15				长
10001000000000010000000
01111100011111000101101
01000000010001000111111
00000000010101000101111
00000111010001000000000
00001001011111000000000
10000001000000000000000
00101000000111110010000
00001000000100010011111
00000001110101010100010
00000100110100010000000
00010001110111110000000
00100001110000000100000
00001000100001000100101
00000001110001000111000
```

输出：

```
a000a0000000000b0000000
0aaaaa000ccccc000d0dd0d
0a0000000c000c000dddddd
000000000c0b0c000d0dddd
00000eee0c000c000000000
0000e00e0ccccc000000000
b000000e000000000000000
00b0f000000ccccc00a0000
0000f000000c000c00aaaaa
0000000ddd0c0b0c0a000a0
00000b00dd0c000c0000000
000g000ddd0ccccc0000000
00g0000ddd0000000e00000
0000b000d0000f000e00e0b
0000000ddd000f000eee000
```

![](https://cdn.acwing.com/media/article/image/2020/03/03/19_41fd00a45d-starry-2.gif)

标记后的结果：

![](https://cdn.acwing.com/media/article/image/2020/03/03/19_7a5ce3ec5d-starry-3.gif)

**数据范围：**$0 \le W,H \le 100$,$0 \le$ 星群数量 $\le 500$,$0 \le$ 不相似星群数量 $\le 26$,$1 \le$ 星群中星星的数量 $\le 160$

----

> **比较特殊，最好就是把这种哈希方式直接记住**
>
> 不用曼哈顿距离和开了方的原因就是尽可能避免冲突
>
> ![IMG20240428222413.jpg](https://cdn.acwing.com/media/article/image/2024/04/28/246003_4d34e99405-IMG20240428222413.jpg) 




```java
/**
 * 洪水填充+图形的哈希映射优化
 * 	本题哈希方式比较少见直接记吧，这个感觉可以用在旋转+对称图形等价时特别好用
 */
/**
 * 步骤：
 * 	1.求联通块：flood fill
 * 	2.区别星群：
 * 		{提一下暴力做法（实现起来很复杂）
 * 
 * 			在搜索星群的过程中将每个星群对应的所有坐标存储下来【坐标转移到原点处，保证相同坐标参考系】。
 * 			之后为每个星群生成所有可能的八个相似模板【旋转/翻转】，
 * 			再去匹配数量相同的星群是否存在相同的模板对。
 * 			（参考后面的资料）
 * 		}
 * 		（这个哈希跟字符串一样，不能保证无冲突，但是保证大概率不冲突）
 * 		这里还用哈希影射把图形映射到一个数上，下面的用的是让旋转与对称都不影响哈希值
 * 		联通块的哈希值=sum(两点之间距离)
 * 				（这里不用曼哈顿距离和开方，是为了减少冲突，实在害怕冲突，使用双哈希）
 * 	3.字典序的判断：从左往右扫，字母按顺序赋就行
 */
/**
 * eps=1e-8
 * 浮点数判断：
 * 	A=B:	|A-B|<eps	(这个用比较多)
 * 	A<B:	A<B-eps
 * 	A<=B	A<B+eps
 */
import java.io.*;
import java.util.*;
class Pair{
	public Pair(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
	int x,y;	
}
public class Main{
	static final int N=(int)110,M=170;//M存的是点的个数
	static final double eps=1e-8;//避免浮点误差
	
	static int n,m;
	static char[][] g=new char[N][N];//存下整张图
		//这里用的是数组模拟队列，方便后续判断图形
	static Pair[] q=new Pair[M];//存下联通块
	static int tt;//队列指针
		//这里映射的哈希值由于是个浮点数，是不准确，因此无法准确的定位到一个key，所以还是用数组存，到时候暴力找
	static double[] hash_val=new double[30];//每个下标对应的哈希值
	static int len;//当前用到了哪个字母
	
	//bfs实现麻烦太多了，这里直接用dfs实现洪水填充了，因为自带了一个栈
	//dfs版洪水填充
	static void dfs(int a,int b) {
		q[++tt]=new Pair(a,b);
		g[a][b]='0';//标记一下
		for(int x=a-1;x<=a+1;++x) 
			for(int y=b-1;y<=b+1;++y) {
				if(x<1||x>n||y<1||y>m||g[x][y]!='1')
					continue;
				dfs(x,y);
			}
	}
	
	static double get_dist(Pair a,Pair b) {
		double dx=a.x-b.x,dy=a.y-b.y;
		return Math.sqrt(dx*dx+dy*dy);
	}
	//联通块的哈希映射
	static double get_hash() {
		double sum=0;
		for(int i=0;i<=tt;++i) 
			for(int j=i+1;j<=tt;++j) 
				sum+=get_dist(q[i], q[j]);
		return sum;
	}
	//通过哈希值，找到的标记
	static char get_id() {
		double val=get_hash();
		for(int i=0;i<len;++i) 
			if(Math.abs(hash_val[i]-val)<eps) //判断哈希值是否想等
				return (char)('a'+i);
		//不存在需要创建
		hash_val[len++]=val;
		return (char)('a'+len-1);
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		m=sc.nextInt();n=sc.nextInt();
		String ss;
		for(int i=1;i<=n;++i) {
			ss=" "+sc.next();
			g[i]=ss.toCharArray();
		}
		//洪水填充+哈希映射
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=m;++j) {
				if(g[i][j]=='1') {
					tt=-1;
					dfs(i,j);
					//寻找哈希映射后的对应的字母
					char id=get_id();
					//标记下联通块位置
					for(int k=0;k<=tt;++k) 
						g[q[k].x][q[k].y]=id;
				}
			}
		}
		
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=m;++j) {
				System.out.print(g[i][j]);
			}
			System.out.println();
		}
		
	}
}
```



## DFS之搜索顺序(外部枚举)

 

### 二维遍历（选当前个）

(这个是外部遍历，把整体当成一个状态，会记录下**当前顺序每个点的影响**每个点的影响)

**注意看这个模板的标记和回溯的位置，是标记当前个**：(跟之前写的模板都不太一样)

> 将标记和恢复当前个，当写在了拓展外面

- 能避免一些边界问题，不用特殊处理起点
-  不用初始化

注意事项：

- **`cnt`初始起点为1，要从1开始**【`cnt`表示选了几个点，**包括当前点**】



[1116. 马走日 - AcWing题库](https://www.acwing.com/problem/content/description/1118/)

马在中国象棋以日字形规则移动。
请编写一段程序，给定 $n*m$ 大小的棋盘，以及马的初始位置 $(x，y)$，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。

数据范围:$1 \le T \le 9$,$1 \le m,n \le 9$,$1 \le n \times m \le 28$,$0 \le x \le n-1$,$0 \le y \le m-1$

----

```java
//dfs遍历
	//注意看这个模板，只看当前位置选与不选，能避免边界问题
import java.util.*;
public class Main{
	static final int N=15;
	static int n,m;
	static int sx,sy;//开始位置
	static boolean[][] st=new boolean[N][N];
	static int ans;
	static int[] dx= {-1,-2,-2,-1,1,2,2,1};
	static int[] dy= {-2,-1,1,2,2,1,-1,-2};
	//二维版有多种拓展的模板
	static void dfs(int x,int y,int cnt) {
		if(cnt==n*m) {
			++ans;
			return;
		}
		st[x][y]=true;//标记
		for(int i=0;i<8;++i) {
			int a=x+dx[i],b=y+dy[i];
			if(a<0||a>=n||b<0||b>=m) continue;
			if(st[a][b]) continue;
			dfs(a,b,cnt+1);
		}
		st[x][y]=false;//恢复
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int T=sc.nextInt();
		while(T-- >0) {
			n=sc.nextInt();
			m=sc.nextInt();
			sx=sc.nextInt();
			sy=sc.nextInt();
			ans=0;
			dfs(sx,sy,1);
			System.out.println(ans);
		}
		
	}
}
```



### 枚举拼接字符串

[1117. 单词接龙 - AcWing题库](https://www.acwing.com/problem/content/1119/)

现在我们已知一组单词，且给定一个开头的字母，要求出**以这个字母开头**的最长的“龙”，每个单词最多被使**用两次**。
在两个单词相连时，其重合部分合为一部分，例如`beast`和`astonish`，如果接成一条龙则变为`beastonish`。
我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 `at` 和 `atide` 间不能相连。

**输入格式**：输入的第一行为一个单独的整数 $n$（$n<=20$） 表示单词数，以下 $n$ 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。

----
也是外部遍历，每次**按这个遍历顺序**的影响会记录下来

```java
//dfs枚举
	//这里也是只改变时只作用在当前遍历的变量，避免在dfs外还需要特殊处理
import java.util.*;
public class Main{
	static final int N=30;
	static int n;
	static String[] word=new String[N];//对象类型小心了
	static int[][] g=new int[N][N];//表示i位置子符串与j位置子符串拼接重合的最小长度
							//这样连接才能最长
	static int[] cnt=new int[N];//表示每个字符用了几个
	static int ans;
	/**
	 * 注意：在当前枚举才选上当前
	 * @param dragon 当前拼接成的字符串
	 * @param last	 上一个拼接的单词
	 */
	static void dfs(String dragon,int last) {
		ans=Math.max(dragon.length(),ans);
		//在拓展外部标记和恢复
		++cnt[last];
		for(int i=0;i<n;++i) {
			if(g[last][i]!=0&&cnt[i]<2) {
				dfs(dragon+word[i].substring(g[last][i]) ,i); 
			}
		}
		--cnt[last];
		//没找到会自动结束
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		for(int i=0;i<n;++i) 
			word[i]=sc.next();
		char start=sc.next().charAt(0);//别忘记还有一个开头
		
		//预处理下：每个字符串之间的连接
		for(int i=0;i<n;++i) 
			for(int j=0;j<n;++j) {//包括自身，会用到两次以上
				//使拼接a和b最长
				String a=word[i],b=word[j];
				//重合部分的长度
				for(int len=1;len<Math.min(a.length(),b.length());++len) 
								//小细节：题目说了严格小于两字符串的长度
					if(a.substring(a.length()-len).equals(b.substring(0,len))) {
						g[i][j]=len;
						break;//第一次找到的就是最好的结果
					}
			}
		//找开头字符，才能遍历
		for(int i=0;i<n;++i) 
			if(start==word[i].charAt(0)) 
				dfs(word[i],i);//选当前个，这里就不需特殊处理起点
		System.out.println(ans);	
	}
}
```





### 分组枚举（重要，但还不熟）

[1118. 分成互质组 - AcWing题库](https://www.acwing.com/problem/content/1120/)

给定 $n$ 个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？

----

这里有组同样的数据数据：`3 6 10 5`
用这种贪心分组法的话，会分成

第一组：`3，10`
第二组：`6，5`

但是这里换下顺序：`3 6 5 10`
会分成

第一组：`3,5`
第二组：`6`
第三组：`10`
答案是错的，而且显然贪心不能因为顺序改变就改变答案



#### 解1:枚举每一组能放哪些元素（需要特别多剪枝时）

(下面那个画黄色的那题可以好好看看)

> 对每一组的要求特别严格时，每组的和都要是一个数

这里写的就是按y总的分组枚举思路：

> 对于每个数：①要么放最后一组②新开一组（不放其他组）
>
> 			(每次都要从头到尾遍历一遍)
>
> 贪心优化：
>
> > 当一个数符合①时，不在进行②操作
> >
> > 解释：
> >
> > >  如果能放到当前最后一组i，但是选择新开一组i+1，此时不能在第i组放任何东西了，显然放在最后一组从分组的情况还是对后续的影响都会比新开好很多	
> >
> > 拓展下，就是最后一组还能再放下数，就在此基础下新开一组了

缺点：会有特别多的冗余情况，但是数据量很小也是小问题，后面会讲如何剪枝

(注意看看下面各种数组的含义，理解如何不漏的地去缩)

```java
//dfs分组遍历
import java.util.*;
public class Main{
	static final int N=10;
	static int n;
	static int[] arr=new int[N];
	
	static int[][] group=new int[N][N];//各个分组，c++用vector更简单,java太麻烦了
	static boolean[] st=new boolean[N];//是否被选过
			//原本想用set集合，重复是不会影响答案，但是数据量小差不了多少
	static int ans;//先初始化为最大值
	static int gcd(int x,int y) {//最大公约数
		return y==0?x:gcd(y,x%y);
	}
	/**
	 * 判断当前组能否放下第k个数
	 * @param g:当前组
	 * @param gc:当前组的个数
	 * @param k:第k个数
	 * @return
	 */
	static boolean check(int g,int gc,int k) {
		for(int i=0;i<gc;++i) {
			if(gcd(group[g][i],arr[k])!=1)
				return false;
		}
		return true;
	}
	/**
	 * 分组枚举
	 * @param g:当前组
	 * @param gc:当前分组有几个数
	 * @param cnt:已分组的个数
	 * @param start："当前组"从哪个数开始遍历（注意）
	 * 				注意下：这个数前面的情况
	 * 					1.已经在当前组2.选不了3.之前选过，现在不选
	 * 这些很多其实是可以放在全局变量里面，但是也没啥差
	 * @return
	 * 重点是尽量不重但是一定不漏的去搜
	 * 注意：如果是参数的话，所有的变化直接体现在参数上就行
	 */
	static void dfs(int g,int gc,int cnt,int start) {
		if(g>=ans) return;//优化：剪枝+结束条件(重要)
			//比当前最优解组数更多，不可能为最优解
		if(cnt==n){//（要配合上一句的）已经搜完所有点，这个解就是当前最优解
			 ans=g;
			 return;
		}
		boolean flag=true;//小小贪心优化：如果还有数能放进当前组，那么在此基础上没必要新建一组
		//当前组上加
		for(int i=start;i<n;++i) {
			if(!st[i]&&check(g,gc,i)) {
				st[i]=true;
				group[g][gc]=arr[i];
				dfs(g,gc+1,cnt+1,i+1);
				//恢复现场
				st[i]=false;
				flag=false;//还能选数
				if(gc==0) return;//这里是超级剪枝
					//没有这句也能过，但是能优化特别多
					//避免等效冗余：组与组之间的顺序所导致重复
			}
		}
		//新开一组
		if(flag) dfs(g+1,0,cnt,0);
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		ans=n;
		for(int i=0;i<n;++i) 
			arr[i]=sc.nextInt();
		dfs(1,0,0,0);
		System.out.println(ans);
	}
}
```

##### 剪枝优化:

1. **如果没有之前的情况好，直接剪掉**（==很常用==）

   ![剪枝优化1.png](https://cdn.acwing.com/media/article/image/2024/02/22/246003_68a4317ed1-剪枝优化1.png) 

2. **去掉一些同样的情况**:

   ![剪枝优化2.png](https://cdn.acwing.com/media/article/image/2024/02/22/246003_b4f5048bd1-剪枝优化2.png) 

   > 这题会存在一些同样的情况，就是一些顺序问题:
   >
   > 以样例`3,6,10,5`为例：（更正）
   >
   > ![质数组-剪枝优化.jpg](https://cdn.acwing.com/media/article/image/2024/04/08/246003_a9642427f5-质数组-剪枝优化.jpg)  

#### 解2:枚举元素放哪一组(一般用这个)

（这个解法会更直接点，更符合组合，一般情况都更优）

```java
//dfs分组遍历
	//看每个元素需要分到那一组
import java.util.*;
public class Main{
	static final int N=15;//注意开多一点
	static int n;
	static int[] arr=new int[N];
	
	static int len=1;//表示当前有几组
	static int[][] group=new int[N][N];//各个分组，c++用vector更简单,java太麻烦了
	static int[] gc=new int[N];//每个分组各个的个数
	static int ans;//先初始化为最大值
	static int gcd(int x,int y) {//最大公约数
		return y==0?x:gcd(y,x%y);
	}
	/**
	 * 判断当前组能否放下第k个数
	 * @param g:当前组java
	 * @param k:第k个数
	 * @return
	 */
	static boolean check(int g,int k) {
		for(int i=0;i<gc[g];++i) {
			if(gcd(group[g][i],arr[k])!=1)
				return false;
		}
		return true;
	}
	/**
	 * 分组遍历:
	 * 		当前元素要选到哪一组
	 * @param x：当前遍历的元素编号
	 */
	static void dfs(int x) {
		if(len>=ans) return;//剪枝优化
		if(x==n) ans=len;//跟上面的解法一个道理
		//看已经存在的组
		for(int i=0;i<len;++i) {//枚举所有组
			if(check(i,x)) {
				group[i][gc[i]++]=arr[x];
				dfs(x+1);
				--gc[i];//假删就行
			}
		}
		//新开一组
		group[len][gc[len++]++]=arr[x];//注意：运算顺序
		dfs(x+1);
		--gc[--len];//运算顺序
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		ans=n;
		for(int i=0;i<n;++i) 
			arr[i]=sc.nextInt();
		dfs(0);
		System.out.println(ans);
	}
}
```

注意下运算顺序



参考：

[y总解法评论里的剪枝优化](https://www.acwing.com/activity/content/code/content/134221/)
[AcWing 1118. 分成互质组(y总代码版的保姆级注释) - AcWing](https://www.acwing.com/solution/content/56339/)
[两种解法](https://www.acwing.com/solution/content/10364/)





## DFS之剪枝与优化

1. 优化搜索顺序

   **分支数量少的先搜**，这样能少很多分支（**只要针对题目的主要限制条件**）

   > 比如：分组搜索中，**先放入很大的**，这时只能新开一组，如果先放的是轻的，分支会多很多

   一般就是先搜大的

2. 排除等效冗余

   把那些重复搜的情况给去掉

   > 例如：分组枚举时不同顺序导致了重复搜

3. 可行性剪枝：

   如果已经发现不合法，直接剪掉

4. 最优性剪枝：

   特别是那些求最优值的，**跟现在的最优值对比**，如果没比人家好，直接剪

5. 记忆化搜索（DP）

注意：**如果需要找到答案就立刻返回，又有多组数据的，一定要注意初始化**

### 分组枚举的剪枝优化

(这里多加了个优化搜索顺序)

[165. 小猫爬山 - AcWing题库](https://www.acwing.com/problem/content/167/)

 $N$ 只小猫要去下山，但是不想徒步只，好花钱让它们坐索道下山。
索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1、C_2……C_N$。
当然，每辆缆车上的小猫的重量之和不能超过 $W$。
每租用一辆缆车，翰翰和达达就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？
**数据范围：**$1 \le N \le 18$,$1 \le C_i \le W \le 10^8$

---
> 数据范围过大了，没法用`dp`时间换空间
```java
//分组dfs
	//具体看上面那一题
import java.util.*;
public class Main{
	static final int N=25;
	static int n,w;
	static Integer[] c=new Integer[N];//涉及到排序，还是等下面在初始化
			//不然不好逆序排序
	
	static int ans=N;//记录下答案，同时又来剪枝
	static int len=1;//当前有几组
	static int[] sum=new int[N];//每组对应质量
	static void dfs(int x) {//自带排除等效冗余剪枝
		if(len>=ans) return;//最优性剪枝
		if(x==n) {//需要跟上面的配合用
			ans=len;
			return;
		}
		//枚举之前的每一组
		for(int i=0;i<len;++i) {
			if(w-sum[i]>=c[x]) {//当前组能装下(其实也是可行性剪枝)
				sum[i]+=c[x];
				dfs(x+1);
				//恢复
				sum[i]-=c[x];
			}
		}
		//新开始一组
		sum[len++]=c[x];
		dfs(x+1);
		sum[--len]=c[x];//注意运算顺序
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		w=sc.nextInt();
		for(int i=0;i<n;++i)
			c[i]=sc.nextInt();
		
		//优化搜索顺序=>大的之前分支更少
		Arrays.sort(c,0,n,Comparator.reverseOrder());//用逆序排序[0,n)（降序）
				//注意不能是基础类型
		dfs(0);
		System.out.println(ans);
	}
}
```



### [166. 数独](https://www.acwing.com/problem/content/description/168/)(DFS剪枝优化，找到答案后立刻返回)

> 找到答案后**立刻返回**一般就是每个调用`dfs()`的地方都要有一个返回值，**触发链式反应**

[数独](https://baike.baidu.com/item/数独/74847?fr=aladdin) 是一种传统益智游戏，你需要把一个 $9×9$ 的数独补充完整，使得数独中每行、每列、每个 $3×3$ 的九宫格内数字 $1∼9$ 均恰好出现一次。

![](https://bkimg.cdn.bcebos.com/pic/9825bc315c6034a8cb048a23cb134954082376a9?x-bce-process=image/format,f_auto/resize,m_lfit,limit_1,h_284)

----

思路：每次枚举当前格子的拓展，直到所有格子选完

> 一二维相互转换

#### 用二进制状压(存下每个格子能选的数)+预处理结果

1. 需要同时符合行、列和大方格，可以用二进制存能存的数

   然后再交集（与运算）就能得到这个位置能选什么

2. 可以将`lowbit(x)`对应哪一位上的数和每个数对应几个$1$预处理出来

#### **剪枝优化：**

1. 优化搜索顺序：每次遍历剩下的格子，看分支数最少的是哪一个

> 综合整个代码来看，直接遍历整个数组就行了
>
> > 如果你想用优先队列，反倒变麻烦，每次拓展，都要改变行，列和大方格的所有记录

2. 排除等效冗余：本身就没有冗余

> 每一层都只枚举一个格子的所有拓展情况，一般是不会有冗余的
>
> 当前格子选完后，看剩下的格子，不会在回头选了（没有顺序问题）

3. 可行性剪枝：知道不合法就不要进入了

> 用行，列和大方格的情况来特判

4. 本题找到答案后就可以立刻退出

```java
//dfs剪枝优化--枚举每个位置的可能
import java.util.*;
public class Main{
	static final int N=9,M=1<<N;//521
	static char[] s=new char[100];//数独：9*9
	
	static int lowbit(int x) {
		return x&-x;
	}
	//打个查询表(预处理)
		//ones[i]:i一共有几个1
		//map[i]:当前选哪一位（最高位的1在哪里）【有点浪费，可以用字典，但是值不大也无所谓】
	static int[] ones=new int[M],map=new int[M];
	
	//行、列、大方格中能填什么(位运算优化)
		//每个位置上能填1~9=>每一位对应一个数
	static int[] row=new int[N],col=new int[N];
	static int[][] cell=new int[3][3];
	//当前格子能填什么
	static int get(int x,int y) {//取个交集：要所有都符合才能填
		return row[x]&col[y]&cell[x/3][y/3];
	}
	
	
	/**
	 * 选或删这个位置：
	 * 如果is_set是真，则将(x,y)这个位置填上k
	 * 			  假，则将(x,y)原本值为'k+1'的填上'.'
	 * 并记录下对行、列和方格的影响
	 * @param x
	 * @param y
	 * @param k:二进制表示下对应哪一位
	 * @param is_set
	 * 
	 * 选了的话，这个位置就不能填了，变为0
	 */
	static void draw(int x,int y,int k,boolean is_set) {
		int v=1<<k;//表示选了第k位
		if(is_set) {
			s[x*N+y]=(char)('1'+k);//转为一维
		}else {
			s[x*N+y]='.';
			v=-v;//又不选了
		}
		//注意是减
		row[x]-=v;
		col[y]-=v;
		cell[x/3][y/3]-=v;
	}
	/**
	 * 初始化行、列和方格的情况
	 * @return 需要填多少个格子
	 */
	static int init() {
		Arrays.fill(row,M-1);
		Arrays.fill(col,M-1);
		for(int i=0;i<3;++i) Arrays.fill(cell[i],M-1);
		
		//一开始就当作一个没填，在一个个慢慢填
		int cnt=0;
		for(int i=0;i<N;++i) {
			for(int j=0;j<N;++j) {
				if(s[i*N+j]=='.') 
					++cnt;//需要填
				else 		
					draw(i,j,s[i*N+j]-'1',true);//为这个位置填上对应的数
			}
		}
		return cnt;
	}
	/**
	 * 枚举剩下的格子该填什么
	 * @param cnt 还剩几个没填(减着遍历)
	 * @return 
	 * 当找到答案后就可以结束了，没必要在继续填了,这就是返回值的作用
	 * 
	 * 必定是没有等效冗余的情况：
	 * 		每次只会搜可能最小且最前的一个格子（只有一个）
	 * 		这个格子选完以后，就不会在被选了(没有选择顺序问题)
	 */
	static boolean dfs(int cnt) {
		if(cnt==0) return true;
		//优化搜索顺序剪枝：找到分支数最少的
		int minv=10;//极大值
		int x=0,y=0;
		for(int i=0;i<N;++i) 
			for(int j=0;j<N;++j)
				if(s[i*N+j]=='.') {//没填过
					int state=get(i,j);//当前格子能填所有数
					if(ones[state]<minv) {//有几个数能填
						minv=ones[state];
						x=i;
						y=j;
					}
				}
		//给这个格子填数
		int state=get(x,y);
		for(int i=state;i!=0;i-=lowbit(i)) {
			int k=map[lowbit(i)];//当前是哪一位
			draw(x,y,k,true);
			if(dfs(cnt-1)) return true;//成功了，直接返回
			draw(x,y,k,false);//恢复
		}
		return false;//没有填成功
	}
	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		//预处理
			//最高位的1在哪
		for(int i=0;i<N;++i) map[1<<i]=i;
			//当前数有几个1
		for(int i=0;i<M;++i) 
			for(int j=i;j!=0;j-=lowbit(j)) //不断减去末尾的1
				ones[i]+=1;
		
		while(true) {
			String st=sc.next();
			if("end".equals(st)) break;
			s=st.toCharArray();
			//初始化
			int cnt=init();
			dfs(cnt);
			System.out.println(new String(s));//char数组能初始化String
		}
	}
}
```

> `draw`：涂色函数设计挺妙的，还能还原

参考：[AcWing 166. 数独【详细注释版】 - AcWing](https://www.acwing.com/solution/content/31873/)





### 分组枚举且每组的总和一样(==分组的方式不一样==)

> 忘了就看看前面写的分组枚举模板

**这些剪枝方式直接记**，试了下其他的优化，都失败了(唉，我的时间呀)

> 优化搜索顺序
>
> 分组枚举：
>
> 	头没有成功就剪，能变成成组合
> 	
> 	特殊：尾没有成功，减（后面又凑出这个数没有意义了）
> 	
> 	跳过相同元素

[167. 木棒 - AcWing题库](https://www.acwing.com/problem/content/description/169/)

乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 $50$ 个长度单位。(木棍总数不超过$64$)(每一节木棍的长度都用大于零的整数表示）
然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。
请你设计一个程序，帮助乔治计算木棒的可能最小长度。

（木棍长度最长也不会超过50）

----

（**本题写出了一堆bug出来,好好看看**）

剪枝再题解里面写得比较清楚，具体证明看代码的注解

这里讲下一些注意事项：

> 1. 本题枚举方式最好采用枚举组内元素的方式（**一组枚举完在一下**）
>
>    本题限的很死，就是每组的总长都是固定的，**只要有一组不是恰好等于都不行**，这样可以少枚举很多情况
>
>    还有一些等长的等效冗余，很难剪掉
>
> 2. `for`循环中找下一个不同的，循环最优有`++i`，并且不一定能到`j`那边所以`i`应当要指向最后一个相等就是`i=j-1`
>
>    ```c++
>    for(int i=start;i<n;++i) {
>        /*中间一堆操作,可能中途退出*/
>        int j=i+1;
>        for(;j<n;++j) {
>            if(w[j]!=w[i]) break; 
>        }
>        i=j-1;
>    }
>    ```
> 3. **多组数据别忘记初始化了**
>

```java
//分组dfs使每组的总长一样
	//木棒有多个木棍组成
/**
 * 思路：枚举木棒的长度=>枚举每个分组
 * 注意几点：
 * 	1.本题找到答案（true）会立刻返回且有多组数据，还需要注意初始化问题
 * 	2.最后还是按y总的，枚举组内有哪些元素会比较好
 * 		原本是按枚举元素该分到哪一组，发现部分剪枝优化不好整
 * 		比如像长度相同的木棍不需要放一个位置
 * 	3.这里不要把集合那些已经选过的剔除，因为会存在重复的元素
 * 	4. 有dfs返回值的地方都要return
 */
	
	
import java.io.*;
import java.util.*;
public class Main{
	static final int N=70;
	static int n;
	static Integer[] w=new Integer[N];
	
	static int sum,length;//总长和当前木棒的长度
	static boolean[] st=new boolean[N];//当前木棍是否被选过
	/**
	 * 枚举每个分组里的元素，使分组的总长为length
	 * @param g:当前分组
	 * @param cur:当前分组木棒的长度
	 * @param start:当前分组先要从哪个数开始
	 * @return 能否成功
	 * 注意：有dfs返回值的地方都要return dfs();
	 */
	static boolean dfs(int g,int cur,int start) {
		if((g+1)*length==sum) return true;//最后一组不用看，一定能拼成
		if(cur==length) return dfs(g+1,0,0);//满了就新开一组
		for(int i=start;i<n;++i) {
			if(st[i]||cur+w[i]>length) continue;//已经用过了，就要跳过
			st[i]=true;//选上
			if(dfs(g,cur+w[i],i+1))
				return true;
			//这样没有成功
			st[i]=false;//恢复
			
			//一堆剪枝
			if(cur==0) return false;
			/**
			 * 	剪枝：排除等效冗余(更正)
			 * 		1.每组的顺序本来就是升序，组与组之间因为顺序不同所导致的重复问题
			 			解决：当为组内的第一个时，后续这一层就没必要继续了
			 * 		2.无法用把当前木棍作为开头
			 * 			第一次使用木棍如果无法放在第一根，当前方案已经不可能了
			 * 			后续的方案，交换一下也能将当前木棍放在第一根，
			 * 			就是只要存在这跟木棍就是不可能
			 */
			if(cur+w[i]==length) return false;
			/**
			 * 	剪枝：排除等效冗余
			 * 		无法将当前木棍作为结尾(本质上和上面使相同的)
			 * 		反证：
			 * 			如果用当前木棍最终凑出了length，但是最终还是失败了
			 * 			假定后续还有可能用多根木棍使当前组凑出length，并成功了
			 * 			那么用当前木棍交换到这个位置也能，矛盾了
			 */
			int j=i+1;
			for(;j<n;++j) {
				if(w[j]!=w[i]) break; 
			}
			i=j-1;//for循环中注意了，还会++，要么就别++了
			/**
			 * 剪枝：排除等效冗余	
			 * 		当前位置放相同的长度是没有意义的，前面已经搜过不行了
			 */
		}
		//这里无需新开一组，每一组都要凑齐才新开
		return false;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		while(true) {
			//初始化:用到的都要初始化
			Arrays.fill(st,false);
			sum=0;
			length=1;
			n=sc.nextInt();
			if(n==0) break;
			for(int i=0;i<n;++i) {
				w[i]=sc.nextInt();
				sum+=w[i];
			}
			
			//剪枝：优化搜索顺序
			Arrays.sort(w,0,n,(a,b)->{//从大到小排，这样分支会少很多
				return b-a;
			});
			while(length<=sum) {
				if(sum%length==0&&dfs(0,0,0)) {
					System.out.println(length);
					break;
				}
				++length;
			}
		}
	}
}
```

> 这里排除等效冗余：只用了每组的开头和结尾
>
> > **不用看了**，试了下不行，还是会超时
> >
> > (只能是同层的`dfs`)感觉还能再剪，就是前面某个长度已经不行了，然后又凑出了同长度，可以剪掉。（跟那个结尾是同理的，这个毕竟是组合么，但是不一样呀，结尾那个能更早排除）
> >
> > 如果你用这个剪枝：就不用再判断相等元素了的剪枝，自动跳过

资料：剪枝证明：[DFS之剪枝下面的评论](https://www.acwing.com/file_system/file/content/whole/index/content/137679/)





> 整理一波：
>
> 对于像这种组合的:
>
> - 就是当前已经成功凑出一组，但还是失败，当前方案不行
>
> - 避免组与组之间的顺序导致的重复
>
>   > 也就是如果当前组的一个，但是还是失败了，后面在枚举都是重复的
>
> - 避免同值，直接跳到下一个值
>
> 
>
> > 不行的主要原因是因为能替换

> 像什么判断同一组的总和一样还是算了吧，目前还没找到比较好的代码，最多只能跳过相同值的元素

> **设计规范**：
>
> - 新开一组放在结束条件后面
>
>   > 减少在循环内的判断
>
>   > 看看上面咋设计的
>
> 
>
> 





### 剪枝：用数学:求精确范围+预估答案提前剪枝

[168. 生日蛋糕 - AcWing题库](https://www.acwing.com/problem/content/description/170/)

一个体积为 $Nπ$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。

设从下往上数第 $i$ 层蛋糕是半径为 $R_i$，高度为 $H_i$ 的圆柱。
当 $i < M$ 时，要求 $R_i > R_{i+1}$ 且 $H_i > H_{i+1}$。

由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。
令 $Q = Sπ$ ，请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $R_i$ 和 $H_i$ 的值），使 $S$ 最小。
(除 $Q$ 外，以上所有数据皆为正整数。)

**数据范围：**$1 \le N \le 10000$,$1 \le M \le 20$

----

(下面这些很多参考了资料，具体看下面的资料)

(可以自动的约掉$π$了)

**思路**：先枚举每一层=>再枚举每一层的半径和

> 记最底层为m
> 表面积的公式为:$$S_总 = S_{m层上侧面积} + \sum_{i=1}^{m}2\pi R_iH_i$$
> 而体积为:$$V_总= \sum_{i=1}^{m}\pi R_i^2H_i$$

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210127003014554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTA3OTM3,size_16,color_FFFFFF,t_70#pic_center)

（注意下：上面是小的）

#### 剪枝优化：

重点是要放在题目需要放在满足的条件和答案中，如果还需要满足一些次要条件，可以适当忽略

设：记总体积为`n`，当前层位`u`, 第u层的高度为$H_u$, 半径为$R_u$，第$m$层到第u层体积的累计值$V_现$【其实就是第m层到u+1的体积和】,面积和是$S_现$

后面的$$V_剩=n-V_现$$【这个值其实就是$V_{1-n}$】

1. 优化搜索顺序：

   > **先从上到下枚举每一层：**
   >
   > > 层内：
   > >
   > > 先枚举半径再枚举高（半径相对于高来说对体积的影响较大）（看公式半径对体积是平方级的），半径由大到小，高度由大到小

2. 可行性剪枝：

   > 把一些一定不满足范围给剔除掉
   >
   > 对于第$u$层，求出每层的半径和高对应的范围:
   >
   > > - 半径
   > >
   > >   每层的半径需要比上层大，比下层小（高度同理）
   > >
   > >   根据那个体积公式，同时高度$H_{min}=u$，还可以求出另一个上限
   > >
   > >   范围：$$ u \leq R_u \leq min \lbrace R_{u+1}-1, \sqrt{\frac{V_剩}{u}} \rbrace$$
   > >
   > > - 高度
   > >
   > >   同上，并且根据枚举顺序，这时还知道了$R_u$
   > >
   > >   范围：$$ u \leq H_u \leq min \lbrace H_{u+1}-1, \frac {{V_剩}}{R_u^2} \rbrace$$
   > >

   (下面就是预测下各个的值范围，看看可不可能是答案)

2. 预处理出最小值，来预估下最小值

   > $minv(u)$:第u层最小体积和
   >
   > $mins(u)$:第u层最小侧面积和
   >
   > - 可行性剪枝：$V_现+minv(u)>n$时，已经不符合条件了
   > - 最优性剪枝：$S_现+mins(u)>=ans$
   
2. 放缩预估下总面积为多少

   > 第1层到第u层：
   >
   > 体积：$V_{1\sim u} = \sum_{i=1}^{u}R_i^2H_i=n - V$【就是剩下的体积】
   >
   > 表面积：$$S_{1-u} = 2\sum_{i=1}^{u}R_iH_i = \frac{2}{R_{u+1}} \sum_{i=1}^{u}R_{u+1}R_iH_i >=  \frac{2}{R_{u+1}}\sum_{i=1}^{u}R_i^2H_i$$
   >
   > 由此得到：$$S_{1-u} >=\frac{2(n-V)}{R_{u+1}}$$【可能取等最后剩下0时】
   >
   > 最优性剪枝:$S_总=S + S_{1-u}=S + \frac{2(n-V)}{R_{u+1}}>=S_{ans}$时已经可以剪掉了

   

**整型有除法最好放最后**

```java
//dfs剪枝优化
	//这里具体看分析那边
import java.io.*;
import java.util.*;
public class Main{
	static final int N=30,INF=(int)1e9;//层数和一个不可能的值
	static int n,m;
	
	//剪枝
	static int[] minv=new int[N],mins=new int[N];
		//minv[u]表示第1~u层的蛋糕的最小体积
		//mins[u]最小第1~u层的蛋糕的最小侧面积（不算上面的圆）
	static int[] R=new int[N],H=new int[N];//当前的所有层的半径和高
		//需要边界需要初始化，避免一些特判
	static int ans=INF;
	/**
	 * 搜索体积和为n，面积和最小的情况
	 * @param u:当前到了第几层
	 * @param v:当前总体积
	 * @param s:当前总面积
	 * 注意：从下往上层搜
	 */
	static void dfs(int u,int v,int s) {
		//一堆剪枝优化
		if(v+minv[u]>n) return;
		if(s+mins[u]>=ans) return;
		if(s+2*(n-v)/R[u+1]>=ans) return;//最优性剪枝
			//预估体积和
			//注意运算顺序，除法最好放最后
		
		if(u==0) {//结束条件（别忘了）
			if(v==n) ans=s;
			return;
		}
		
		//分支一看先看主要的限制的条件：总体积
		for(int r=Math.min(R[u+1]-1,(int)Math.sqrt((n-v)/u));r>=u;--r) {
		//从大到小枚举半径（对体积影响大）
			//还需要特判底层，需要加上上面的面积（别忘了）
			int t=0;
			if(u==m) t=r*r;
			for(int h=Math.min(H[u+1]-1,(n-v)/r/r);h>=u;--h) {//注意看清楚范围
			//从大到小枚举高度
				//不要忘记保存每层的这个了
				R[u]=r;
				H[u]=h;
				dfs(u-1,v+h*r*r,s+h*2*r+t);
			}	
		}
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		m=sc.nextInt();
		//预处理：最小的情况
		for(int i=1;i<=m;++i) {
			minv[i]=minv[i-1]+i*i*i;
			mins[i]=mins[i-1]+2*i*i;
		}
		//预处理下边界问题
		R[m+1]=H[m+1]=INF;
		
		dfs(m,0,0);
		if(ans==INF) ans=0;
		System.out.println(ans);
	}
}
```

参考资料：[AcWing 168. 生日蛋糕【图解+推导】 - AcWing](https://www.acwing.com/solution/content/31876/)



## 迭代加深

**思路**：每次`DFS`都规定一个深度上限，没找到答案深度就`+1`（类似`BFS`）

**场景**：答案深度比较浅或者限制了深度，如果直接`DFS`可能前面会走到比答案深得多的位置

> 迭代加深会一直搜前面的层：(一般只看指数的极端情况)
>
> 当搜索树的分支很多时，搜每一层复杂度是爆炸性增长的，搜之前所有层的和都不如搜当前层，因此可以忽略不记
>
> 就以二叉树为例：$2^0+2^1……+2^{n-1}+2^n=2^{n+1}-1$:前面所有层的和跟只搜最后$n+1$层差不多，不用咋当心
>
> 如果不是指数拓展更不用担心了，分支数少，一般都能搜完



> 为什么直接用`BFS`呢？
>
> 主要是因为`BFS`更容易爆空间，空间复杂度是指数级别，而`DFS`的时间复杂度只有$O(深度)$
>
> 当状态很多时容易爆

![](https://cdn.acwing.com/media/article/image/2021/03/04/2675_69ed07da7c-1.png)

![](https://cdn.acwing.com/media/article/image/2021/03/04/2675_6d4068c17c-2.png)

==如果是那种找到答案立刻放回，记得每次调用`dfs()`时都要有返回值==



[170. 加成序列 - AcWing题库](https://www.acwing.com/problem/content/description/172/)

满足如下条件的序列 $X$（序列中元素被标号为 $1、2、3…m$）被称为“加成序列”：

  1. $X[1]=1$
  2. $X[m]=n$
  3. $X[1]<X[2]<…<X[m-1]<X[m]$
  4. 对于每个 $k$（$2 \le k \le m$）都存在两个整数 $i$ 和 $j$ （$1 \le i,j \le k-1$，$i$ 和 $j$ 可相等），使得 $X[k]=X[i]+X[j]$。

你的任务是：给定一个整数 $n$，找出符合上述条件的长度 $m$ 最小的“加成序列”。

如果有多个满足要求的答案，只需要找出任意一个可行解。

**数据范围：** $1 \le n \le 100$

----

剪枝优化：

1. 优化搜索顺序：

   先枚举大的，显然后面到$n$，分支剩的少

2. 可行性剪枝：

   ①当前两个数的和大于$n$

   ②要比序列的最后一个数大【有这步这里无需标重前面的数了】

3. 排序等效冗余：

   同一个序列，如果和是一样的，不需重复搜

```java
//迭代加深
	/* 一个个深度去搜，适用于答案在比较浅层，如果一条路走到黑情况用特别多
	 * 这里不用bfs主要是空间的原因，这里存序列和每一层的元素容易爆,但是感觉有优化下还是行的
	 * 用dfs空间复杂度仅有O(深度)
	 * */
	//这里这个是原始做法,还能在加点优化（需要点数学证明）
import java.io.*;
import java.util.*;
public class Main{
	static final int N=110;

	static int n;
	static int[] path=new int[N];//记录下当前路径
	/**
	 * 判断深度为k时，能否找到答案
	 * @param u：当前整数序列的第u个
	 * @param k：深度
	 * @return 当深度为k，并且找到答案时，返回真
	 */
	static boolean dfs(int u,int k) {
		if(u==k) {
			return path[u-1]==n;
		}
		boolean[] st=new boolean[N];//主要是避免当前层不要重复搜
			//之前层不用管，只要比当前序列的最后一个数大，一定不会重复
			//注意：每层都是不同判重数组
		//剪枝：优化搜索顺序（从大到小枚举和）
        //这个循环还能优化：就是如果要大于最后一个数且要最短：一定要用到最后一个数
		/*//这个已经能过了
		for(int i=u-1;i>=0;--i) {
			for(int j=i;j>=0;--j) {
				int s=path[i]+path[j];
				//剪枝：可行性剪枝和排除等效冗余
				if(s>n||st[s]||s<=path[u-1]) continue;
					//不要忘记不会大于n
				path[u]=s;
				if(dfs(u+1,k)) return true;//每个dfs都要返回
				st[s]=true;
			}
		}*/
		//循环优化一下
		for(int i=u-1;i>=0;--i){
		    int s=path[i]+path[u-1];
		    if(s>n||st[s]) continue;
		    path[u]=s;
		    if(dfs(u+1,k)) return true;
		    st[s]=true;
		}
		return false;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		
		//初始化
		path[0]=1;//不要忘记了第一个数
		while(true) {
			n=sc.nextInt();
			if(n==0) break;
			
			int k=1;
			while(!dfs(1,k)) ++k;//迭代加深的过程
			for(int i=0;i<k;++i) 
				System.out.printf("%d ",path[i]);
			System.out.println();
		}	
	}
}
```

通过性质来小小优化下：

> $a[n]$必定是由$a[n-1]$构造而来
>
> 证明：
>
> > （反证）不是由这个构造而来，那么这个序列不需要$a[n-1]$可以更短，长度可以更短，一定不是答案【我们也是一层一层搜的么】

**注意**：==如果是那种找到答案立刻放回，记得每次调用`dfs()`时都要有返回值==

参考资料：[别人的题解](https://www.acwing.com/solution/content/38248/)

[下面的评论有性质的来源](https://www.acwing.com/activity/content/code/content/136954/)











## 双向DFS（空间换时间：前半部打表，后半部查表）（思想重要）

思想：分成两半去搜

			前一半搜完，打下结果表(需要去重排序，方便查找)；
	
			后一半搜完，用后一半的结果，去结果表中查询最优结果，组合起来就是整个的集合

![](https://cdn.acwing.com/media/article/image/2021/03/10/2675_357470bf81-1.png)

---

[171. 送礼物 - AcWing题库](https://www.acwing.com/problem/content/description/173/)

达达帮翰翰给女生送礼物，翰翰一共准备了 $N$ 个礼物，其中第 $i$ 个礼物的重量是 $G[i]$。
达达的力气很大，他一次可以搬动重量之和不超过 $W$ 的任意多个物品。
达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。

**数据范围**:$1 \le N \le 46$,$1 \le W,G[i] \le 2^{31}-1$

---



时间复杂度：$2^k+2^{N-k}*log_2^{2^k}$=$2^k+k*2^{N-k}$，中间处不一定最优，但是一定差不了


```java
//双向dfs(打表：空间换时间)
	//这种思路还是挺重要的
	/* 本题用不了背包DP，因为重量太大了，肯定会爆复杂度O(N*M)
	 * 暴力思路：就是枚举每个礼物选或不选  O(2^N)
	 * 优化思路：
	 * 	1.枚举前一半的集合，将结果集合打表下来，供另一半查询
	 * 		答案表去重排序下，方便查找
	 *  2.枚举剩下的集合，当前重量为s，从表中找到不超过W的最大值(可以用二分)
	 * 	剪枝优化：
	 * 		1.优化搜索顺序：（针对的都是主要限制条件，这里是W）
	 * 			先枚举大的重量，剩下的质量少，分支就少
	 * 		2.可行性剪枝：
	 * 			质量超过W的不看
	 * 
	 * 说明：这里折半其实不一定是最优的，但是一定差不了
	 * 		没必要去找最优的那个点
	 * */
	//二分忘的有点多，这里先实现下二分查找的版本
import java.io.*;
import java.util.*;
public class Main{
	static final int N=55,M=1<<25;//M前半结果集合的数量
	static int W,n;
	static Integer[] g=new Integer[N];
	
	static int[] weight=new int[M];//前半部分的答案表
	static int cnt;//答案表有几个数
	static int ans;

	static int k;//中间点
	/**
	 * 枚举前半部分的集合
	 * 并创建前部分结果集合的查询表
	 * @param u:第u个礼物
	 * @param s:当前选择的总重（注意会爆）
	 * 
	 * 说明：这里到第k个礼物停，枚举的是0~k-1礼物的情况
	 */
	static void dfs1(int u,int s) {
		if(u==k) {
			weight[cnt++]=s;//保存下当前结果
			return;
		}
		//选上
		if((long)s+g[u]<=W)//加个可行性剪枝
			dfs1(u+1,s+g[u]);
		//不选
		dfs1(u+1,s);
	}
	/**
	 * 枚举后半部分，
	 * 并查找前半部分的结果表找到其中不超过W最大值
	 * @参数跟前面同
	 */
	static void dfs2(int u,int s) {
		if(u==n) {
			/*二分查找(有点忘了，复习下)
			 	找weight[i]<=W-s的最大值(可能会爆，稍微移动下)
				1.是找最小还是最大值，来确定是下或上取整
					找最大值(右找模板),向上取整
				2.画二分图
					找最大值，答案在左边
					左边<=W-s；右边>W-s
			 */
			int l=0,r=cnt-1;//不要管边界，因为后面在特判下
			while(l<r) {
				int mid=l+r+1 >>1;//上取整
				if(weight[mid]<=W-s) l=mid;//答案在这边
				else				 r=mid-1;//配齐
			}
			if(weight[l]+(long)s<=W) 
				ans=Math.max(ans,weight[l]+s);
			return;
		}
		//选上
		if((long)s+g[u]<=W)//加个可行性剪枝
			dfs2(u+1,s+g[u]);
		//不选
		dfs2(u+1,s);
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		W=sc.nextInt();
		n=sc.nextInt();
		for(int i=0;i<n;++i)
			g[i]=sc.nextInt();
		
		//优化搜索顺序:大的在前
		Arrays.sort(g,0,n,(a,b)->{
			return b-a;//b<a,后者小于前者
		});
		
		//获取前半部分
		k=n/2;
		dfs1(0,0);
		//对前半部分结果排序去重
			//排序
		Arrays.sort(weight,0,cnt);//一定要规定下边界
			//用流去重
		weight=Arrays.stream(weight).distinct().toArray();
			//注意哈，一定会出现0，后边会跟着去掉
		cnt=weight.length;
		
		//获取后半部分
		dfs2(k,0);
		System.out.println(ans);
	}
}
```

注意：**排序时，最好规定下首尾边界**，不然超过边界的那些$0$可能也会参与排序

> 测试了一下，用`TreeSet`是过不了最后一个数据，会超时。

### 手写去重

**会比用流去重快很多**

思路：(类似队列，但是是在原数组上进行的)特判下首个，如果当前与前者不同就放入

			最后返回去重后的个数

```java
	static int unique(int[] arr,int len) {//前提：排序
		int t=0;//去重后数组的个数
		for(int i=0;i<len;++i) 
			if(i==0||arr[i-1]!=arr[i])//为首个或当前的不等于前面的
				arr[t++]=arr[i];
		return t;
	}
```

参考：[题解](https://www.acwing.com/solution/content/38250/)



## IDA* （迭代加深+估计深度的函数）

思路：（比`A*`算法更直接点）

> 每次迭代加深，会一个个增加深度，知道找到答案
>
> 但是有一些答案是能预估出当前深度（`max_depth`）一定不符合答案的
>
> 这时可以用估计函数估计出还需要的深度，如果已经不可能了，直接返回
>
> 前提：**估价函数<=真实值**

### [180. 排书 - AcWing题库](https://www.acwing.com/problem/content/182/)

给定 $n$ 本书，编号为 $1 \sim n$。
在初始状态下，书是任意排列的。
在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。
我们的目标状态是把书按照 $1 \sim n$ 的顺序依次排列。
求最少需要多少次操作。

如果最少操作次数大于或等于 $5$ 次，则输出 `5 or more`。

**数据范围：**$1 \le n \le 15$

```
输入：
3（样例数）
6
1 3 4 6 2 5
5
5 4 3 2 1
10
6 8 5 3 4 7 2 9 1 10
输出：
2
3
5 or more
```



---
![排书.jpg](https://cdn.acwing.com/media/article/image/2024/03/03/246003_02452a40d9-排书.jpg)

> 这里有个公式（但是我推不出来）（用暴力算也没事）
> $$
> n\times(n-1)+(n-1)\times(n-2)+....+2\times1=\frac{(n-1)\times n\times(n+1)}{3}
> $$
>

注意：**==像这种找到答案就立刻返回的，每次调用`dfs`都要返回==**，引发链式反映

```java
//IDA* 
	//其实就是：迭代加深+估价函数(估深度)
	//详细分析看笔记
import java.io.*;
import java.util.*;
public class Main{
	static final int N=20;//M前半结果集合的数量
	static int n;
	static int[] q=new int[N];
	
	static int[][] back=new int[5][];//每一层的备份:方便插入和复原
	//估价函数(小于等于实际就行)
		/* 最终:每一个都有对应的后继
		 * 每次抽一段插入:能改变的其实就三个数的直接后继
		 * 返回：最少需要插入几次 ceil(有多不是对应后继的/3)
		 * */
		//说明：为0时，表示已经排好序了
	static int f() {
		int cnt=0;//有多少个不是对应的后继的
		for(int i=0;i+1<n;++i)
			if(q[i+1]!=q[i]+1)
				++cnt;
		return (cnt+2)/3;//等价于向上取整
	}
	/**
	 * 在最大深度(次数)下，能否拍好序
	 * @param u:第u次插入
	 * @param max_depth:最大深度
	 * @return
	 */
	//说明：插入时其实会出现重复，这时只往一个方向能避免一些重复
	//注意：找到答案立刻返回，一定要每次调用`dfs`时都要，返回答案（引发链式反应）
	static boolean dfs(int u,int max_depth) {
		if(u+f()>max_depth) return false;
		if(f()==0) return true;
		
		//枚举各个插入的情况
		for(int len=1;len<n;++len) {//枚举当前段的长度
			for(int l=0;l+len-1<n;++l){//枚举当前段的左端点
				int r=l+len-1;//当前段的右端点
				for(int k=r+1;k<n;++k) {//枚举插入点
					back[u]=Arrays.copyOf(q,N);
						//注意N：主要是因为这个方法会返回一个新的数组（会覆盖）
					/*插入：
					 	将右端点后面到插入点这一段往前移
					 	空出来的那些放当前段*/
					int x,y;//x作用在插入后的数组;y作用在备份数组
					//将右端点后面到插入点这一段往前移
					for(x=l,y=r+1;y<=k;x++,y++) 
						q[x]=back[u][y];
					//空出来的放当前段
					for(y=l;y<=r;x++,y++)
						q[x]=back[u][y];
					if(dfs(u+1,max_depth)) return true;
					q=back[u];
				}
			}
		}
		return false;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int T=sc.nextInt();
		while(T-- >0) {
			n=sc.nextInt();
			for(int i=0;i<n;++i)
				q[i]=sc.nextInt();
			int depth=0;
			while(depth<5&&!dfs(0,depth)) {
				++depth;
			}
			if(depth>=5)
				System.out.println("5 or more");
			else 
				System.out.println(depth);
		}
	}
}
```

#### 数组的复制：

(像什么移动插入交换，最好都复制一遍，复制数组不动，改变原数组就行)

**特别注意：**

> **如果是数组直接等于另一个数组时`数组a=数组b;`，要特别注意，因为这时会共用同一个地址了，很危险**
>
> 这时你在什么改变都是同一个数组，最后都会相同

`Arrays.copyOf`:这个会生成**副本**，这样可以尽可能的避免用同地址问题【上面等于没有问题，因为又生成一个新的地址，并没有指向同一块地址】

`System.arrayscopy`:是**直接将值复制过去**，如果这时还直接`数组=备份数组`这时就会有问题了

例：(呜呜，又写了个小bug)

```java
				for(int k=r+1;k<n;++k) {//枚举插入点
					System.arraycopy(q, 0, back[u], 0, n);
					。。。。。
                      //q=back[u];
                      /*这样是错的，
                      		k到下一次循环时，q数组已经指向了back[u]数组
                      		这时q数组原来的地址已经丢失了，q这时就是back[u]数组
                      		也就是说后面无论q都是等于back[u]的
                      */
					System.arraycopy(back[u], 0, q, 0, n);
				}
```

注意：**如果是值复制，那么后面还原时也要复制**

**方法**：

- `int b[]=Arrays.copyOfRange(a,l,r);`:截取数组,注意: 左闭右开:$[l,r)$

  `Arrays.copyOf(a,len)`

  > 这个是新生成一个数组，不是单纯的复制值
  >
  > 也就是说**会覆盖**，因此最好每次复制时直接`Arrays.copyOf(a,N)`，这样可以尽可能避免因为覆盖而缩小的问题

- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`

  > 第一个参数是要被复制的数组
  > 第二个参数是被复制的数字开始复制的下标
  > 第三个参数是目标数组，也就是要把数据放进来的数组
  > 第四个参数是从目标数据第几个下标开始放入数据
  > 第五个参数表示从被复制的数组中拿几个数值放到目标数组中
  >
  > [System.arraycopy的使用方法详解_arraycopy方法的作用-CSDN博客](https://blog.csdn.net/wenzhi20102321/article/details/78444158)



参考：[y总的题解](https://www.acwing.com/solution/content/4050/)



### [181. 回转游戏 - AcWing题库](https://www.acwing.com/problem/content/183/)【操作特殊+估价函数特殊】



有一个 `#` 形的棋盘，上面有 $1,2,3$ 三种数字各 $8$ 个。
给定 $8$ 种操作，分别为图中的 $A \sim H$。
这些操作会按照图中字母和箭头所指明的方向，把一条长为 $7$ 的序列循环移动 $1$ 个单位。

给定一个初始状态，请使用最少的操作次数，使 `#` 形棋盘最中间的 $8$ 个格子里的数字相同。

例如：下图最左边的 `#` 形棋盘执行操作 $A$ 后，会变为下图中间的 `#` 形棋盘，再执行操作 $C$ 后会变成下图最右边的 `#` 形棋盘。

![2286_1.jpg](https://cdn.acwing.com/media/article/image/2019/01/23/19_4ec33e321e-2286_1.jpg)

```
上图
输入：1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3
输出：
AC
2
```

**输入格式：**多组用例（输入0截止）。每个测试用例占一行，包含 $24$ 个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。

**输出格式**：有多个答案输出字典序最小的，第一行输出操作，第二行最终中间格的数字

---

时间复杂度：$O(7^k)$

> 假设答案最少需要 $k$ 步，每次需要枚举 $7$ 种不同操作（除了上一步的逆操作），因此最坏情况下需要枚举 $7^k$ 种方案。但加入启发函数后，实际枚举到的状态数很少。

**操作：**（再好好看看）

> 每个方向，按顺序存下对应编号，倒时候直接对应编号的数组就行了

估价函数：(挺不一样的)

- 统计中间8个方格中出现次数最多的数出现了多少次，记为 $k$ 次。
- 每次操作会从中间8个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数。因此估价函数为$8-k$

剪枝：不要枚举上一次的逆操作，否则又还原了

![回转游戏.jpg](https://cdn.acwing.com/media/article/image/2024/03/03/246003_5ab31189d9-回转游戏.jpg) 

```c++
/*
      0     1
      2     3
4  5  6  7  8  9  10
      11    12
13 14 15 16 17 18 19
      20    21
      22    23
*/
```



```java
//IDA* 
	//其实就是：迭代加深+估价函数(估深度)
import java.io.*;
import java.util.*;
public class Main{
	static final int N=30;//M前半结果集合的数量
	static int[] g=new int[N];//用来存棋盘
	
	/*题目答案要求要字典序：
	 	所以每一层的操作直接按字典序来
	 	这样能够保证一个搜到的就是字典序最小的
	 	（因为就是按字典序的顺序搜的）*/
	//转为对应的一维编号
	static int[][] op= {//每一方向对应的编号
			{ 0, 2, 6,11,15,20,22},
			{ 1, 3, 8,12,17,21,23},
			{10, 9, 8, 7, 6, 5, 4},
			{19,18,17,16,15,14,13},
			{23,21,17,12, 8, 3, 1},
			{22,20,15,11, 6, 2, 0},
			{13,14,15,16,17,18,19},
			{ 4, 5, 6, 7, 8, 9,10}
	};
	static int[] center= {6,7,8,11,12,15,16,17};//最中间8格
	static int[] opposite= {5,4,7,6,1,0,3,2};//每个操作对应的逆操作
	
	static int[] path=new int[100];
	/**
	 * 估值函数：判断当前状态最少还需要几步
	 * 	【备注：每次只能移动一格】
	 * 设计:1.找到其中出现最多格数
	 * 		2.计算当前还差几个
	 * @return
	 * 说明：当估计函数等于0时，表示成功了
	 */
	static int[] sum=new int[4];//一共只有三个数字,每个数字出现几次
		//记得要还原
	static int f() {
		Arrays.fill(sum,0);
		for(int i=0;i<8;++i) {
			++sum[g[center[i]]];
		}
		int res=8;
		for(int i=1;i<=3;++i) {
			res=Math.min(res,8-sum[i]);
		}
		return res;
	}
	/**
	 * 对当前棋盘惊醒【'A'+x】这个操作
	 * @param x
	 */
	static void operation(int x) {
		int t=g[op[x][0]];//记录下首个
		//剩下的往前移
		for(int i=1;i<7;++i)
			g[op[x][i-1]]=g[op[x][i]];
		//剩下的位置就是给首个的
		g[op[x][6]]=t;
	}
	/**
	 * 判断在最大深度内能否得到目标
	 * @param u:当前深度
	 * @param max_depth：最大深度
	 * @param last：上一次操作
	 * @return
	 */
	//注意要链式反应
	static boolean dfs(int u,int max_depth,int last) {
		if(u+f()>max_depth) return false;//超过深度了
		if(f()==0) return true;
		//八种操作
		for(int i=0;i<8;++i) {
			if(opposite[i]==last) 
				continue;//排除下等效冗余
				//现在进行之前的逆操作又还原回去了
			operation(i);
			path[u]=i;
			if(dfs(u+1,max_depth,i))
				return true;//注意：链式反应！！！！！
			//还原
			operation(opposite[i]);//进行下逆操作还原回去
		}
		
		return false;
	}
		
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		while(!sc.hasNext("0")) {
			for(int i=0;i<24;++i)
				g[i]=sc.nextInt();
			
			//迭代加深算法
			int depth=0;//最大深度
			while(!dfs(0,depth,-1))//向下搜深度
				++depth;
				//-1表示初始状态
			
			if(depth==0)
				System.out.print("No moves needed");
			else
				for(int i=0;i<depth;++i)
					System.out.print((char)('A'+path[i]));
			System.out.println("\n"+g[6]);
		}
	}
}
```

参考：[y总的题解](https://www.acwing.com/solution/content/4056/)

# treap树堆（平衡树）

## 能完成的操作：

对应题目：[253. 普通平衡树 - AcWing题库](https://www.acwing.com/problem/content/description/255/)

1.  插入数值 x。
2.  删除数值 x(若有多个相同的数，应只删除一个)。
3.  查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4.  查询排名为 x 的数值。
5.  求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6.  求数值 x 的后继(后继定义为大于 x 的最小的数)。

**注意：** 数据保证查询的结果一定存在。

----

## 树堆`treap`



![BST.jpg](https://cdn.acwing.com/media/article/image/2024/02/07/246003_5856bd9fc5-BST.jpg) 

![treap.jpg](https://cdn.acwing.com/media/article/image/2024/02/07/246003_d98461b0c5-treap.jpg)  ![唯一性.jpg](https://cdn.acwing.com/media/article/image/2024/02/07/246003_de1d99fbc5-唯一性.jpg) 

**易错点：**

- **小心左右旋然后根节点的更新**

  - `java`没有显性的引用，**那个根的更新只能用返回值 **

    **都要返回`p`,调用时让`当前根=函数(当前根)`**

    原本想用`AtomicInteger`这个对象来莽一下引用，但是**他是递归**，太麻烦了

    （唉，java写算法确实麻烦好多啊,本来就挺难的）

    ==**涉及到左旋右旋包括插入删除:**==

    1. 函数都要返回`p`
    2. 调用时让`当前根=函数(当前根,~);`
    3. 最后一定要`pushup`

- 树的结构发生改变最后都要`pushup`，不难点个个数会不准

- `java`的那个**随机数是要指定范围的**，不然是会爆空间的

- `java`建树：要建`tr[0]`这个点

- 每次都是没处理空结点

- 哎呀呀，**递归的时候名字不要写错了**

### 1. `java`版

（写得要吐了,能踩的坑大部分都踩了一遍）

```java
//树堆treap   =>(左旋右旋版)+(大根堆版+BST二叉搜索树)
    //treap树的形态是唯一的（看笔记《算法竞赛》那里的比较直观）
    /*（当时我不太明白为什么这个能称为平衡树，都是说概率期望能成）
        （这里也只是直观理解一下）
        treap的左右高度其实是说不准
        但是他能尽可能的避免退化成链表的情况：就是有序序列一个个插入情况
        就是你加一个随机的优先级，那他变成随机的堆
            这样退化的概率会特别小
        (哎呀，感觉这个数据结构，还挺看脸的)*/
        //（这里会写的比较详细，每种函数对应着笔记看吧）
import java.util.*;
import java.io.*;
class Node{//tr[0]表示空结点 =>0指向空
    int l,r;//左右孩子
    int key,val;//实际值 和 堆的优先级看这个随机数
    int cnt,size;//相同的值有几个点 和 这棵树总共的点树 (用来算排名)
    Node(int l,int r,int k,int v,int c,int s){
        this.l=l;
        this.r=r;
        key=k;
        val=v;
        cnt=c;
        size=s;
    }
    Node(){}
}
public class Main{
    static final int N=(int)1e5+10,INF=(int)1e8;//那个INF是最值
    static Node[] tr=new Node[N];
    static int root,idx;//现在的根结点 和 结点分配器  （用整数表示指针）
    static Random random=new Random();//试了下，java每次随机序列都不一样
    static int get_node(int key){//创建新的结点，并返回下标
        tr[++idx]=new Node(0,0,key,random.nextInt(N),1,1);//注意是++idx,下标为0表示空
                        //我真的受不了，这个N不指定是会爆空间的
        /*c++:
        随机序列如果你不加随机种子，就是伪随机
        srand(time(0));//加个这句话
        val=rand();//这个函数是用来生成正int之间的随机数的*/
        return idx;
    }
    
    static void pushup(int p){//两儿子的点合并
        //会改变树的状态的（除了查询）都要
        tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;//两儿子点+自己的点
    }
    /*左右旋肯定能满足二叉搜索树的特性；
        这里还有一个作用：充当堆的下坠和上移操作，让这颗BST也满足堆*/
        
    
    //c++引用：需要更新值的或者当作返回值
        //根结点可能变的都用引用：左旋右旋插入删除
    //注意：哎呀，这里用的是java,所以只能用返回值了
    
        
    /*助记：先记录下旋上去成根的儿子，然后一个一个随后更新
            左儿子大，右旋上去(左儿子的val值比根的val大，不满足大根堆)
            右儿子大，左旋上去*/
    static int zip(int p){//右旋
    //同时会更新的根节点
        int q=tr[p].l;
        tr[p].l=tr[q].r;
        tr[q].r=p;
        pushup(p);pushup(q);
        return q;//q成为新的根
    }
    static int zap(int p){//左旋
        int q=tr[p].r;
        tr[p].r=tr[q].l;
        tr[q].l=p;
        pushup(p);pushup(q);
        return q;
    }
    
    static void build(){//建树
        tr[0]=new Node();//空结点
        //一开始就只有两个虚拟结点，最大值和最小值避免一些特判情况
        get_node(-INF);get_node(INF);
            //手动建一下
        root=1;tr[1].r=2;//先假设一下这颗treap是这样的
                    //不一定，满足了平衡树还要满足堆
        if(tr[2].val>tr[1].val)//如果不满足堆的性质：右儿子大，左旋
            root=zap(root);//注意：要传根，需要更新
    }
    
    
    static int insert(int p,int key){//插入
        //找对应的位置，如果不存在会出现在叶子结点，这时用左右旋上移
            //说明：插入操作结束后，插入的子树的根是会改变的
        if(p==0) return get_node(key);//没有先创建
        else if(tr[p].key==key) ++tr[p].cnt;//本来就有
        else if(tr[p].key>key){//在左儿子
            tr[p].l=insert(tr[p].l,key);//左儿子插入
            //检查一下是否符合堆
            if(tr[tr[p].l].val>tr[p].val) p=zip(p);//左儿子大了
        }else{//在右儿子那
            tr[p].r=insert(tr[p].r,key);
            if(tr[tr[p].r].val>tr[p].val) p=zap(p);
        }
        pushup(p);
        return p;
    }
    static int remove(int p,int key){//删除结点
        //将需要删除的点通过左右旋，下坠到叶子结点
        if(p==0) return 0;//不存在这个点,就不用动它了
        else if(tr[p].key==key){//找到当前结点
            if(tr[p].cnt>1) --tr[p].cnt;
            else if(tr[p].l!=0||tr[p].r!=0){//不是叶子结点，要转为叶子结点
                if(tr[p].r==0||tr[tr[p].l].val>tr[tr[p].r].val){//只有左结点或者左结点的权值比右大
                    p=zip(p);//让左结点成为根
                    //这时候待删的点变为了右儿子
                        //变成在右子树上删掉这个点，右子树的根可能变
                    tr[p].r=remove(tr[p].r,key);
                }else{//根结点变左儿子（对称一下就行）
                    p=zap(p);
                    tr[p].l=remove(tr[p].l,key);
                }
            }else return 0;//如果为叶子结点，指向空
        }else if(tr[p].key>key) //在左儿子那里
            tr[p].l=remove(tr[p].l,key);
        else//在右儿子那
            tr[p].r=remove(tr[p].r,key);
            
        //改完别忘记合并了
        pushup(p);
        return p;
        
    }
    
    static int get_rank_by_key(int p,int key){//根据数值获取排名
        if(p==0) return -1;//不存在这个排名（本题没有这种情况）
        else if(tr[p].key==key) return tr[tr[p].l].size+1;//就是当前结点，然后左子树都是小于这个结点的
        else if(tr[p].key>key)  return get_rank_by_key(tr[p].l,key);//在左儿子那边
        //最后一种在右儿子的情况
        return tr[tr[p].l].size+tr[p].cnt+get_rank_by_key(tr[p].r,key);
    }
    
    static int get_key_by_rank(int p,int rank){//根据排名找数值
        if(p==0) return INF;//排名太大了，没有这个值（本题不会出现）
        else if(tr[tr[p].l].size>=rank) //在左儿子那
            return get_key_by_rank(tr[p].l,rank);
        else if(tr[tr[p].l].size+tr[p].cnt>=rank)//就是当前结点
            return tr[p].key;
        //在右儿子那 
            //注意：别忘记减去前面的排名
        return get_key_by_rank(tr[p].r,rank-tr[tr[p].l].size-tr[p].cnt);
        
    }
    /*部分对称操作：
        	左右旋：左变右就行了,其他都不动
       全部对称操作：
       		找前后驱：全部都是反的
        */
        
    //找前驱
    static int get_prev(int p,int key){ // 找到严格小于key的最大数
        if(p==0) return -INF;//不存在
        else if(tr[p].key>=key) return get_prev(tr[p].l,key);//只能在左子树上
        return Math.max(tr[p].key,get_prev(tr[p].r,key));
            //当前结点已经小于但是还需要看看右结点
    } 
    //找后继
    static int get_next(int p,int key){  // 找到严格大于key的最小数
        if(p==0) return INF;//不存在
        else if(tr[p].key<=key) return get_next(tr[p].r,key);
        return Math.min(tr[p].key,get_next(tr[p].l,key));
    }
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int n=Integer.parseInt(br.readLine()),op,x;
        
        build();
        while(n-- >0){
            String[] ss=br.readLine().split(" ");
            op=Integer.parseInt(ss[0]);
            x=Integer.parseInt(ss[1]);
            //本题保证一定有结果，不会出现空结点的情况，这里的查询都不需要特判
                //注意：那两个虚拟结点
            if(op==1)       root=insert(root,x);
            else if(op==2)  root=remove(root,x);
            else if(op==3)  System.out.println(get_rank_by_key(root,x)-1);
                                //注意：有一个最小值的虚拟结点在前面
            else if(op==4)  System.out.println(get_key_by_rank(root,x+1));
                                //注意：有一个最小值的虚拟结点在前面
            else if(op==5)  System.out.println(get_prev(root,x));
            else            System.out.println(get_next(root,x));
        }
    }
}
//啊，真的很难写啊
    //哇靠，对照法找bug都找半天，呜呜，能踩的坑全部踩一遍了
        //真想不到连随机数那里都有坑
```

> 太恐怖了，真的不想写这个

参考做法：

写得比较接近y总：[题解2](https://www.acwing.com/activity/content/code/content/283177/)

`无旋树堆  java版`（`fhq treap`）:[题解2](https://www.acwing.com/activity/content/code/content/493760/)（java版没引用也特别难写）

别人家的论文：[1](https://byvoid.com/attachments/wp/2010/12/treap-analysis-and-application.pdf)

### 2. c++版：（by--yxc）

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, INF = 1e8;

int n;
struct Node
{
    int l, r;
    int key, val;
    int cnt, size;
}tr[N];

int root, idx;

void pushup(int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &p)    // 右旋
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &p)    // 左旋
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build()
{
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
    pushup(root);

    if (tr[1].val < tr[2].val) zag(root);
}


void insert(int &p, int key)
{
    if (!p) p = get_node(key);
    else if (tr[p].key == key) tr[p].cnt ++ ;
    else if (tr[p].key > key)
    {
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &p, int key)
{
    if (!p) return;
    if (tr[p].key == key)
    {
        if (tr[p].cnt > 1) tr[p].cnt -- ;
        else if (tr[p].l || tr[p].r)
        {
            if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                zig(p);
                remove(tr[p].r, key);
            }
            else
            {
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if (tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);

    pushup(p);
}

int get_rank_by_key(int p, int key)    // 通过数值找排名
{
    if (!p) return 0;   // 本题中不会发生此情况
    if (tr[p].key == key) return tr[tr[p].l].size + 1;
    if (tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int p, int rank)   // 通过排名找数值
{
    if (!p) return INF;     // 本题中不会发生此情况
    if (tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l, rank);
    if (tr[tr[p].l].size + tr[p].cnt >= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int get_prev(int p, int key)   // 找到严格小于key的最大数
{
    if (!p) return -INF;
    if (tr[p].key >= key) return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key)    // 找到严格大于key的最小数
{
    if (!p) return INF;
    if (tr[p].key <= key) return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    srand(time(0));
    build();

    scanf("%d", &n);
    while (n -- )
    {
        int opt, x;
        scanf("%d%d", &opt, &x);
        if (opt == 1) insert(root, x);
        else if (opt == 2) remove(root, x);
        else if (opt == 3) printf("%d\n", get_rank_by_key(root, x) - 1);
        else if (opt == 4) printf("%d\n", get_key_by_rank(root, x + 1));
        else if (opt == 5) printf("%d\n", get_prev(root, x));
        else printf("%d\n", get_next(root, x));
    }

    return 0;
}
```



### 3. 能水过去得暴力版本（by评论）



```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
vector<int> a;
int main()
{
    int n,opt,x;
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d%d",&opt,&x);
        switch(opt)
        {
            case 1:a.insert(upper_bound(a.begin(),a.end(),x),x); break;
            case 2:a.erase(lower_bound(a.begin(),a.end(),x)); break;
            case 3:cout<<lower_bound(a.begin(),a.end(),x)-a.begin()+1<<endl; break;
            case 4:cout<<a[x-1]<<endl; break;
            case 5:cout<<(*--lower_bound(a.begin(),a.end(),x))<<endl; break;
            case 6:cout<<(*upper_bound(a.begin(),a.end(),x))<<endl; break;
        }
    }
    return 0;
}
```

#### 随机数：

- c++：

```c++
srand(time(0));//用当前时间来随机
int a=rand();//随机数 [0,unsigned int的最大值]
```

	[C++ rand 与 srand 的用法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/cpp-rand-srand.html)

- java:(哇敲，这里是有坑的，一不注意会超空间的)

  不知道它的底层是什么，反正**一定要指定范围**

```java
Random random=new Random();
int a=random.nextInt(N);//这里一定要指定范围[0,N)
```

[实例解析常用的java随机数生成办法_w3cschool](https://www.w3cschool.cn/java/java-random.html)



## 无旋`Treap`(FHQ Treap) （推荐）

（感觉没有cnt会更简单点，**下面有没有cnt的版本**）

(那几个`BST`的通用操作还是要会的，不涉及左右旋那几个)

(找前后缀，也能用二分图，分为两区间，答案放在`return`中)

![分裂](https://oi-wiki.org/ds/images/treap-none-rot-split-by-val.svg)

![分裂](https://pic3.zhimg.com/80/v2-2d4ea07aedb1dedd0324006930cf17ea_1440w.webp)

![分裂合并.jpg](https://cdn.acwing.com/media/article/image/2024/02/08/246003_d15c8a09c6-分裂合并.jpg) 



注意：(唉，自己写的bug)

- ==**递归名字不要写错**==（尤其是按排名分裂那里）
- 只要是改变点树最后都要`pushup`：
  - 分裂合并，插入，删除
- 多看几遍那个`get_key_by_rank`：**很关键很容易错**
  - **每个分支都要`return`**
- 最好还是写成`if ifelse`分支，这样比较不会错'
- 分裂完，记得复原

```java
//无旋Treap（FHQ Treap）
        //旋转操作太繁琐了，感觉真的写不来
    /*无旋Treap只需要分裂合并就能搞定几乎所有的操作，而且还有很多扩展操作
        时间复杂度可以说差不多
        说明：最后生成的树跟旋转treap其实是一样的，treap唯一性
        然后就是这里是用java写，引用只能返回值的形式*/
    /*这次的代码我就尽量去吸收好多种代码(看我裤裤抄)
        大部分写的模板都是不处理相同值的(cnt)，这里感觉可以处理下,还是会比旋转方便
        然后尽量去往y总的分格去靠*/
    /*题解风格：（直接一手究极缝合怪）
        1.返回值平替引用
        2.有cnt相同值计数器
            (没有cnt确实会简单点，但是有点浪费空间了)
        3.数组版treap
        4.模仿y总的码分
            (像建两个最值点，避免边界问题之类的)
        5.有按排名分裂
            （但是不会用单单这个找对应排名的数，因为有cnt，不好操作）*/
import java.util.*;
import java.io.*;
class Node{
    int l,r;//左右子树
    int key,val;//实际值 和 堆的随机权值（堆值）
    int cnt,size;//相同值的个数 和 子树的点数
        //这里为了可读性，就不写构造函数了
}
class Pair{//为了分裂充当返回值（平替下引用）
    int l,r;//分裂的左右树
    //规定：左子树承接<=key,右子树承接>key
    Pair(int l,int r){
        this.l=l;
        this.r=r;
    }
}
public class Main{
    static final int N=(int)1e5+10,INF=(int)1e8;//INF最值（不存在）
    //无旋treap
    static Node[] tr=new Node[N];
    static int root,idx;//根节点 和 下标分配器
    static void pushup(int p){//更新p这个点的size
        //注意：只要改变了树的结构就是要用的（分列和合并）
        tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;
    }
    static Random random=new Random();//随机数分配器
    static int get_node(int key){//创建结点
        tr[++idx]=new Node();
        tr[idx].key=key;
        tr[idx].val=random.nextInt(N);//给个随机数，记得限定范围，不然会有问题
                    //不知道为什么这个没有N也能过
        tr[idx].cnt=tr[idx].size=1;
        return idx;
    }
    static Pair split(int p,int key){//默认按key值分裂（返回左右树:左树小于等于,右树大于）
                            //这里看笔记的图，会好理解点
                        //这里用c++引用写，会更简单
    //这个函数只需要看键值，不会用堆值，分裂完都是treap
        if(p==0) return new Pair(0,0);
        
        //其他的情况
        int l,r;
        //每次分裂都是针对p,只有pushup它就行
        if(tr[p].key<=key){//注意下这个等号
                //当根节点<=key时，这时候需要右割(想一下刚好等于的时候)
            l=p;
            //分裂右子树，可能存在的部分<=key（左树）,成为新的右子树
            Pair t=split(tr[p].r,key);
            tr[p].r=t.l;
            r=t.r;
        }else{//跟上面完全对称操作
            r=p;
            Pair t=split(tr[p].l,key);
            tr[p].l=t.r;
            l=t.l;
        }
        pushup(p);//对p就是，别忘记这步
        return new Pair(l,r);
    }

    static Pair split_by_rank(int p,int rank){//按排名分裂（返回左树小于等于）
                        //其实没有这个也能做出来了，毕竟模板题还是写全一点
        if(p==0) return new Pair(0,0);
        int l,r;//大部分同上
        int now_rank=tr[tr[p].l].size+tr[p].cnt;//这个其实是当前排名
        if(now_rank<=rank){//在右子树
                //根节点刚好等于rank时，右割
            l=p;
            //分裂右子树，可能存在的部分<=key（左树）,成为新的右子树
            Pair t=split_by_rank(tr[p].r,rank-now_rank);//注意：右边子树的排名是要减去根和左边的
            tr[p].r=t.l;
            r=t.r;
        }else{
            //跟上面完全对称操作
            r=p;
            Pair t=split_by_rank(tr[p].l,rank);//注意递归的名字别用错了
            tr[p].l=t.r;
            l=t.l;
        }
        pushup(p);//对p就是，别忘记这步
        return new Pair(l,r);
    }
    static int merge(int l,int r){//合并，返回新的根节点
            //l和r都是treap,合并时只看堆值就行
                //时刻要从BST的性质出发：l所有点都<r
        if(l==0||r==0) return l+r;//含有空结点
        
        //其他
            //其实就是两数争根
        int p;//新根
            //每次也是pushup根结点
        if(tr[l].val>tr[r].val){//左边的根成为新根
            p=l;
            //右和左的右子树合并
            tr[l].r=merge(tr[l].r,r);
        }else{//右的根成为新根
        //也是完全对称操作
            p=r;
            tr[r].l=merge(l,tr[r].l);//这里注意左右
        }
        pushup(p);//别忘了
        return p;
    }
    static void build(){//建树：包含两个不存在的点
        tr[0]=new Node();//java童鞋不要忘了，不然会报错的
        get_node(-INF);get_node(INF);
        root=merge(1,2);//合并子树
    }
    //只要点数还是形态改变都必须pushup
    static int insert(int p,int key){//插入值
        //cnt体现在这，没有会省略一点
        Pair t=split(p,key);
        int l,cur,r=t.r;//分裂称小于 等于 大于
        t=split(t.l,key-1);//左子树是小于等于
        l=t.l;cur=t.r;
        if(cur==0)
            cur=get_node(key);//没有这个点
        else//存在
            ++tr[cur].cnt;
        pushup(cur);
        return merge(merge(l,cur),r);//合并,会自动pushup
        
    }
    static int remove(int p,int key){//合并 （跟插入类似）
        Pair t=split(p,key);
        int l,cur,r=t.r;//分裂称小于 等于 大于
        t=split(t.l,key-1);//左子树是小于等于
        l=t.l;cur=t.r;
        if(tr[cur].cnt>1)
            --tr[cur].cnt;
        else
            cur=0;//标记为空结点
        pushup(cur);
        return merge(merge(l,cur),r);
    }
    
    
    //下面这些查找操作都能用传统方法(前面那些都是能用的)，也能用分裂合并的方法
        //传统BST应该会快一点，但是分裂合并简单
    static int get_rank_by_key(int p,int key){//根据值找排名
        if(p==0) return -1;//空节点不存在这个排名
        Pair t=split(p,key-1);//稍稍改动：变为左树<key
        int rank=tr[t.l].size+1;
        merge(t.l,t.r);//复原
        return rank;
    }
    static int get_key_by_rank(int p,int rank){//根据排名找值
        //这个就直接按前面的来了，比较快一点
            //可以按排名分裂出rank这个排名，然后再合并
        if(p==0) return INF;//不存在，这个一般是排名太大
        if(tr[tr[p].l].size>=rank) 
            return get_key_by_rank(tr[p].l,rank);//在左子树上
        //这种函数返回值，if并列还是if else都是一样的
        int t=tr[tr[p].l].size+tr[p].cnt;//当前节点的排名
        if(t>=rank) return tr[p].key;
        //剩下的情况就是在右子树的情况了
        return get_key_by_rank(tr[p].r,rank-t);
    }
    /*(初版，没写成功)
    //这里没想到什么好办法，如果有cnt的话
    static int get_key_by_rank(int p,int rank){
        if(p==0) return INF;
        int l,r,cur;
        Pair t=split_by_rank(p,rank);
        r=t.r;
        t=split_by_rank(t.l,rank-1);//这里不行，你不知到具体有多少个点
        l=t.l;cur=t.r;
        // System.out.println(tr[l].size+" "+tr[cur].size+" "+tr[r].size);
        int key=tr[cur].key;
        merge(merge(l,cur),r);
        return key;
    }
    */
    static int get_prev(int p,int key){// 找到严格小于key的最大数
        if(p==0) return -INF;//不存在
        //左树小于key
        Pair t=split(p,key-1);
        //找左数中最大的
        int res=get_key_by_rank(t.l,tr[t.l].size);
        merge(t.l,t.r);
        return res;
    }
    static int get_next(int p,int key){// 找到严格大于key的最小数
        if(p==0) return INF;
        //右树大于key
        Pair t=split(p,key);
        //找右树的最小值
        int res=get_key_by_rank(t.r,1);
        merge(t.l,t.r);
        return res;
    }
    
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int n=Integer.parseInt(br.readLine());
        
        build();//别忘了
        
        String[] ss;
        int opt,x;
        while(n-- >0){
            ss=br.readLine().split(" ");
            opt=Integer.parseInt(ss[0]);
            x=Integer.parseInt(ss[1]);
            if (opt == 1)      root=insert(root, x);
            else if (opt == 2) root=remove(root, x);
                    //排名都要注意两个虚拟结点
            else if (opt == 3) System.out.println(get_rank_by_key(root, x) - 1);
            else if (opt == 4) System.out.println(get_key_by_rank(root, x + 1));
            else if (opt == 5) System.out.println(get_prev(root, x));
            else               System.out.println(get_next(root, x));
        }
    }
}
//这个是会比较简单，但是还是把能错的都整上了
```

(`c++`版:无cnt版本看：《算法竞赛》)（往下看，实现了大部分，但是估计有部分是有问题的）

参考代码：

(无cnt版本   java)主要：[题解1](https://www.acwing.com/activity/content/code/content/493760/)

部分思路：[Treap - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/treap/#插入_1)

参考图片：[Treap 和 fhq treap - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/657243646)



### 例题：

### [265. 营业额统计 - AcWing题库](https://www.acwing.com/problem/content/description/267/)

设第 $i$ 天的营业额为 $a_i$，则第 $i$ 天($i \ge 2$)的最小波动值 $f_i$ 被定义为：

					$$f_i=min_{1 <= j <= i}|a_i-a_j|$$

当最小波动值越大时，就说明营业情况越不稳定。
而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。
你的任务就是编写一个程序帮助 Tiger 来计算这一个值.
第一天的最小波动值为第一天的营业额 $a_1$。

数据范围：<p>$1 \le n \le 32767, |a_i| \le 10^6$</p>（比较水）

---

#### 无旋`Treap（无cnt版）`

这个代码是验证过，完全没问题的：

靠，我忘记这题的前驱和后继不太一样，**一定要注意这的前驱后继**

```java
//无旋Treap
    //无cnt版本
import java.util.*;
import java.io.*;
class Node{
    int l,r;
    int key,val;
    int size;
}
class Pair{//承接分裂的值
    int l,r;
    Pair(int l,int r){
        this.l=l;
        this.r=r;
    }
}
public class Main{
    static final int N=(int)3.5e4,INF=(int)1e8;//最值
    static Node[] tr=new Node[N];
    static int root,idx;
    static Random rand=new Random();
    static int get_node(int key){
        tr[++idx]=new Node();
        tr[idx].key=key;
        tr[idx].val=rand.nextInt(N);
        tr[idx].size=1;
        return idx;
    }
    static void pushup(int p){
        tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+1;
    }
    static Pair split(int p,int key){//按值分裂
        if(p==0) return new Pair(0,0);
        int l,r;
        if(tr[p].key<=key){//当前点小于等于，分裂右子树
            l=p;
            Pair u=split(tr[p].r,key);
            tr[p].r=u.l;
            r=u.r;
        }else{
            r=p;
            Pair u=split(tr[p].l,key);
            tr[p].l=u.r;
            l=u.l;
        }
        pushup(p);
        return new Pair(l,r);
    }
    static Pair split_by_rank(int p,int rank){//按排名分裂（返回左树小于等于）
                        //其实没有这个也能做出来了，毕竟模板题还是写全一点
        if(p==0) return new Pair(0,0);
        int l,r;//大部分同上
        int now_rank=tr[tr[p].l].size+1;//这个其实是当前排名
        if(now_rank<=rank){//在右子树
                //根节点刚好等于rank时，右割
            l=p;
            //分裂右子树，可能存在的部分<=key（左树）,成为新的右子树
            Pair t=split_by_rank(tr[p].r,rank-now_rank);//注意：右边子树的排名是要减去根和左边的
            tr[p].r=t.l;
            r=t.r;
        }else{
            //跟上面完全对称操作
            r=p;
            Pair t=split_by_rank(tr[p].l,rank);//注意递归的名字别用错了
            tr[p].l=t.r;
            l=t.l;
        }
        pushup(p);//对p就是，别忘记这步
        return new Pair(l,r);
    }
    static int merge(int l,int r){//只看随机的堆值
        if(l==0||r==0) return l+r;
        //看彼此的根
        int p;
        if(tr[l].val>tr[r].val){
            p=l;
            tr[l].r=merge(tr[l].r,r);
        }else{
            p=r;
            tr[r].l=merge(l,tr[r].l);
        }
        pushup(p);
        return p;
    }
    static void build(){
        tr[0]=new Node();
        get_node(-INF);
        get_node(INF);
        root=merge(1,2);
    }
    static int insert(int p,int key){
        Pair u=split(p,key);
        return merge(merge(u.l,get_node(key)),u.r);
    }
    static int remove(int p,int key){
        int l,cur,r;
        Pair u=split(p,key);
        r=u.r;
        u=split(u.l,key-1);
        l=u.l;cur=u.r;
        cur=merge(tr[cur].l,tr[cur].r);//直接删当前点
        return merge(merge(l,cur),r);
    }
    /*法一：平衡树通用
    static int get_key_by_rank(int p,int rank){
        if(p==0) return INF;
        if(tr[tr[p].l].size>=rank) 
            return get_key_by_rank(tr[p].l,rank);
        int t=tr[tr[p].l].size+1;//当前排名
        if(t>=rank)
            return tr[p].key;
        return get_key_by_rank(tr[p].r,rank-t);
    }
    */
    static int get_rank_by_key(int p,int key){//根据值找排名
        if(p==0) return -1;//空节点不存在这个排名
        Pair t=split(p,key-1);//稍稍改动：变为左树<key
        int rank=tr[t.l].size+1;
        merge(t.l,t.r);//复原
        return rank;
    }
    static int get_key_by_rank(int p,int rank){
        if(p==0) return INF;
        int l,r,cur;
        Pair t=split_by_rank(p,rank);
        r=t.r;
        t=split_by_rank(t.l,rank-1);//这里不行，你不知到具体有多少个点
        l=t.l;cur=t.r;
        // System.out.println(tr[l].size+" "+tr[cur].size+" "+tr[r].size);
        int key=tr[cur].key;
        merge(merge(l,cur),r);
        return key;
    }
    static int get_prev(int p,int key){//找小于等于x的最大值
        if(p==0) return -INF;
        Pair u=split(p,key);//左区间是小于等于
        //找左区间的最大值
        int res=get_key_by_rank(u.l,tr[u.l].size);
        merge(u.l,u.r);
        return res;
    }
    static int get_next(int p,int key){//找大于等于的最小值
        if(p==0) return INF;
        Pair u=split(p,key-1);//这样右区间就是小于等于的
        int res=get_key_by_rank(u.r,1);
        merge(u.l,u.r);
        return res;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);//低于1e5用这个
        int n=sc.nextInt();
        long res=0;
        build();
        for(int i=0;i<n;++i){
            int x=sc.nextInt();
            if(i==0) res+=x;
            else{
                // System.out.println(get_prev(root,x)+" "+get_next(root,x));
                res+=Math.min(x-get_prev(root,x),get_next(root,x)-x);
                // System.out.println(Math.min(x-get_prev(root,x),get_next(root,x)-x));
            }
            root=insert(root,x);
        }
        System.out.println(res);
    }
}

```



  

##### 传统平衡树方法

```java
//无旋Treap
import java.util.*;
import java.io.*;
class Node{//本题是简化版本,只需要查询前后缀
    int l,r;
    int key,val;
}
class Pair{//承接分裂的值
    int l,r;
    Pair(int l,int r){
        this.l=l;
        this.r=r;
    }
}
public class Main{
    static final int N=(int)3.5e4,INF=(int)1e8;//最值
    static Node[] tr=new Node[N];
    static int root,idx;
    static Random rand=new Random();
    static int get_node(int key){
        tr[++idx]=new Node();
        tr[idx].key=key;
        tr[idx].val=rand.nextInt(N);
        return idx;
    }
    static Pair split(int p,int key){//按值分裂
        if(p==0) return new Pair(0,0);
        int l,r;
        if(tr[p].key<=key){//当前点小于等于，分裂右子树
            l=p;
            Pair u=split(tr[p].r,key);
            tr[p].r=u.l;
            r=u.r;
        }else{
            r=p;
            Pair u=split(tr[p].l,key);
            tr[p].l=u.r;
            l=u.l;
        }
        //pushup
        return new Pair(l,r);
    }
    static int merge(int l,int r){//只看随机的堆值
        if(l==0||r==0) return l+r;
        //看彼此的根
        int p;
        if(tr[l].val>tr[r].val){
            p=l;
            tr[l].r=merge(tr[l].r,r);
        }else{
            p=r;
            tr[r].l=merge(l,tr[r].l);
        }
        //pushup
        return p;
    }
    static void build(){
        tr[0]=new Node();
        get_node(-INF);
        get_node(INF);
        root=merge(1,2);
    }
    static int insert(int p,int key){
        Pair u=split(p,key);
        return merge(merge(u.l,get_node(key)),u.r);
    }
    static int get_prev(int p,int key){//找小于等于x的最大值
        if(p==0) return -INF;
        //这里还是用二分那个图来解决，分为两个区间，答案放在return
        if(tr[p].key>key) return get_prev(tr[p].l,key);
        return Math.max(tr[p].key,get_prev(tr[p].r,key));//根节点符合<=,还需要向右找找
    }
    static int get_next(int p,int key){//找大于等于的最小值
        if(p==0) return INF;
        if(tr[p].key<key) return get_next(tr[p].r,key);
        return Math.min(tr[p].key,get_next(tr[p].l,key));
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);//低于1e5用这个
        int n=sc.nextInt();
        long res=0;
        build();
        for(int i=0;i<n;++i){
            int x=sc.nextInt();
            if(i==0) res+=x;
            else{
                res+=Math.min(x-get_prev(root,x),get_next(root,x)-x);
            }
            root=insert(root,x);
        }
        System.out.println(res);
    }
}

```







#### `TreeSet`做法：

```java
//TreeSet容器：
import java.util.*;
import java.io.*;
public class Main{
    static final int INF=(int)1e8;//最值
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);//低于1e5用这个
        int n=sc.nextInt();
        long res=0;
        //建树，同时避免特判
        TreeSet<Integer> s=new TreeSet<>();
        s.add(-INF);
        s.add(INF);
        for(int i=0;i<n;++i){
            int x=sc.nextInt();
            if(i==0) res+=x;
            else{
                res+=Math.min(x-s.floor(x),s.ceiling(x)-x);
            }
            s.add(x);
        }
        System.out.println(res);
    }
}

```

# 回文字符串

[139. 回文子串的最大长度 - AcWing题库](https://www.acwing.com/problem/content/description/141/)

如果一个字符串正着读和倒着读是一样的，则称它是回文的。

给定一个长度为 N 的字符串 S，求他的最长回文子串的长度是多少。

输入将包含最多 $30$ 个测试用例，每个测试用例占一行，以最多$1000000$个小写字符的形式给出。
输入以一个以字符串 END 开头的行表示输入终止。

## manacher



> 这个老哥的题解相当好，这里为了省事，直接照搬下来了：
>
> 	[Manacher 算法详解 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/446985/) 和 [Manacher 算法详解 | Yuhi's Blog](https://yuhi.xyz/post/Manacher-算法详解/)
>
> （这里只是稍稍改进下写法而已，配和代码好好看看）
>
> 这里代码参照的是《算法竞赛》，但是它这里对算法的描述和图有点问题，会带来一些困惑



#### 字符串预处理

为了解决奇数长度的回文串，与偶数长度的回文串的不统一的问题，我们对给定字符串`S`预处理，即间隔插入分隔符`#`，**同时加入起始和结束符号，防止边界问题，自动结束**，如下所示：

    原串 abaa -> ^#a#b#a#a#$
    		    11213123211	
    最长回文子串 aba -> #a#b#a#
    
    原串 abaabc -> ^#a#b#a#a#b#c#$
    最长回文子串 baab -> #b#a#a#b#

那么所有回文子串都统一成了 _奇数长度_ 。

#### 引入 p 数组, rt, mid

预处理后的新串表示为`Str`，定义数组`p[]`，`p[i]`表示 `Str`中以下标`i`为回文中心的最大回文半径。以`abab`为例：

| i    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Str  | #    | a    | #    | b    | #    | a    | #    | b    | #    |
| p[i] | 1    | 2    | 1    | 4    | 1    | 4    | 1    | 2    | 1    |

如果我们得到了 `p[i]`，那么 `p[i] - 1` 就是原串 $ m S$ 以 `i` 为回文中心的最大回文 _长度_ （可根据上表验证一下）。

现在我们来求解 `p[i]`，定义 `rt` 表示已经计算过的回文串能达到的最远右边界的 _下一个位置_[1]。即 $ rt =
\max(j+p[j]),j\in[1,i-1]$，`mid` 表示 `rt` 所对应的最左侧的回文中心，有 `mid + p[mid] == rt`
。如下图所示：

![](https://yuhi.xyz/images/manacher_1.png)

>  ◎ mid 与 rt 的定义

#### 分类讨论最小长度

如何计算 `p[i]` 呢，显然有 `i > mid`（因为 `p[mid]` 已经计算过·）下面再分两种情况讨论：  
 **情况一** ：`i < rt`

![](https://yuhi.xyz/images/manacher_2.png)

>  ◎ i < rt 时计算 p[i]

此时我们发现，我们可以用已知的 `p[j]` 的信息来辅助计算 `p[i]`。`p[j]` 又有两种情况，讨论如下：

>   1. 以 `j` 为中心的最大回文串 _被包含_ 在以 `mid` 为中心的最大回文串中
>
>      ![](https://yuhi.xyz/images/manacher_3.png)
>
>   > ◎ 以 j为中心的最大回文串被包含在以 mid 为中心的最大回文串中
>
>   2. 以 `j` 为中心的最大回文串 _没有被包含_ 在以 `mid` 为中心的最大回文串中
>
>      ![](https://yuhi.xyz/images/manacher_4.png)
>
>   >  ◎ 以 j为中心的最大回文串没有被包含在以 mid 为中心的最大回文串中

**情况二** ：`i >= rt` 此时，没有已知信息可以辅助计算了，令 `p[i] = 1` 然后暴力扩展。

![](https://yuhi.xyz/images/manacher_5.png)

>  ◎ i >= rt 时计算 p[i]

 **最后暴力（中心拓展法）求剩下的**



#### 时间复杂度分析

下次拓展发生在`rt`后面，因此时间复杂度$O(n)$



```java
//manacher算法
/* 本质上： 是动态规划的思想，尽量不重复计算
 * 		    利用的是回文串的镜像还是回文串
 * 重要技巧：需要分成多种情况，经过变换，将这些变换化为同一种
 * 			统一处理（使用了多次）
 * 
 * 
 * 		预处理变换：	本来回文串是分为两种：长度为奇数或者偶数
 * 					偶数的空隙为奇数，奇数的空隙为偶数
 * 					偶数+奇数=奇数
 * 					通过将缝隙用特殊全部补上，就都变为了奇数字符串
 * 					然后为了防止边界情况，左右边界加上特殊字符，左边界在加个开始字符，右边界加结束字符
 * 经过这样变换后个数，以s[i]为中心的回文串长度为p[i]-1
 * 
 * 具体过程（看题解，这里大概提一下）：【不断分类讨论】：
 * 		p数组用来存以s[i]为中心字符的最长回文串长度
 * 		当前最大的右端点rt（开区间），对应的中心点为c
 * 			rt=c+p[c]，回文串不包含这个
 * 		当前算p[i],p[1~i-1]已经算完了
 * 		情况1：能镜像：i<rt
 * 			i关于c的镜像是j=2*c-i【(i+j)/2=c】
 * 			① 以s[j]为中心的回文串被这个最大右端点的回文串包含:
 * 				那么以s[i]为中心的回文串最小为p[i]
 * 			② 以s[j]为中心的回文串被这个最大右端点的回文串不能包含:
 * 				那么最多只能确定到以c为中心回文串的右端点
 * 				长度为rt-i
 * 		情况2：不能镜像：i>=rt
 * 			那么p[i]至少为1
 * 		剩下的用暴力法（中心拓展法）确定就行
 * 		
 * 	时间复杂度为：O(n)【不会重复计算已经走过的右端点】			
 * */
import java.util.*;
import java.io.*;
public class Main{
	static final int N=(int)1e6+10;
	//这些参数配合上面的分析看
	static int len;//预处理后的长度
	static char[] s=new char[N<<1],tmp;
	static int[] p=new int[N<<1];
	static int c,rt;
	//预处理，将回文串都变为奇数
	static void init() {
		int k=1;//从1开始存储
		//构造左边界
		s[k++]='^';//开始字符
		s[k++]='#';//特殊字符加入缝隙中
		for(int i=0;i<tmp.length;++i) {
			s[k++]=tmp[i];
			s[k++]='#';
		}
		s[k++]='$';//结束字符
		len=k;
	}
	static void manacher() {
		for(int i=1;i<len;++i) {
			if(i<rt) 
				p[i]=Math.min(p[(c<<1)-i],rt-i);
			else
				p[i]=1;
			//再用暴力（中心拓展法，去算）
			while(s[i-p[i]]==s[i+p[i]])
				++p[i];
			if(i+p[i]>rt) {
				rt=i+p[i];
				c=i;
			}
		}
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int T=1;
		while(true) {
			String ss=br.readLine();
			if("END".equals(ss)) break;
			tmp=ss.toCharArray();
			init();
			manacher();
			int res=0;
			for(int i=0;i<len;++i) 
				res=Math.max(res,p[i]-1);
			System.out.printf("Case %d: %d\n",T++,res);
		}
	}
}
```

## 二分+(前后缀)字符串哈希

> 时间复杂度没有比上一个好，这个本质上就是优化下暴力，这里引入上面那些参数
>
> 不过这种解法挺适合用来练习的

> 这里好好看看如何倒着处理哈希



```java
//暴力优化:二分+（前后缀）字符串哈希
	//引入下manacher那些东西
	//有明显的二段性，可以用二分找
import java.util.*;
import java.io.*;
public class Main{
	static final int N=(int)1e6+10;
	//引入manacher那些概念浅浅优化一下
	static int len;//预处理后的长度
	static char[] s=new char[N<<1],tmp;//预处理成s
	static int[] f=new int[N<<1];//以s[i]为中心的回文串半径
	
	//字符串哈希
		//注意下：java没有无符号的整型
	static final int P=131;//模数让他们自然溢出
	static long[] p=new long[N<<1];//预处理进制
	static long[] hl=new long[N<<1];//正向
	static long[] hr=new long[N<<1];//逆向，注意：最后一个字符表示下标1
			//注意：倒着存，hr[j]实际表示的是s[n~j]的哈希
	/**
	 * 					a b c d e f
	 * hl对应的下标：	1 2 3 4 5 6
	 * hr对应的下标：	6 5 4 3 2 1
	 * hr你反着来的,长度len=7,j对应len-i
	 */
	//预处理，将回文串都变为奇数+前后缀字符串哈希
	static void init() {
		//预处理s
		int k=1;//从1开始，因为后面会涉及前缀和
		s[k++]='^';
		s[k++]='#';
		for(int i=0;i<tmp.length;++i) {
			s[k++]=tmp[i];
			s[k++]='#';
		}
		s[k++]='$';
		len=k;
		
		//前后缀字符串哈希
		p[0]=1;//初始话
		for(int i=1,j=len-1;i<len;++i,--j) {
			hl[i]=hl[i-1]*P+s[i];
			hr[i]=hr[i-1]*P+s[j];//注意是倒着来的
			p[i]=p[i-1]*P;
		}
	}
	static long get(long[] h,int l,int r) {
		return h[r]-h[l-1]*p[r-l+1];//注意要配齐
	}
	static boolean check(int i,int l) {
		return get(hl,i-l,i-1)==get(hr,len-(i+l),len-(i+1));//这里没有啥好办法
			//最好就是自己举例子
	}
	
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int T=1;
		while(true) {
			String ss=br.readLine();
			if("END".equals(ss)) break;
			
			tmp=ss.toCharArray();
			init();
			for(int i=1;i<len;++i) {
				//二分找长度
					//找到长度的最大值
					//向右模板
				int l=0,r=Math.min(i-1,len-i-1);
				while(l<r) {
					int mid=l+r+1 >>1;
					if(check(i,mid)) 
						l=mid;
					else 
						r=mid-1;
				}
				f[i]=l+1;
			}
			
			int res=0;
			for(int i=0;i<len;++i) 
				res=Math.max(res,f[i]-1);
			System.out.printf("Case %d: %d\n",T++,res);
		}
		
	}
}
```

> **注意这里倒着的字符串哈希是逆向的**，并且注意这里的长度
>
> 有一堆边界问题



# 基础算法







## 排序

### 贪心：均分纸牌问题（绝对值不等式）

[105. 七夕祭 - AcWing题库](https://www.acwing.com/problem/content/107/)

矩形的祭典会场由 $N$ 排 $M$ 列共计 $N×M$ 个摊点组成。
每次只能交换相邻的摊位。
两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上，

希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。

现在想知道他的两个要求最多能满足多少个。
在此前提下，至少需要交换多少次摊点。

**数据范围**：$1 \le N,M \le 100000$,$0 \le T \le min(N*M,100000)$,$1 \le x \le N$,$1 \le y \le M$

---

原型：[AcWing 122. 糖果传递 - AcWing](https://www.acwing.com/activity/content/problem/content/1765/)=>[AcWing 104. 货仓选址 - AcWing](https://www.acwing.com/activity/content/problem/content/1214/)

![七夕祭.jpg](https://cdn.acwing.com/media/article/image/2024/03/17/246003_57c8b0a4e4-七夕祭.jpg) 

```java
//贪心=>只不过要排序
/*原型：
    环形均分纸牌问题(绝对值不等式)=>绝对值不等式
  分成行列就行了*/
import java.io.*;
import java.util.*;

public class Main {
	static int N = (int) 1e5 + 10;
	//那个n,m就不写这了，因为行列要分别操作
	static int[] row = new int[N],col=new int [N],sum=new int[N],c=new int[N];
		//分別：每一行和每一列分别有几个摊位，前缀和，数学公式推导出的需要绝对值不等式那一项
			//说明这里c数组是爆了int的，前缀和最大就是1e5
	/**
	 * 求这个环形数组进行纸牌均分的最小值
	 * @param n:数组长度
	 * @param a
	 * @return:不能时返回-1；能时返回答案
	 */
	static long work(int n,int[] a) {
		//这里初始话的都是顺便的
		//构建前缀和
		for(int i=1;i<=n;++i) 
			sum[i]=sum[i-1]+a[i];
		
		if(sum[n]%n!=0) return -1;//不能够均分
		
		int avg=sum[n]/n;
		//构建c数组
		c[1]=0;
		for(int i=2;i<=n;++i) 
			c[i]=sum[i-1]-(i-1)*avg;
		//绝对值不等式
			//得到中位数
		long res=0;//是会爆的，全部集中在边界的情况
		Arrays.sort(c,1,n+1);//java没有那种很好的得到中位数的函数
		for(int i=1;i<=n;++i) {
			res+=Math.abs(c[(n+1)/2]-c[i]);
		}
		return res;
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		int n=Integer.parseInt(ss[0]),m=Integer.parseInt(ss[1]),T=Integer.parseInt(ss[2]);
		for(int i=0;i<T;++i) {
			ss=br.readLine().split(" ");
			++row[Integer.parseInt(ss[0])];
			++col[Integer.parseInt(ss[1])];
		}
		
		long r=work(n,row);
		long c=work(m,col);
		if(r!=-1&&c!=-1)
			System.out.printf("both %d",r+c);
		else if(r!=-1)
			System.out.printf("row %d",r);
		else if(c!=-1)
			System.out.printf("column %d",c);
		else 
			System.out.println("impossible");
	}

}
```

![绝对值不等式1.jpg](https://cdn.acwing.com/media/article/image/2023/08/18/246003_560c56d13d-绝对值不等式1.jpg)



## 对顶堆：动态求中位数

> 挺重要的，常考

> 好像也叫二叉堆

![对顶推.png](https://cdn.acwing.com/media/article/image/2024/03/17/246003_6479c1c6e4-对顶推.png)

![](https://cdn.acwing.com/media/article/image/2021/02/05/64845_14476dfb67-F95830359687924963F89380AE7BB7D5.png)

> 注意喽：这两个堆是分开的
>
> 说明：(有序序列的)**左半部在下面，右半部在上面**

**需要满足的性质：**

- 上面所有数>=下面所有的数

- 下面个数最多比下面多1

  > 这个是为了**让中位数始终出现在上面**



基本代码：

```java
//对顶堆=>求中位数
	/* 说明：前半部在下面，后半部在上面
	 * 规则:1.下面所有的元素<=上面所有的元素
	 * 		2.下面的个数最多比上面的多1
	 * 因此中位数是在下面（前半部）
	 * */

//对顶堆
    //前半部
    Queue<Integer> down=new PriorityQueue<>(Collections.reverseOrder());//大根堆
    //后半部
    Queue<Integer> up=new PriorityQueue<>();//小根堆

//构造方法
        if(down.isEmpty()||x<=down.peek()) 
            down.add(x);
        else
            up.add(x);
        //让中位数保持在下面
        if(down.size()>up.size()+1)
            up.add(down.remove());
        if(down.size()<up.size())
            down.add(up.remove());

//输出中位数
	down.peek();
```



[106. 动态中位数 - AcWing题库](https://www.acwing.com/problem/content/108/)

依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。

---



```java
//对顶堆=>求中位数
	/* 说明：前半部在下面，后半部在上面
	 * 规则:1.下面所有的元素<=上面所有的元素
	 * 		2.下面的个数最多比上面的多1
	 * 因此中位数是在下面（前半部）
	 * */
import java.util.*;
import java.io.*;
public class Main{
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		int P=Integer.parseInt(br.readLine());
		String[] ss;
		while(P-- >0) {
			ss=br.readLine().split(" ");
			int num=Integer.parseInt(ss[0]),n=Integer.parseInt(ss[1]);
			bw.write(num+" "+(n+1)/2+"\n");
			int cnt=0;//记录输出了几个中位数，到十个就换行
			
			//对顶堆
				//前半部
			Queue<Integer> down=new PriorityQueue<>(Collections.reverseOrder());//大根堆
				//后半部
			Queue<Integer> up=new PriorityQueue<>();//小根堆
			int h=(n+10)/10;
			//读入
			for(int i=0;i<h;++i) {
				ss=br.readLine().split(" ");
				for(int j=0;j<ss.length;++j) {
					int x=Integer.parseInt(ss[j]);
					
					//对堆顶堆操作
					if(down.isEmpty()||x<=down.peek()) 
						down.add(x);
					else
						up.add(x);
						//让中位数保持在下面
					if(down.size()>up.size()+1)
						up.add(down.remove());
					if(down.size()<up.size())
						down.add(up.remove());
					
					if(j%2==0) {//个数为奇数时输出
						bw.write(down.peek()+" ");
						if(++cnt%10==0) bw.write("\n");
					}
				}
			}
			//不能输出多余的空行，需要特判
			if(cnt%10!=0)
				bw.write("\n");
		}
		bw.flush();
	}
}
```

参考资料：[AcWing 106. 动态中位数 - AcWing](https://www.acwing.com/solution/content/34043/)



## 求逆序对

[107. 超快速排序 - AcWing题库](https://www.acwing.com/problem/content/description/109/)

	求使用冒泡排序(每次交换**相邻**的两个数)，直到升序排序，最少需要执行多少次操作

> 就是**逆序对个数**：
>
> 当升序时，逆序对数为0
>
> 如果不是升序，必然存在相邻的逆序对（$a[i]>a[i+1]$），每次就减少一对(并不会影响到除这两个之外其他的数)
> 每次交换意味着减少一个逆序对，那么总交换次数就是序列的逆序对总数。

----



### 离散化+树状数组

> 无需离散化的话，用这个比较不容易出错

```java
//树状数组求逆序对
	//这个比较不容易错，但是肯定是会慢一点的
import java.io.*;
import java.util.*;
public class Main {
	static final int N=(int)5e5+10;
	static int n;
	
	static int[] arr=new int[N];//查询数组
	//离散化
		//可惜java的可变成数组还是挺难用的
	static Integer[] alls=new Integer[N];//离散化后的结果
	static int len=0;//离散化后的长度
	static int find(int x) {//x对应离散化后的下标
		return Arrays.binarySearch(alls, 0, len, x)+1;//从1开始
	}
	
	//树状数组:动态求前缀和
		//注意树状数组从1开始
	static int[] tr=new int[N];
	static int lowbit(int x) {
		return x&-x;
	}
	//单点修改
	static void add(int x,int y) {
		//向上找爸爸
		for(int i=x;i<=n;i+=lowbit(i))
			tr[i]+=y;
	}
	//区间查询
	static int sum(int x) {
		int res=0;
		//往前爬楼梯
		for(int i=x;i!=0;i-=lowbit(i))
			res+=tr[i];
		return res;
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		while(true) {
			n=Integer.parseInt(br.readLine());
			if(n==0) break;
			
			//初始化树状数组
				//剩下那些会在后续中初始化
			Arrays.fill(tr,0);
			//离散化
			List<Integer> tmp=new ArrayList<>();
			for(int i=0;i<n;++i) {
				arr[i]=Integer.parseInt(br.readLine());
				tmp.add(arr[i]);
			}
			tmp=new ArrayList<>(new TreeSet<>(tmp));
			len=tmp.size();
			alls=tmp.toArray(new Integer[0]);
			
			//求逆序对个数
			long res=0;//可能会爆int（等差序列）
			for(int i=0;i<n;++i) {
				//放入arr[i]前，一共有i个数
				int x=find(arr[i]);
				res+=i-sum(x);//求以arr[i]为尾的逆序对
				add(x,1);
			}
			System.out.println(res);
		}
	}
}
```

> 需要注意的是，为了避免返回`Object`类型的数组，可以**传递一个指定类型的数组**作为参数，如果数组大小不够，则会创建一个新数组。

### 归并排序

```java
//归并排序求逆序对
import java.io.*;
import java.util.*;
public class Main {
	static final int N=(int)5e5+10;
	static int n;
	static int[] arr=new int[N];
	static int[] tmp=new int[N];
	/**
	 * 归并排序：将两个有序序列合并成一个
	 * @param l
	 * @param r
	 * @return:返回逆序对个数
	 * 注意：是要放入时，统计另一个区间还没放入那些
	 * 		这样无需在补入时计算
	 */
	static long merge_sort(int l,int r) {
		if(l>=r) return 0;
		
		int mid=l+r >>1;
		long res=merge_sort(l,mid)+merge_sort(mid+1,r);
		//双指针合并序列
		int i=l,j=mid+1,k=0;
			//合并到一方结束
		while(i<=mid&&j<=r) {//每一次放入的是小的
			if(arr[i]<=arr[j]) {
				tmp[k++]=arr[i++];//相等的也放入，前面相等的不算逆序对
			}else {
				res+=mid-i+1;
				tmp[k++]=arr[j++];
			}
		}
			//补下剩下的
		while(i<=mid) 
			tmp[k++]=arr[i++];
		while(j<=r)
			tmp[k++]=arr[j++];
			//放回原数组
		for(i=l,j=0;i<=r;++i,++j)
			arr[i]=tmp[j];
		
		return res;
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		while(true) {
			n=Integer.parseInt(br.readLine());
			if(n==0) break;
			
			for(int i=0;i<n;++i) 
				arr[i]=Integer.parseInt(br.readLine());
			System.out.println(merge_sort(0, n-1));
		}
	}
}
```





## RMQ(ST表)：静态区间最值查询

[1273. 天才的记忆 - AcWing题库](https://www.acwing.com/problem/content/submission/1275/)

查询$[l,r]$的区间最值（从1开始）

---

![RMQ区间查询.jpg](https://cdn.acwing.com/media/article/image/2024/03/17/246003_6f3030dae4-RMQ区间查询.jpg) 

```java
//RMQ(别名：ST表或者跳表)
	//静态求区间最值（无法修改数字）
import java.io.*;
import java.util.*;
public class Main {
	static final int N=(int)5e5+10,M=20;//log2(2e5)<20
	static int n,m;
	static int[] arr=new int[N];
	
	//st表（最值查询表）
		//时间复杂度：查询O(1),建表O(nlog2n)
	static int[][] f=new int[N][M];//j<M
	static void init() {
		for(int j=0;j<M;++j) 
			for(int i=1;i+(1<<j)-1<=n;++i) {
				if(j==0)//别忘了
					f[i][j]=arr[i];
				else
					f[i][j]=Math.max(f[i][j-1],f[i+(1<< j-1)][j-1]);
			}
	}
	static int query(int l,int r) {
		int len=r-l+1;
		//算2^k>=len&&2*2^k<len
			//法1：
		int k=(int)(Math.log(len)/Math.log(2));
		/* 法2：
		 * 	预处理每个数：
		 * 		先将二的倍数的下标都标记好
		 * 		然后没给赋值就按上一个值 */
		return Math.max(f[l][k],f[r-(1<<k)+1][k]);
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		n=Integer.parseInt(br.readLine());
		String[] ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i) 
			arr[i]=Integer.parseInt(ss[i-1]);
		
		init();
		
		m=Integer.parseInt(br.readLine());
		while(m-- >0) {
			ss=br.readLine().split(" ");
			int l=Integer.parseInt(ss[0]),r=Integer.parseInt(ss[1]);
			System.out.println(query(l,r));
		}
		bw.flush();
	}
}
```



### 万能线段树

```java
//线段树
import java.io.*;
import java.util.*;
class Node{
	int l,r,max;
	Node(int l, int r, int max) {
		this.l = l;
		this.r = r;
		this.max = max;
	}
}
public class Main {
	static final int N=(int)5e5+10;
	static int n,m;
	static int[] arr=new int[N];
	
	//线段树
		//思想：不断将区间分两半
	static Node[] tr=new Node[4*N];
	static void pushup(int u) {
		tr[u].max=Math.max(tr[u<<1].max,tr[u<<1|1].max);
	}
	static void build(int u,int l,int r) {
		if(l>=r) {
			tr[u]=new Node(l,r,arr[l]);
			return;
		}
		tr[u]=new Node(l,r,0);
		int mid=l+r >>1;
		build(u<<1,l,mid);build(u<<1|1,mid+1,r);
		pushup(u);
	}
	static int query(int u,int l,int r) {
		if(l<=tr[u].l&&tr[u].r<=r) {//被包含
			return tr[u].max;
		}
		int mid=tr[u].l+tr[u].r >>1;
		int res=Integer.MIN_VALUE;
		if(l<=mid) //包含左区间
			res=Math.max(res,query(u<<1,l,r));
		if(r>mid)
			res=Math.max(res,query(u<<1|1,l,r));
		return res;
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		n=Integer.parseInt(br.readLine());
		String[] ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i) 
			arr[i]=Integer.parseInt(ss[i-1]);
		
		build(1,1,n);
		
		m=Integer.parseInt(br.readLine());
		while(m-- >0) {
			ss=br.readLine().split(" ");
			int l=Integer.parseInt(ss[0]),r=Integer.parseInt(ss[1]);
			System.out.println(query(1,l,r));
		}
		bw.flush();
	}
}
```

# 树状数组

 **基础功能：1.区间查询2.单点修改** 

	（**查询不包括求最值**）

 其他功能：是由这两个功能拓展的



常用思路：==**让下标表示数轴，然后下标上的值表示对应位置出现的次数**==

				（数轴上能相当容易的比较大小或者得到排名）

 1. 求前面或者后面小于或大于这个数个数相当好用(当这个数字很大，需要离散化)( **AcWing 241. 楼兰图腾**)

    例如：对于y[i]这个数，数轴在这个点前面的和就是小于它的个数，后面就是大于它的个数

    			如果从前往后一个个求：就能求出原数组前面大于和小于的个数
	
    			如果从后往前一个个求：后面的

 2. 找第k小的数+删除某个数


-----

## 模板题（单点修改+区间查询）

**[AcWing 1264. 动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)**

(蓝桥杯辅导课)

```
题意：1.能修改某个数2.求区间和
```
```
//想了解原理可以看看这个
https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.851.header_right.fav_list.click&vd_source=79043f2a8efe4672df69e4818fe876b8
https://www.bilibili.com/video/BV1pE41197Qj/?spm_id_from=333.851.header_right.fav_list.click&vd_source=79043f2a8efe4672df69e4818fe876b8
```
（结合几题一起看看，后面看了提高课后又补充了一点）

![树状数组1.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_4e12b1e72c-树状数组1.jpg) 
![树状数组2.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_55e8fa0f2c-树状数组2.jpg) 

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=100000;
int a[maxn],tr[maxn];
//其实是从1开始存的

//tr[x]中的一共有几个a[x,x-1,……,x-lowbit+1]
int lowbit(int x){  //放回最末位的1
   return (x&-x); 
}
//修改操作
void add(int x,int y){
    //不断的找父节点
    for(int i=x;i<=n;i+=lowbit(i)){
        tr[i]+=y;
    }
}
//查询前缀和
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)){
        res+=tr[i];
    }
    return res;
}
int main(){
    
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        add(i,a[i]);//类似二维差分
    }
    while(m--){
        int k,x,y;
        cin>>k>>x>>y;
        if(k){
            add(x,y);
        }else{
            cout<<sum(y)-sum(x-1)<<endl;//前缀和思想
        }
    }
    
    return 0;
}
```

------





### 求`lowbit`+树状数组补充

![树状数组](https://cdn.acwing.com/media/article/image/2022/03/21/68493_42cbd032a8-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png)

> 补充：
>
> 这个x其实是表示前缀和(可以理解为要算的个数)
>
> `lowbit`是用来求二进制表示下最低位的1和后面的0组成的数，在树状数组中表示当前数组的个数（用这个去想前缀和比较简单）
>
> （1……1表示中间全是1，0同理）
>
> 原码:`~10……0`=>反码：`~01……1`=>
>
> 补码:`~10……0`(原码和补码的~，都是反的，后面部分是一样)
>
> 
>
> 儿子和爸爸：（对照着树状数组的图）(这个跟建树方法的法2有关)
>
> 儿子x:`……01……10……0`   
>
> 爸爸p:`……10……..……0`
>
> （所有子结点必然是这样,先-1然后爬到爸爸的下一个楼梯之前）(儿子+`lowbit(i)`能直接影响到的是唯一的)

#### 建树方法：（将数组变为树状树状）

##### 1. 一个数一个数单点修改（暴力，O($nlog_2n$)）

（90%的情况这个都适用，如果卡时间推荐用法3，比较不会错）

##### 2. 只加对应的子结点 （O($2n-1$)）

		(前面儿子和爸爸那边，对照着看)

![树状数组的图.png](https://cdn.acwing.com/media/article/image/2024/02/02/246003_9a6cf75ac1-树状数组的图.png) 

(可以重点看`C12`这个点)（先-1然后爬到爸爸的下一个楼梯之前）

复杂度分析：只会用到树边，且每条边只用一次（数有$n-1$条边）,算上原数组，总共$2n- 1$

```c++
for (int i = 1; i <= n; i++) {
    tr[i] = a[i];
    for (int j = i - 1; j > i - lowbit(i); j -= lowbit(j)) {
        tr[i] += tr[j];
    }
}
```

注意：**不要加上爸爸的前面的楼梯**

##### 3. 从定义出发用前缀和求(O(n))

$C_x = a[x-lowbit(x)+1 \cdots x]$

$C_x = S[x] - S[x-lowbit(x)]$



## 下标表示数轴=>求各种对的数量

 **AcWing 241. 楼兰图腾**
西部 $314$ 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 $n$ 个点，经测量发现这 $n$ 个点的水平位置和竖直位置是两两不同的。
西部 $314$ 认为这幅壁画所包含的信息与这 $n$ 个点的相对位置有关，因此不妨设坐标分别为 $(1,y_1),(2,y_2),…,(n,y_n)$，其中 $y_1 \sim y_n$ 是 $1$ 到 $n$ 的一个排列。
如果三个点 $(i,y_i),(j,y_j),(k,y_k)$ 满足 $1 \le i < j < k \le n$ 且 $y_i > y_j, y_j < y_k$，则称这三个点构成 `V` 图腾;
如果三个点 $(i,y_i),(j,y_j),(k,y_k)$ 满足 $1 \le i < j< k \le n$ 且 $y_i < y_j, y_j < y_k$，则称这三个点构成 `∧`图腾;
求出 `V` 的个数和 `∧`的个数。

```java
//树状数组
    //求各种前面或者后面大或者小的对相当好用（例如:逆序对）

/*思路：
    对于谷底i能构成'V'的个数为：前大*后大
    对于顶峰i能构成'∧'的个数为：'前小*后小
    
（将数放在数轴中，前面有几个就是小的个数，后面就是大的个数）
由于y的大小并不大，所以可以在yi这个位置上标记出现了一次，
从前往后一个个加：
    对于每个y[i]求前缀和：就是前小
                求后缀和(整个区间-y[i]前面)：就是前大
从后往前一个个加：
    对于每个y[i]求前缀和：就是后小
                求后缀和(整个区间-y[i]前面)：就是后大

这个思路会比归并求逆序对正序对简单很多*/
import java.util.*;
import java.io.*;
public class Main{
    static final int N=(int)2e5+10;
    static int n;
    static int[] a=new int[N];
    //树状数组
        //默认从1开始
    static int[] tr=new int[N];
    static int lowbit(int x){
        return x&(-x);
    }
    //1单点修改
    static void add(int x,int d){//在x这个位置上加上d
        //向上找爸爸
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i]+=d;
    }
    //2查询前缀和
    static int sum(int x){
        int res=0;
        //往前爬楼梯
        for(int i=x;i>0;i-=lowbit(i))
            res+=tr[i];
        return res;
    }
    
    static int[] up=new int[N],down=new int[N];
        //up记录前大，down记录前小
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        n=Integer.parseInt(br.readLine());
        String[] ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            a[i]=Integer.parseInt(ss[i-1]);
        //从左往右求
        for(int i=1;i<=n;++i){
            int y=a[i];
            up[i]=sum(n)-sum(y);//在前面，又比它大
            down[i]=sum(y-1);//前小
            add(y,1);//在数轴上标记上y这个位置
        }
        
        Arrays.fill(tr,0);//清空数组
        long res1=0,res2=0;//结果是会爆int的
                                //一个位置上的乘积都会爆
        //从右往前求
        for(int i=n;i>0;--i){
            int y=a[i];
            res1+=up[i]*(long)(sum(n)-sum(y));//*后大
            res2+=down[i]*(long)(sum(y-1));//后小
            add(y,1);
        }
        System.out.println(res1+" "+res2);
    }
}
```

资料：

图来自：[1](https://www.acwing.com/solution/content/102989/)

## 区间修改+单点查询=>用差分转为单点修改+区间查询

 **AcWing 242. 一个简单的整数问题**
给定长度为 $N$ 的数列 $A$，然后输入 $M$ 行操作指令。
第一类指令形如 `C l r d`，表示把数列中第 $l \sim r$ 个数都加 $d$。
第二类指令形如 `Q x`，表示询问数列中第 $x$ 个数的值。

----



```java
/*转为差分：
（差分的前缀和就是原数组）
    又能变为单点修改+区间查询*/
//这里用前缀和初始化（一般可以不用这个）
import java.io.*;
import java.util.*;
public class Main{
    static final int N=(int)1e5+10;
    static int n,m;
    static int[] s=new int[N];//原数组(是差分数组的前缀和)
    //树状数组
    static long[] tr=new long[N];//前缀和是会爆int的
    static int lowbit(int x){
        return x&-x;
    }
    static void init(){//用前缀和初始化，一般用不到
        //这里差分很特殊
        for(int i=1;i<=n;++i)
            tr[i]=s[i]-s[i-lowbit(i)];
    }
    static long sum(int x){
        long res=0;
        //往前爬楼梯
        for(int i=x;i!=0;i-=lowbit(i))
            res+=tr[i];
        return res;
    }
    static void add(int x,int d){
        //往上找找爸爸
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i]+=d;
    }
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);
        m=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)//从1开始
            s[i]=Integer.parseInt(ss[i-1]);
        init();
        while(m-- >0){
            ss=br.readLine().split(" ");
            String op=ss[0];
            if("C".equals(op)){
                int l=Integer.parseInt(ss[1]),r=Integer.parseInt(ss[2]),d=Integer.parseInt(ss[3]);
                //差分
                add(l,d);
                add(r+1,-d);
            }else{
                int x=Integer.parseInt(ss[1]);
                System.out.println(sum(x));
            }
        }
    }
}
```

## 区间修改+区间查询=>通过差分转为单点修改+区间查询
(求会原数组的前缀和时需要补成矩阵运算)
 **AcWing 246. 区间最大公约数** 
给定一个长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一：

- `C l r d`，表示把 $A[l],A[l+1],…,A[r]$ 都加上 $d$。
- `Q l r`，表示询问 $A[l],A[l+1],…,A[r]$ 的最大公约数($GCD$)。

----

![求会原数组的前缀和](https://cdn.acwing.com/media/article/image/2021/04/13/55909_2458a3c69c-%E5%A4%87%E6%B3%A8-2020%E5%B9%B47%E6%9C%8825%E6%97%A5.png)
> （一种错误的想法：就是如果不把代码补全直接用那个三角求如何？
> 这时你需要仔细看看，那个每个差分数$b_1$需要$(x-i+1)$个，会随着查询的x变化而变化，所以不行）

```java
//利用差分转为树状数组，求回前缀和时还需要补全矩阵后再算
import java.io.*;
import java.util.*;
public class Main{
    static final int N=(int)1e5+10;
    static int n,m;
    static int[] a=new int[N];
    
    //树状数组
    static long[] tr1=new long[N];//树状数组维护差分数组b[i]
    static long[] tr2=new long[N];//        维护i*b[i]数组
    static int lowbit(int x){
        return x&-x;
    }
    static void add(long[] tr,int x,long d){
        //向上找爸爸
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i]+=d;
    }
    static long sum(long[] tr,int x){//树状数组的前缀和
        //往前爬楼梯
        long res=0;
        for(int i=x;i!=0;i-=lowbit(i))
            res+=tr[i];
        return res;
    }
    static long prefix_sum(int x){//求会原数组的前缀和
        return sum(tr1,x)*(x+1)-sum(tr2,x);
    }
    public static void main(String[] args) throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);
        m=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            a[i]=Integer.parseInt(ss[i-1]);
        //暴力建树
        for(int i=1;i<=n;++i){
            int b=a[i]-a[i-1];
            add(tr1,i,b);
            add(tr2,i,(long)i*b);//只要是乘积一般都会爆int
        }
        while(m-- >0){
            ss=br.readLine().split(" ");
            String op=ss[0];
            int l=Integer.parseInt(ss[1]),r=Integer.parseInt(ss[2]);
            if("Q".equals(op)){
                System.out.println(prefix_sum(r)-prefix_sum(l-1));
            }else{
                int d=Integer.parseInt(ss[3]);
                //b[i]数组
                add(tr1,l,d);add(tr1,r+1,-d);
                //i*b[i]数组
                add(tr2,l,l*d);add(tr2,r+1,(r+1)*-d);//这里不会爆
            }
        }
        
    }
}
```
资料：
图来源[1](https://www.acwing.com/solution/content/44886/)



## 树状数组表示数轴+二分=>求第k小的数+删除某个数
(这个需要多看看思路，很有启发)
 **AcWing 244. 谜一样的牛** 
有 $n$ 头奶牛，已知它们的身高为 $1 \sim n$ 且各不相同，但不知道每头奶牛的具体身高。
现在这 $n$ 头奶牛站成一列，已知第 $i$ 头牛前面有 $A_i$ 头牛比它低，求每头奶牛的身高。
（注意：因为第 $1$ 头牛前面没有牛，所以并没有将它列出）

---

对于此类所求答案是未知的？
==**不断从边界问题出发**==（具体看下面的资料2）

----
**解题方法**：（来源资料1）
树状数组 + 二分，从后往前枚举时，有两个操作
1、从剩余的数中找第k小的数
2、删除某个数

**具体步骤：**

* 1、对于每头牛都初始化化为1，a[i] = 1,表示每头牛都未被使用，树状数组维护的是第i个高度中a[1] + a[2] + .. + a[i]的值，其中 a[i] 只有 0 和 1 两种情况
* 2、在剩余的数中找第 k 小，即在所有满足 sum(x) = k 情况中，通过二分找到最小的 x ，如图所示
![](https://cdn.acwing.com/media/article/image/2020/11/06/7416_99eb062220-b1c1ab46b331b822a0b5b2096307755.png)
* 3、找到了当前牛的高度后删除该牛的高度，继续枚举
```java
//树状数组+二分
/*从边界结尾出发，能照顾到全局：
发现刚好就是剩余数中$A_i+1$这个位置：
    需要查找到这个数，用过后就删掉
    1.找第k小的数
    2.删除某个数
    (这些原本可以用平衡树解决，但是这个比较复杂)
    可以用树状数组+二分来解决：
        用树状数组来装数轴上每个数的剩余几个(开始都是1个)
        然后用二分查找，找到其中排名k个（就是sum(x)=k中最小的那个）*/
import java.io.*;
import java.util.*;
public class Main{
    static final int N=(int)1e5+10;
    static int n;
    static int[] A=new int[N];
    static int[] ans=new int[N];
    //树状数组
        //这个肯定是不会爆int的
    static int tr[]=new int[N];
    static int lowbit(int x){
        return x&-x;
    }
    static void init(){
        for(int i=1;i<=n;++i){
            tr[i]=lowbit(i);//理解1：从定义出发，lowbit(i)表示这个数组的长度
                        //理解2：用前缀和建树：tr[i]=sum[i]-sum[i-lowbit(i)]
        }
    }
    static int sum(int x){//这里的前缀和还能表示排名
        //往前爬楼梯
        int res=0;
        for(int i=x;i!=0;i-=lowbit(i))
            res+=tr[i];
        return res;
    }
    static void add(int x,int d){
        //向上找爸爸
        for(int i=x;i<=n;i+=lowbit(i))
            tr[i]+=d;
    }
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
        n=Integer.parseInt(br.readLine());
        init();
        for(int i=2;i<=n;++i)
            A[i]=Integer.parseInt(br.readLine());
        //从后往前确定数字
        for(int i=n;i>0;--i){
        //找到第k个数
            int k=A[i]+1;//表示在数组中的排名
            int l=1,r=n;
            //找到符合条件的最小值
            while(l<r){
                int mid=l+r>>1;
                if(sum(mid)>=k) r=mid;
                else            l=mid+1;
            }
            ans[i]=l;
            add(l,-1);
        }
        for(int i=1;i<=n;++i)
            bw.write(ans[i]+"\n");
        bw.flush();
    }
}
//独立写没写出来，真的好妙，可以多看看
```
资料来源：
[1题解思路和图片](https://www.acwing.com/solution/content/24500/)

[2这个可以多看看如何思考此类问题](https://www.acwing.com/solution/content/3449/)

### 迭代器的暴力做法（过不了）

（实在不会可以用用这个）
这里`set`的迭代器找第k个数:`next(nums.begin(), k - 1)`
(从1开始)
虽然是平衡树，但是模板代码上是一个个找的，**时间复杂度为$O(n)$**，肯定是过不了的
```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
int n;
int h[N];
int ans[N];
set<int> s;
int main()
{   
    scanf("%d", &n);
    for (int i = 2; i <= n; i ++ ) scanf("%d", &h[i]);
    for(int i=1;i<=n;++i)
        s.insert(i);
    for(int i=n;i>0;--i){
        auto p=next(s.begin(),h[i]);//找第h[i]+1个元素
        ans[i]=*p;
        s.erase(p);
    }
    for (int i = 1; i <= n; i ++ ) printf("%d\n", ans[i]);
    return 0;
}
```
资料：[C++ 标准模板库 - 迭代器相关 (w3schools.cn)](https://www.w3schools.cn/cpp_standard_library/iterator.html)[C++迭代器 iterator详解-阿里云](https://developer.aliyun.com/article/977947)

# 线段树

> 一般是$1e5$的能用，如果超了很可能tle

第一次学的东西在这里：[蓝桥杯动态求区间和](https://www.acwing.com/activity/content/code/update/6155775/)

> 算法竞赛中还有一些

![线段树1.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_303f02432c-线段树1.jpg) 
![线段数2.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_35ac95c02c-线段数2.jpg) 





## 单点修改+区间最值

[**1275. 最大数**](https://www.acwing.com/problem/content/1277/)

给定一个正整数数列 $a_1,a_2,……,a_n$，每一个数都在 $0 \sim p-1$ 之间。
可以对这列数进行两种操作：

* 添加操作：向序列后添加一个数，序列长度变成 $n+1$；
* 询问操作：询问这个序列中最后 $L$ 个数中最大的数是多少。

程序运行的最开始，整数序列为空。
一共要对整数序列进行 $m$ 次操作。
写一个程序，读入操作的序列，并输出询问操作的答案。

----

这个写得相当不好：尤其是区间修改那边，写这个代码一定要谨慎

 **注意：只有建树那边传区间范围参数要传mid，其他函数一律不动除了结点的参数** 
 ==区间修改，跟哪个孩子区间相交要想清楚==

```java
import java.util.*;
import java.io.*;
class Node{
    int l,r;
    int v;//用来记录区间[l,r]中的最大值
    Node(int l,int r,int v){
        this.l=l;
        this.r=r;
        this.v=v;
    }
}
public class Main{
    static final int N=(int)2e5+10;
    static int m,p;
    static int last;
    static int n;//用来记录当前结点个数
//线段树模板
    static Node[] tr=new Node[N*4];
    static void pushUp(int u){
        tr[u].v=Math.max(tr[u<<1].v,tr[u<<1|1].v); 
    }
    static void build(int u,int l,int r){//建线段树
        tr[u]=new Node(l,r,0);
        if(l==r) return;
        int mid=l+r >>1;
        build(u<<1,l,mid);build(u<<1|1,mid+1,r);
        //pushUp，但是这里不需要，因为一开始没有一个元素
    }
    static int query(int u,int l,int r){//区间查询
        if(l<=tr[u].l&&tr[u].r<=r) return tr[u].v;
        int mid=tr[u].l+tr[u].r >>1;
        int v=0;
        if(l<=mid) v=query(u<<1,l,r);
        if(r>mid)  v=Math.max(v,query(u<<1|1,l,r));
        return v;
    }
    static void modify(int u,int x,int v){//单点修改
        if(tr[u].r==tr[u].l) tr[u].v=v;
        else{
            int mid=tr[u].l+tr[u].r >>1;
            if(mid>=x) modify(u<<1,x,v);
            else       modify(u<<1|1,x,v);
            pushUp(u);
        }
        // System.out.println(tr[u].v);
    }
    public static void main(String[] args) throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String[] ss=br.readLine().split(" ");
        m=Integer.parseInt(ss[0]);
        p=Integer.parseInt(ss[1]);
        build(1,1,m);
        while(m-- >0){
            ss=br.readLine().split(" ");
            String op=ss[0];
            int x=Integer.parseInt(ss[1]);
            if("A".equals(op)){
                ++n;
                x=(int)(((long)x+last)%p);
                modify(1,n,x);
                // System.out.println(query(1,n,n));
            }else{
                last=query(1,n-x+1,n);
                System.out.println(last);
            }
        }
    }
}
```



## 线段树动态（单点修改）求区间最大连续和
（考察用结点所包含信息，两儿子能否推出当前所有的信息）

 [AcWing 245. 你能回答这些问题吗 - AcWing](https://www.acwing.com/activity/content/problem/content/1608/)
给定长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一：

- `1 x y`，查询区间 $[x,y]$ 中的最大连续子段和，即 $\max\limits_{x \le l \le r \le y}${$\sum\limits^r_{i=l} A[i]$}。
- `2 x y`，把 $A[x]$ 改成 $y$。
对于每个查询指令，输出一个整数表示答案。

**数据范围：**$N \le 500000, M \le 100000$,$-1000 \le A[i] \le 1000$

----

分析：
如何求线段树结点的信息：

1. 先将答案维护出来
2. 用当前信息能否将答案算出，如果不行不断加额外信息
3. 判断能否算出额外信息
![最大连续子段和.jpg](https://cdn.acwing.com/media/article/image/2024/01/18/246003_9e3b98bcb5-最大连续子段和.jpg) 

[AcWing 245. 你能回答这些问题吗 - AcWing](https://www.acwing.com/solution/content/110854/)（这题解不错）

```java
import java.util.*;
import java.io.*;
//线段树的结点:
class Node{
    int l,r;
    int tmax,lmax,rmax,sum;
    Node(){}
    Node(int l,int r){
        this.l=l;
        this.r=r;
    }
    Node(int l,int r,int tmax,int lmax,int rmax,int sum){
        this.l=l;
        this.r=r;
        this.tmax=tmax;
        this.lmax=lmax;
        this.rmax=rmax;
        this.sum=sum;
    }
}
public class Main{
    static final int N=(int)5e5+10;
    static int n,m;
    static int[] a=new int[N];
    
//线段树
    static Node[] tr=new Node[N*4];
    //1.左右儿子合并
    static void pushup(int u){
        pushup(tr[u],tr[u<<1],tr[u<<1|1]);
    }
    static void pushup(Node u,Node l,Node r){//重载一下，就是简化一下代码
        u.tmax=Math.max(l.rmax+r.lmax,Math.max(l.tmax,r.tmax));
                      //1.横跨两区间2.只在左区间3.只在右区间
        u.lmax=Math.max(l.lmax,l.sum+r.lmax);
                //1.只有左区间的前缀2.包含一点右区间的前缀
        u.rmax=Math.max(r.rmax,r.sum+l.rmax);
        u.sum=l.sum+r.sum;
    }
    //2.建树
    static void build(int u,int l,int r){//注意：只有建树除了u的参数会变
        //小心java的对象数组
        if(l==r){
            tr[u]=new Node(l,r,a[l],a[l],a[l],a[l]);//这里一般都是从[1,n]
        }else{
            tr[u]=new Node(l,r);
            int mid=l+r >>1;
            build(u<<1,l,mid);
            build(u<<1|1,mid+1,r);
            pushup(u);
        }
    }
    //3.单点修改
    static void modify(int u,int x,int v){//将x这个位置改为v
        if(tr[u].l==x&&tr[u].r==x){
            tr[u]=new Node(x,x,v,v,v,v);
        }else{
            int mid=tr[u].l+tr[u].r >>1;
            //看是左还是右
            if(x<=mid) modify(u<<1,x,v);
            else       modify(u<<1|1,x,v);
            pushup(u);
        }
    }
    //4.区间查询
    static Node query(int u,int l,int r){
        //这里返回结点，因为后面也会区间合并的问题
        if(l<=tr[u].l&&tr[u].r<=r) return tr[u];
        else{
            //1.只在左区间2.只在右区间3.横跨两区间
                    //其实跟前面的代码是一样的
            int mid=tr[u].l+tr[u].r >>1;
            if(r<=mid)      return query(u<<1,l,r);
            else if(l>mid)  return query(u<<1|1,l,r);
            else{
                Node L=query(u<<1,l,r);
                Node R=query(u<<1|1,l,r);
                Node res=new Node();
                pushup(res,L,R);//合并操作只会改变根结点
                return res;
            }
        }
    }
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);
        m=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            a[i]=Integer.parseInt(ss[i-1]);
        build(1,1,n);
        while(m-- >0){
            ss=br.readLine().split(" ");
            int k=Integer.parseInt(ss[0]),x=Integer.parseInt(ss[1]),y=Integer.parseInt(ss[2]);
            if(k==1){
                if(x>y){
                    int t=x;
                    x=y;
                    y=t;
                }
                Node res=query(1,x,y);
                bw.write(res.tmax+"\n");
            }else modify(1,x,y);
        }
        bw.flush();
    }
}
```

> **这个区间查询好好看下，当树状数组需要存下多个区间值时**

## 涉及区间整体加的区间最大公约数

 **AcWing 246. 区间最大公约数** 
给定一个长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一：

- `C l r d`，表示把 $A[l],A[l+1],…,A[r]$ 都加上 $d$。
- `Q l r`，表示询问 $A[l],A[l+1],…,A[r]$ 的最大公约数($GCD$)。

对于每个询问，输出一个整数表示答案。

----
> 本题好好看看如何将原数组的最大公约数=>转为差分：
>
> 将原来数组转为差分数组后，【原来的数组】和【差分数组】的区间最大公约数相同
>
> > **注意：数组第一项**
> >
> > > 第一项需要是【原来数组】的第一项，这样才是当前数组对应的差分数组
> > >
> > > > 例如：$[1,n]$转为差分数组`b`后，求$[l,r]$数组对应的差分数组
> > > >
> > > > 对应的是$a[l],b[l+1],\dots,b[r]$就是$[l,r]$数组对应的差分数组

![区间最大公约数.jpg](https://cdn.acwing.com/media/article/image/2024/05/19/246003_516e598415-区间最大公约数.jpg) 

> 证明②实际为裴蜀定理

> 本题很取巧：转为了单点修改
>
> 转为用线段树存差分数组
> *要注意能构成一个区间*

```java
import java.util.*;
import java.io.*;
class Node{
    int l,r;
    long s,d;//区间和和区间公约数
    Node(){}
    Node(int l,int r){
        this.l=l;
        this.r=r;
    }
    Node(int l,int r,long s,long d){
        this.l=l;
        this.r=r;
        this.s=s;
        this.d=d;
    }
}
//会用到超过两次，就设置一个变量
public class Main{
    static int N=(int)5e5+10;
    static int n,m;
    static long[] A=new long[N];
    //求最大公约数
    static long gcd(long a,long b){
        return b!=0?gcd(b,a%b):a;
    }
    //线段树（里面存的数组只要差分数组）
    static Node[] tr=new Node[N*4];
    static void pushup(Node u,Node l,Node r){
        u.s=l.s+r.s;
        u.d=gcd(l.d,r.d);
    }
    static void pushup(int u){
        pushup(tr[u],tr[u<<1],tr[u<<1|1]);
    }
    static void build(int u,int l,int r){
        if(l==r) {
            long b=A[l]-A[l-1];
            tr[u]=new Node(l,r,b,b);
        }else{
            tr[u]=new Node(l,r);
            int mid=l+r >>1;
            build(u<<1,l,mid);
            build(u<<1|1,mid+1,r);
            pushup(u);
        }
    }
    //除了建树，其他除u以外的参数都不用改
    static Node query(int u,int l,int r){
        if(l<=tr[u].l&&tr[u].r<=r) return tr[u];
        else{
            int mid=tr[u].l+tr[u].r >>1;
            if(r<=mid)//只在左儿子
                return query(u<<1,l,r);
            else if(l>mid)//只在右儿子
                return query(u<<1|1,l,r);
            else{//横跨
                Node res=new Node();
                //原来的区间分为左右，在合并
                Node L=query(u<<1,l,r);
                Node R=query(u<<1|1,l,r);
                pushup(res,L,R);
                return res;
            }
            
        }
    }
    static void modify(int u,int x,long v){
        if(tr[u].l==x&&tr[u].r==x){
            long b=tr[u].s+v;
            tr[u]=new Node(x,x,b,b);
        }else{
            int mid=tr[u].l+tr[u].r >>1;
            if(x<=mid) modify(u<<1,x,v);//在左区间
            else       modify(u<<1|1,x,v);
            pushup(u);
        }
    }
        
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);m=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            A[i]=Long.parseLong(ss[i-1]);
        
        build(1,1,n+1);//避免越界
        
        while(m-- >0){
            ss=br.readLine().split(" ");
            String op=ss[0];
            int l=Integer.parseInt(ss[1]),r=Integer.parseInt(ss[2]);
            if("Q".equals(op)){
                //具体看笔记上的公式
                long x=query(1,1,l).s;
                long y=0;//gcd(x,0)=x注意这个小细节
                if(l+1<=r) y=query(1,l+1,r).d;
                bw.write(Math.abs(gcd(x,y))+"\n");//由于是差分会出现负数，所以需要绝对值
            }else{
                long d=Long.parseLong(ss[3]);
                //差分：区间修改
                modify(1,l,d);
                modify(1,r+1,-d);
            }
        }
        
        bw.flush();
    }
}
```

## 区间修改和区间查询（懒标记）
后面回顾时需要记起的地方：
1. 懒标记的含义
2. `pushup`左右儿子合并和`pushdown`分裂成左右儿子的位置

 **AcWing 243. 一个简单的整数问题2** 
给定一个长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一：

* `C l r d`，表示把 $A[l],A[l+1],…,A[r]$ 都加上 $d$。
* `Q l r`，表示询问数列中第 $l \sim r$ 个数的和。

对于每个询问，输出一个整数表示答案。

----

![懒标记.jpg](https://cdn.acwing.com/media/article/image/2024/01/20/246003_e963a3c3b7-懒标记.jpg)

> 说明：上面那个`+5 +10`，顺序其实不用，哪个是区间要加的数或者懒标记都没事 
>
> 这种情况就是标记不一致的情况，懒标记需要下放
>
> 同时，就是懒标记下方的点，其实都没有修改，所有后面如果要查询时，也需要下放

```java
//线段树就是将一个区间不断区间分为两个区间
//懒标记：注意pushup和pushdown位置
import java.util.*;
import java.io.*;
class Node{
    int l,r;
    //这个区间和肯定会爆int
    long sum;//表示区间和
    long add;//懒标记：具体含义就是给[l,r]每个数都加上add
                 //给以当前结点为根的子树中的每个结点都加上add这个数（规定不包含当前区间自己）
    Node(){}
    Node(int l,int r){
        this.l=l;
        this.r=r;
    }
    Node(int l,int r,int s,int a){
        this.l=l;
        this.r=r;
        this.sum=s;
        this.add=a;
    }
}
public class Main{
    static int N=(int)1e5+10;
    static int n,m;
    static int[] A=new int[N];
    //线段树
    static Node[] tr=new Node[4*N];
    static void pushup(int u){//两儿子合并
            //线段树的信息并不复杂，所有不需要重载了
        tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
        //一般使用到合并，那么懒标记已经下放清空了，所有这里没有涉及懒标记
    }
    static void pushdown(int u){//懒标记下放
        //当前结点的区间和sum跟自己的懒标记add是没有关系的
        Node root=tr[u],left=tr[u<<1],right=tr[u<<1|1];//在java中这样相当于引用
        //当懒标记为0时就不需要下放了
        if(root.add!=0){
            left.add+=root.add;
            left.sum+=(left.r-left.l+1)*root.add;
            right.add+=root.add;
            right.sum+=(right.r-right.l+1)*root.add;
            root.add=0;
        }
    }
    static void build(int u,int l,int r){
        if(l==r) tr[u]=new Node(l,r,A[l],A[l]);
        else{
            tr[u]=new Node(l,r);
            //建好左右孩子，在合并
            int mid=l+r >>1;
            build(u<<1,l,mid);
            build(u<<1|1,mid+1,r);
            pushup(u);
        }
    }
                //除建树其他除u外其他参数都不用改
    //注意：这里是区间修改，将[l,r]+d
        //懒标记跟区间查询差不多，就是如果包含了这个结点所表示的区间就能够返回了
    static void modify(int u,int l,int r,int d){
        if(l<=tr[u].l&&tr[u].r<=r){
            //打上懒标记，但需要注意就是不包括根节点，所以这个区间和要算出来
            tr[u].add+=d;
            tr[u].sum+=(tr[u].r-tr[u].l+1)*d;
        }else{
            //用到左右儿子，懒标记要下放，需要统一标记
            pushdown(u);
            int mid=tr[u].l+tr[u].r >>1;
            if(l<=mid) modify(u<<1,l,r,d);
            if(r>mid)  modify(u<<1|1,l,r,d);
            pushup(u);
        }
    }
    static long query(int u,int l,int r){
        if(l<=tr[u].l&&tr[u].r<=r) return tr[u].sum;
        //用到左右儿子，懒标记下放
        pushdown(u);
        long res=0;
        int mid=tr[u].r+tr[u].l >>1;
        //看这个区间涉及哪几个儿子
        if(l<=mid) res+=query(u<<1,l,r);
        if(r>mid)  res+=query(u<<1|1,l,r);
        return res;
    }
    public static void main(String[] args) throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);
        m=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            A[i]=Integer.parseInt(ss[i-1]);
        
        build(1,1,n);
        while(m-- >0){
            ss=br.readLine().split(" ");
            String op=ss[0];
            int l=Integer.parseInt(ss[1]),r=Integer.parseInt(ss[2]);
            if("Q".equals(op)) 
                bw.write(query(1,l,r)+"\n");
                // System.out.println(query(1,l,r));
            else{
                int d=Integer.parseInt(ss[3]);
                modify(1,l,r,d);
            }
        }
        
        bw.flush();
    }
}
```

## 有乘和加的懒标记

有懒标记且对当前区间打上标记时，比较复杂： 可以写个`eval(Node t,~)`的函数
（`pushdown`的时候或者区间修改时包含区间的时候）



 [AcWing 1277. 维护序列 - AcWing](https://www.acwing.com/activity/content/problem/content/1612/)

> 在一个序列中：
>
> 操作 $1$：`1 t g c`，表示把所有满足 $t \le i \le g$ 的 $a_i$ 改为 $a_i \times c$;    
>
> 操作 $2$：`2 t g c`，表示把所有满足 $t \le i \le g$ 的 $a_i$ 改为 $a_i + c$；
>
> 操作 $3$：`3 t g`，询问所有满足 $t \le i \le g$ 的 $a_i$ 的和模 $P$ 的值。

**数据范围：**$1 \le N,M \le 10^5$,$1 \le t \le g \le N$,$0 \le c,a_i \le 10^9$,$1 \le P \le 10^9$

----

分析:

懒标记：要满足可叠加性，**同一个区间多次操作，标记要能叠加**（不然用不了）(有点优先级问题了)

> 特别是有多个懒标记时，需要特别注意下

![IMG20240129103424.jpg](https://cdn.acwing.com/media/article/image/2024/01/29/246003_12ad8adabe-IMG20240129103424.jpg) 

一些小错误整理：

- 整型相乘一定要开`ll`

- (`java`)爆`int`:如果运算过程中会出现`ll`，但是又通过取模回到整型

  注意观察这个式子：`(int)((long)t.sum*mul+(long)(t.r-t.l+1)*add)%p`

  整数转换的优先级特别高，在取模前(int)(long)已经被转为整型了，才取模，这个时候就是错的

  应该改成：

  ```java
  (int)(((long)t.sum*mul+(long)(t.r-t.l+1)*add)%p)
  ```

  注意：`int`转换==一定要保证是最后运算==

```java
import java.util.*;
import java.io.*;
    //乘法肯定会爆int
class Node{
    int l,r;
    int sum;//这里还是不全开long，练习一下，记得每次都要取模
    int add,mul;//两种懒标记=>注意：有先后顺序,先乘后加【区间*mul+add】（具体解释看分析）
        //写代码的时候注意：懒标记不包含当前结点
    //特别注意：乘法的懒标记清空时为1
    Node(int l,int r,int s,int a,int m){
        this.l=l;
        this.r=r;
        sum=s;
        add=a;
        mul=m;
    }
}
public class Main{
    static final int N=(int)1e5+10;
    static int n,p,m;
    static int[] w=new int[N];
    
    //线段树
    static Node[] tr=new Node[N*4];//开四倍空间
    static void pushup(int u){//进行合并时，懒标记要先清空
        tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
    }
    static void build(int u,int l,int r){//只有这个参数都变
        if(l==r){
            tr[u]=new Node(l,l,w[l],0,1);
        }else{
            tr[u]=new Node(l,r,0,0,1);
            int mid=l+r >>1;
            build(u<<1,l,mid);
            build(u<<1|1,mid+1,r);
            pushup(u);
        }
    }
    static void eval(Node t,int add,int mul){//计算当前更新结点的所有信息
                    //用了两次以上封装一下
        t.sum=(int)(((long)t.sum*mul+(long)(t.r-t.l+1)*add)%p);
        t.add=(int)(((long)t.add*mul+add)%p);//这里注意一下
        t.mul=(int)((long)t.mul*mul%p);
    }
    static void pushdown(int u){//懒标记下放
        eval(tr[u<<1],tr[u].add,tr[u].mul);
        eval(tr[u<<1|1],tr[u].add,tr[u].mul);
        //最后别忘记清空懒标记
        tr[u].add=0;
        tr[u].mul=1;
    }
    //这里有个小优化，将加和乘合并了
    static void modify(int u,int l,int r,int add,int mul){//区间修改
        if(l<=tr[u].l&&tr[u].r<=r){//包含这个区间
            eval(tr[u],add,mul);
        }else{
            pushdown(u);
            int mid=tr[u].l+tr[u].r >>1;
            if(l<=mid) modify(u<<1,l,r,add,mul);
            if(r>mid)  modify(u<<1|1,l,r,add,mul);
            pushup(u);
        }
    }
    static int query(int u,int l,int r){
            //包含
        if(l<=tr[u].l&&tr[u].r<=r) return tr[u].sum;
        else{
            pushdown(u);
            int mid=tr[u].l+tr[u].r >>1;
            int ans=0;
            if(l<=mid) ans+=query(u<<1,l,r);
            if(r>mid)  ans=(ans+query(u<<1|1,l,r))%p;
            return ans;
        }
    }
    public static void main(String[] args)throws Exception{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
        String[] ss=br.readLine().split(" ");
        n=Integer.parseInt(ss[0]);
        p=Integer.parseInt(ss[1]);
        ss=br.readLine().split(" ");
        for(int i=1;i<=n;++i)
            w[i]=Integer.parseInt(ss[i-1]);
        build(1,1,n);//不要忘记建树
        m=Integer.parseInt(br.readLine());
        while(m-- >0){
            ss=br.readLine().split(" ");
            int op=Integer.parseInt(ss[0]);
            int l=Integer.parseInt(ss[1]),r=Integer.parseInt(ss[2]);
            if(op==1){
                int d=Integer.parseInt(ss[3]);
                modify(1,l,r,0,d);
            }else if(op==2){
                int d=Integer.parseInt(ss[3]);
                modify(1,l,r,d,1);
            }else{
                bw.write(query(1,l,r)+"\n");
            }
        }
        bw.flush();
    }
}
/*碎碎念：
    哎呀，那个优先级，理解了半天，
    因为那个规定的不包括根节点把我给的绕进去的，但其实这个无关紧要（不要去想这个）
    区间该那样加还是乘还是那样*/ 
//哇靠改bug也改半天
```


## 离散化+扫描线（特殊线段树）
[AcWing 247. 亚特兰蒂斯 - AcWing](https://www.acwing.com/activity/content/problem/content/1611/)
直角坐标系中有多个矩形，计算这些矩形的总面积
接下来 $n$ 行，描绘了每张地图，每行包含四个数字 $x_1,y_1,x_2,y_2$（**不一定是整数**），$(x_1,y_1)$ 和 $(x_2,y_2)$ 分别是地图的左上角位置和右下角位置。

**数据范围：**$1 \le n \le 10000$,$0 \le x_1 \lt x_2 \le 100000$,$0 \le y_1 \lt y_2 \le 100000$

---

![题目](https://cdn.acwing.com/media/article/image/2019/12/26/19_4acba44c27-%E6%97%A0%E6%A0%87%E9%A2%98.png)
![](https://pic4.zhimg.com/80/v2-0045211a70609cd146fb1908fa9d55fb_1440w.webp)
![](https://pic1.zhimg.com/80/v2-5bb99a5e69f525826e9d01328c12a204_1440w.webp)
(旋转一下看)平行于y轴，从小到大扫下来
（总体积=用x轴分割的每个矩形的面积和)
当前矩形的一条边=当前扫描线区间覆盖的总长度
总体积=【与上一个x的差值】*【当前扫描线覆盖长度】

> **线段树存的结点也离散化了，根以往不同这里结点表示的是一段区间**
>
> `pushdown`的目的：避免整个区间标记不一致，但是这里只要被标记，下面所有都被包含

```java
//离散化+扫描线（特殊线段树）    //（本题有点特殊，可以硬记）
/*扫描线：
  （把只保留图形的轮廓，不管里面怎么样）
  本题是用平行于y轴的线，垂直于x轴从小到大扫描
  这样就能将这个不规则的图形，又重新变为一个个矩形*/
/*离散化：
  线段树的本质就是分割区间，这个区间是那种整数区间
  但是这题都是浮点数
  因此需要离散化:
      将这些浮点数从小到大，然后映射到一个新的紧凑的轴上
      例：1.29，2.63，6.66……，1e9
              =>如果按原来数轴长度至少要1e9，而且还有小数
          离散化后：0，   1，     2……，   n
                    1.29  2.63    6.66    1e9
                  （上下对应）*/
import java.util.*;
import java.io.*;
class Line implements Comparable<Line>{//矩形的边
  double x;//
  double y1,y2;//边所对应的上下界
  int k;//用来标记是矩形开始(+1)边还是结束边(-1)
  Line(double x,double y1,double y2,int k){
      this.x=x;
      this.y1=y1;
      this.y2=y2;
      this.k=k;
  }
  public int compareTo(Line o){//设置比较方法
      return Double.compare(x,o.x);
  }
}
class Node{//线段树的结点:表示其实是区间数组
  int l,r;//表示的是y[l]~y[r+1]这个区间
  int cnt;//表示当前区间最先被矩形边包含的次数(能被包含后就不继续看这个区间的儿子们了）
      /*由于这题很特殊：
          一开始表示这段区间出现了多少次（只需要看是否等于0，所以后续会做一些优化，优化后这个值不在准确）
          这个cnt是可以当作标记的，区间修改是改这个，但又不一样，没有必要pushdown*/
  double len;//当前区间被覆盖的长度（准确）
  Node(int l,int r){
      this.l=l;
      this.r=r;
  }
}
/*本题很特殊：
cnt标记已经不是传统意义的懒标记:
  (这里不探究为什么不需要pushdown，感觉不是一个东西，探究也没有意义)
探究一下为什么对吧？
  明确线段树的结点表示的是“一段区间”：（跟以前也不一样）
      ys[tr[u].l]~ys[tr[u].r+1]
      
  这里你需要很明确cnt是什么？
      cnt准确来说应该是表示：当前区间被边‘首次’包含的次数
                              (首次：指的是第一个符合包含条件，
                                  然后就不往下了，不看那些儿子们了)

  首先你需要仔细看看那个pushup已经不是单纯两个儿子合并了
  他还跟自己的cnt是有关系的
  如果能确实这个区间已经被边包含（cnt>0），那么都没必要往下看了，直接看其所表示的上下界ys[l]~ys[r+1]
  如果不能确定被包含，就是两个更新过的儿子相加（前面已经更新过左右儿子，所以能保证是对的）
  
  修改的时：
      开始边：+1
          只要被边包含时，就没必要看他的儿子们了，一定就是包含这一整段了
      结束边：-1
          (补充说明：（感觉其实也没必要）
          开始边和结束边的上下界是相同的，然后他们进行加减的结点肯定是相同的
          在+1的基础上在-1：开始边出现过的痕迹就会被完全抹除)
          当开始被边包含时，肯定是前面的开始边修改过的（+1），因为开始边没往下，结束边也没必要往下
*/
public class Main{
  static int N=(int)1e5+10;//哎呀，怎么会是10万
  static Line[] line=new Line[N*2];//注意有开始和结束两条线
  //离散化
  static ArrayList<Double> ys=new ArrayList<>();//承接y轴上用到的点
  static int find(double x){//找离散化后对应的坐标
                              //二分查找(左找模板)
      int l=0,r=ys.size()-1;
      while(l<r){
          int mid=l+r >>1;
          if(ys.get(mid)<x) l=mid+1;
          else              r=mid;//包含答案直接等，另一个要凑等
      }
      return l;
      // return Collections.binarySearch(ys,x);
  }
  //线段树
  static Node[] tr=new Node[N*2*4];//y有上下两个再乘4
  static void build(int u,int l,int r){//这个比较特殊，从空开始建所以这样就行
      tr[u]=new Node(l,r);
      if(l==r) return;
      int mid=l+r >>1;
      build(u<<1,l,mid);
      build(u<<1|1,mid+1,r);
  }
  static void pushup(int u){
      if(tr[u].cnt!=0)
          tr[u].len=ys.get(tr[u].r+1)-ys.get(tr[u].l);
      else if(tr[u].l!=tr[u].r)//不确定他的儿子们是否被包含
          tr[u].len=tr[u<<1].len+tr[u<<1|1].len;
      else
          tr[u].len=0;
  }
  static void modify(int u,int l,int r,int k){
      //修改当前边覆盖的区间的个数
      if(l<=tr[u].l&&tr[u].r<=r){//首先被包含的区间
          tr[u].cnt+=k;
      }else{//不能完全覆盖接着往下找
          int mid=tr[u].l+tr[u].r >>1;
          if(mid>=l) modify(u<<1,l,r,k);
          if(mid<r)  modify(u<<1|1,l,r,k);
      }
      pushup(u);
  }
  public static void main(String[] args)throws Exception{
      int T=0;
      //哇靠这样就超时了
      BufferedReader bw=new BufferedReader(new InputStreamReader(System.in));
      String[] ss;
      while(true){
          int n=Integer.parseInt(bw.readLine());
          if(n==0) break;
          ++T;//有几个样例
          for(int i=0,j=0;i<n;++i){
              ss=bw.readLine().split(" ");
              double x1=Double.parseDouble(ss[0]);
              double y1=Double.parseDouble(ss[1]);
              double x2=Double.parseDouble(ss[2]);
              double y2=Double.parseDouble(ss[3]);
              line[j++]=new Line(x1,y1,y2,1);//开始
              line[j++]=new Line(x2,y1,y2,-1);//结束
              ys.add(y1);ys.add(y2);
          }
          Arrays.sort(line,0,2*n);//部分排序[l,r)
          //java中离散化：去重+排序
          ys=new ArrayList(new TreeSet(ys));
         
          build(1,0,ys.size()-2);//注意线段树表示的是区间
          double res=0;
          for(int i=0;i<2*n;++i){
            if(i>0)//最开始那个边是没有面积的
                res+=tr[1].len*(line[i].x-line[i-1].x);
                      //只需要查询整个区间
            modify(1,find(line[i].y1),find(line[i].y2)-1,line[i].k);
                               //注意这里的-1,因为线段树的结点表示的区间
            // System.out.printf("y1=%.1f,y2=%.1f,%.2f\n",line[i].y1,line[i].y2,tr[1].len);
          }
          System.out.printf("Test case #%d\n",T);
          System.out.printf("Total explored area: %.2f\n\n",res);
      }
  }
}
//哎呀，整了好久，还挺抽象的，感觉不能过分关注pushdown标记之类的
```
参考：
[1](https://zhuanlan.zhihu.com/p/610898003)  	[2](https://www.acwing.com/activity/content/code/content/2005991/)






## 线段树错误整理

1. 空间要开区间的四倍

2. 除了建树那边函数的参数全部会变,其他的都不要动

3. `mid`本质都是树的中点，只有建树那里是`l+r >>1`

4. 如果是对区间操作的话（下面那些的条件一定要注意，这些条件都是并列的）

   （然后这些是跟mid判断的）

   1）全被包含

   2）①是否有右区间

   	  ②是否有左区间

   （如果涉及区间合并`pushup`那么还需要一种③处在中间）
   
   
   
   > 部分解释：
   >
   > 对于第2点：（可以不看，就是要记住上面那些都行）
   >
   > [可以看看下面评论区的问题](https://www.acwing.com/activity/content/code/content/167944/)
   >
   > 	比如查询操作，如果参数后面变了：
   >
   > ```c++
   > if (l <= mid) sum = query(u << 1, l, mid)%p;
   > if (r > mid) sum = (sum + query(u << 1 |1,mid+1,r)) % p;
   > ```
   >
   > 这样有时候会多查询一些多余区间：
   >
   > ![](https://i.bmp.ovh/imgs/2022/07/27/e8ce0d3a240ac263.png)
   
5. 乘法的懒标记清空还是初始为1

6. 懒标记：再用儿子时就必须清空（比如`pushup`时，懒标记肯定都清空了）

7. 千万不要忘记建树了

8. 涉及离散化：注意点的个数（一般都是倍数）：

   	比如[l,r]（$l<=r<=1e9$）:这时要开$2*区间个数$

   





# 图论



## 差分约束

> **必须从问题出发，不要瞎建图**

### 理论基础：

![差分约束1.jpg](https://cdn.acwing.com/media/article/image/2024/05/15/246003_2aabfbe612-差分约束1.jpg) 
![差分约束2.jpg](https://cdn.acwing.com/media/article/image/2024/05/15/246003_305c62a712-差分约束2.jpg) 



### 例题：

#### 不等式转为边

[AcWing 1169. 糖果 - AcWing](https://www.acwing.com/activity/content/problem/content/1533/)

幼儿园里有 $N$ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。
老师需要满足小盆友的所有需求：

> 如果 $X = 1$．表示第 $A$ 个小朋友分到的糖果必须和第 $B$ 个小朋友分到的糖果一样多。
> 如果 $X = 2$，表示第 $A$ 个小朋友分到的糖果必须少于第 $B$ 个小朋友分到的糖果。
> 如果 $X = 3$，表示第 $A$ 个小朋友分到的糖果必须不少于第 $B$ 个小朋友分到的糖果。
> 如果 $X = 4$，表示第 $A$ 个小朋友分到的糖果必须多于第 $B$ 个小朋友分到的糖果。
> 如果 $X = 5$，表示第 $A$ 个小朋友分到的糖果必须不多于第 $B$ 个小朋友分到的糖果。

老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 $-1$。

**数据范围：**$1 \le N \le 10^5$,$1 \le K \le 10^5$,$1 \le X \le 5$,$1 \le A,B \le N$

样例：

```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1
输出：11
```

---

![acwing糖果.jpg](https://cdn.acwing.com/media/article/image/2024/05/15/246003_35f80f5412-acwing糖果.jpg)

```java
//差分约束的理论要先搞懂，不然没用

/**
 * 找最小值
 * 每一种路径就是一个不等式组，首先要满足所有的不等式
 * 求所有不等式的下界=>找到上界的最大值（每个都要满足）=>最长路
 * 
 * 把题目的都转为：Xi ? Xj +Ck
 * 然后在转换为边
 * 
 * 找最长路，当纯在正环时，就是无解
 */
import java.io.*;
import java.util.*;
public class Main{
	static final int N=(int)1e5+10,M=(int)3e5+10;
		//边数：初始源点会跟每个点连，每次加边最多可能加2条，所以一共就是三倍
	static int n,m;
	//邻接表
	static int e[]=new int[M],ne[]=new int[M],w[]=new int[M],h[]=new int[N],idx;
	static void init() {
		Arrays.fill(h,-1);
	}
	//连x->z,边权是z
	static void add(int x,int y,int z) {
		e[idx]=y;w[idx]=z;ne[idx]=h[x];h[x]=idx++;
						//指向上一次同起点出现的位置；记录下这个起点最后一次出现的位置
	}
	static int dist[]=new int[N],cnt[]=new int[N];
	//队列也能栈，这里用栈优化下
	static int q[]=new int[N],hh,tt;
	static boolean st[]=new boolean[N];
	/**
	 * spfa判断负环，顺便求下最短路
	 * @return
	 */
	static boolean spfa() {
		int hh=0,tt=-1;
		Arrays.fill(dist,(int)-1e9);//最长路所以要初始较小话
		//虚拟源点
		dist[0]=0;//注意了
		q[++tt]=0;
		st[0]=true;
		while(hh<=tt) {
			int x=q[tt--];//弹出
			st[x]=false;
			for(int i=h[x];i!=-1;i=ne[i]) {
				int y=e[i];
				int td=dist[x]+w[i];
				if(dist[y]<td) {//注意喽，最长路
					dist[y]=td;
//					System.out.println(x+" "+y);
					if(!st[y]) {//没在队列中才入队，重复更新没有意义
						st[y]=true;
						q[++tt]=y;
					}
					cnt[y]=cnt[x]+1;//记录下步数
					if(cnt[y]>n)	return false;//呜呜，这里要注意，有问题，不能取等
				}
			}
		}
		return true;
	}
	
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String ss[]=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		m=Integer.parseInt(ss[1]);
		init();
		//创建虚拟源点0
			//题目隐含条件每个小盆友都分到糖果：Xi>=1
		for(int i=1;i<=n;++i)
			add(0,i,1);
		while(m-- >0) {
			ss=br.readLine().split(" ");
			int op=Integer.parseInt(ss[0]),a=Integer.parseInt(ss[1]),b=Integer.parseInt(ss[2]);
			//把不等式都转换为边
			if(op==1) {
				add(a,b,0);
				add(b,a,0);
			}else if(op==2) add(a,b,1);
			else if(op==3)	add(b,a,0);
			else if(op==4)	add(b,a,1);
			else 			add(a,b,0);
		}
		if(!spfa()) 
			System.out.println(-1);
		else {
			long res=0;//可能爆
			for(int i=1;i<=n;++i) 
				res+=dist[i];
			System.out.println(res);
		}	
	}
}
```

> **注意：如果有虚拟源点时，判断负环时，一定要算上**

> 笔记：[AcWing 1169. 糖果 - AcWing](https://www.acwing.com/solution/content/37324/)

#### 前缀和思想+差分约束

[AcWing 362. 区间 - AcWing](https://www.acwing.com/activity/content/problem/content/1534/)

给定 $n$ 个区间 $[a_i,b_i]$ 和 $n$ 个整数 $c_i$。
你需要构造一个整数集合 $Z$，使得 $\forall i \in [1,n]$，$Z$ 中满足 $a_i \le x \le b_i$ 的整数 $x$ 不少于 $c_i$ 个。
求这样的整数集合 $Z$ 最少包含多少个数。

**数据范围**：$1 \le n \le 50000$,$0 \le a_i,b_i \le 50000$,$0 \le c_i \le b_i-a_i+1$

---

![区间.jpg](https://cdn.acwing.com/media/article/image/2024/05/15/246003_3ac1177e12-区间.jpg) 

> [AcWing 362. 区间 贪心 + 数据结构做法 - AcWing](https://www.acwing.com/solution/content/6528/):看看贪心做法

```java
/**
 * 其实就是在每个位置上选或不选，sum[i]<=sum[i-1]+1,sum[i]>=sum[i-1]
 * 另一个条件就是题目那些了
 * 
 * 通过前缀和思想转为不等式关系，一定不能漏掉不等式
 * 就能变为差分约束
 * 
 * 注意：全部往后移一格
 * 
 * 对于最长路：
 * 	i->j	因为有虚拟源点的原因，前面的点值是确定的
 * 	dist[i]+Ck<=dist[j]
 * 	求所有的不等式的下界=>每个下界对应到一条从0到1的路径
 * 	求下界的最小值=>需要满足所有的下界=>求下界的最大值=>因此求的是最长路
 * 
 * 然后因为题目一定有解，所以不存在正环
 */
//具体分析细节写在笔记上
import java.io.*;
import java.util.*;
public class Main{
	static final int N=(int)5e4+10,M=N*3;
	static final int n=(int)5e4+1;//点的下标
	//存图：邻接表
	static int h[]=new int[N],ne[]=new int[M],e[]=new int[M],w[]=new int[M],idx;
	static void init() {
		Arrays.fill(h,-1);
	}
	static void add(int x,int y,int z) {
		e[idx]=y;w[idx]=z;ne[idx]=h[x];h[x]=idx++;
	}
	
	static int[] dist=new int[N];//最后其实表示的是前缀和，看有几个点
	//用栈来，感觉会比队列方便点
	static boolean[] st=new boolean[N];//是否在队列中
	static int q[]=new int[N],hh,tt=-1;
	//找最长路
	static void spfa() {
		Arrays.fill(dist,-M);//初始较小话
		q[++tt]=0;
		st[0]=true;
		dist[0]=0;//虚拟源点
		while(tt>=hh) {
			int x=q[tt--];
			st[x]=false;
			for(int i=h[x];i!=-1;i=ne[i]) {
				int y=e[i];
				int t=dist[x]+w[i];
				if(t>dist[y]) {
					dist[y]=t;
					if(!st[y]) {//入队
						st[y]=true;
						q[++tt]=y;
					}
				}
			}
		}
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		//初始话
		int m=Integer.parseInt(br.readLine());
		init();
		//前缀和思想：1.前者大于后者2.每个位置最多只有一个
		//注意：集体往后移一格
			//0就是虚拟源点了
		for(int i=1;i<=n;++i) {
			add(i,i-1,-1);
			add(i-1,i,0);
		}
		String[] ss;
		while(m-- > 0) {
			ss=br.readLine().split(" ");
			int l=Integer.parseInt(ss[0]),r=Integer.parseInt(ss[1]),c=Integer.parseInt(ss[2]);
			++l;++r;//不用忘了，集体移一格
			add(l-1,r,c);
		}
		spfa();
		System.out.println(dist[n]);
	}
}
```

#### 虚拟源点等价代换+起点选择

> 好好看看推导，本题可以加深对差分约束的理解

[1170. 排队布局 - AcWing题库](https://www.acwing.com/problem/content/description/1172/)

第一行包含三个整数 $N,M_L,M_D$。
接下来 $M_L$ 行，每行包含三个正整数 $A,B,L$，表示奶牛 $A$ 和奶牛 $B$ 至多相隔 $L$ 的距离。
再接下来 $M_D$ 行，每行包含三个正整数 $A,B,D$，表示奶牛 $A$ 和奶牛 $B$ 至少相隔 $D$ 的距离。

输出一个整数，如果不存在满足要求的方案，输出-1；如果 $1$ 号奶牛和 $N$ 号奶牛间的距离可以任意大，输出-2；否则，输出在满足所有要求的情况下，$1$ 号奶牛和 $N$ 号奶牛间可能的最大距离。

**数据范围：**$2 \le N \le 1000$,$1 \le M_L,M_D \le 10^4$,$1 \le L,D \le 10^6$

----

- 超级源点：

  - 能够遍历所有的边

  - 每个点都与一个常数有关

    > 等价于一开始到所有点，可以先将所有点都入队

> 笔记好好看下

![排队布局.jpg](https://cdn.acwing.com/media/article/image/2024/05/18/246003_e528118314-排队布局.jpg) 

```java
//猜想：
//1.n是否为超级源点
//2.起点什么的是不是不重要，主要能满足到遍历到所有边就行吗？

//本题有点裸，具体分析看笔记
//求最大距离，用最短路
	//这里先按y总的写法，后面在测试
import java.util.*;
import java.io.*;
public class Main{
	static final int N=(int)1e3+10,M=(int)21010;//边数就要具体算了
	static int n;
	//邻接表存下图
	static int h[]=new int[N],ne[]=new int[M],e[]=new int[M],w[]=new int[M],idx;
	static void init() {
		Arrays.fill(h,-1);
	}
	static void add(int x,int y,int z) {
		ne[idx]=h[x];e[idx]=y;w[idx]=z;h[x]=idx++;
	}
	
	//spfa求最短路
	static int[] dist=new int[N];
	static boolean[] st=new boolean[N];//看是否在队列中
	static int q[]=new int[N],hh,tt;//这里不太一样，用队列版
	static int[] cnt=new int[N];//用来判断走了多少次
	/**
	 * 判断有没有负环
	 * @param size：要几个点要变为起点
	 * 	这里点小技巧，刚好就是加1号或者是全部点
	 * @return
	 */
	static int INF=(int)1.5e9+10;//看看数据范围，最大也不能超过1e9
	static boolean spfa(int be) {
		//初始化
		Arrays.fill(dist,INF);
		Arrays.fill(st,false);
		Arrays.fill(cnt,0);
		
		hh=0;tt=-1;
		dist[be]=0;
		st[be]=true;
		q[++tt]=be;
	
		while(hh<=tt) {
			int x=q[tt--];//一个队列不需要重复的点
				//只需要更新就好了，在放入就会重复更新，没有意义
			st[x]=false;
			for(int i=h[x];i!=-1;i=ne[i]) {
				int y=e[i];
				int t=dist[x]+w[i];
				if(dist[y]>t) {//最短路
					dist[y]=t;
					cnt[y]=cnt[x]+1;
//					System.out.println(x+" "+y+" "+dist[y]);
					if(cnt[y]>=n)//这回没有虚拟源点所以没事
						return false;
					if(!st[y]) {
						q[++tt]=y;
						st[y]=true;
					}
				}
			}
		}
		return true;
		
	}
	
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		int m1=Integer.parseInt(ss[1]),m2=Integer.parseInt(ss[2]);
		init();
		for(int i=1;i<n;++i)
			add(i+1,i,0);
		while(m1-- > 0) {
			ss=br.readLine().split(" ");
			int a=Integer.parseInt(ss[0]),b=Integer.parseInt(ss[1]),c=Integer.parseInt(ss[2]);
			if(a>b) {
				int t=a;
				a=b;
				b=t;
			}
			add(a,b,c);
		}
		while(m2-- > 0) {
			ss=br.readLine().split(" ");
			int a=Integer.parseInt(ss[0]),b=Integer.parseInt(ss[1]),c=Integer.parseInt(ss[2]);
			if(a>b) {
				int t=a;
				a=b;
				b=t;
			}
			add(b,a,-c);
		}
		if(!spfa(n)) 
			System.out.println(-1);//判断是否还有负环
		else {
			spfa(1);
			if(dist[n]==INF)
				System.out.println(-2);
			else
				System.out.println(dist[n]);
		}
	}
}
```

> 回答猜想：
>
> - ==**差分约束都是从答案出发，看要求的是什么，来判断是用最短路和最长路，以此来建边**==
> - 起点的选择是会影响答案的
>
> 1. n是否为超级源点
>
>    是超级源点能够遍历到所有边（点）
>
>    **如果是超级源点一定能判断出环**，（==但是还是要看从超级源点出发求的什么==）
>
> 2. **一定是从超级源点开始吗？**
>
>    **不行，起点会影响答案**（要看求的是什么）

> 问1：是否满足所有条件？
>
> > 要遍历到所有边（点），要就是可以从超级源点出发
> >
> > 隐含条件中，`n`能到所有点=>`n`出发的`spfa`
>
> 问2： $1$到$n$是否任意大？
>
> > 如果没有任意大等价于$d_1-d_n \le C$
> >
> > 然后这里看你用的是最长路还是最短路，**起点和建边都是有影响的**

> [AcWing 1170. 排队布局 - AcWing](https://www.acwing.com/activity/content/code/content/153492/):下面有个评论回答了我的问题

## 最近公共祖先(LCA)

> 最近公共祖先简称 LCA（Lowest Common Ancestor）。

公共祖先：当前结点，是这些的结点的祖先

最近公共祖先：在x和y的所有公共祖先中，深度最大的称为最近公共祖先，记为$LCA(x,y)$



例如这个图：

```
         o
        / \
       .   o			lca(x,y)
      / \
     o   .				y
    / \	
   .   o				x
```

方法1：向上标记法（暴力）

> 每次查询：时间复杂度O(n)

```
方法1 向上标记法 O(n)
          o
        ↗ \
       .    o
     ↗ \
     o   .
   ↗ \   2
  .   o
  1
步骤
1 先从点1往上走到根节点,走过的点都标记
2 再从点2往上走,碰到的第一个带标记的点就是最近公共祖先
```

### 倍增法:

时间复杂度：预处理$O(nlog_2^n)$  每次查询$O(log_2^n)$

> 图形化解释：[【manim | 算法】7分钟学会倍增法求解LCA_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1N7411G7JD/?spm_id_from=333.337.search-card.all.click&vd_source=79043f2a8efe4672df69e4818fe876b8)
>
> 懒得写笔记了，大部分分析来自这份题解:[AcWing 1172. 祖孙询问(树上倍增LCA) - AcWing](https://www.acwing.com/solution/content/20554/)
>
> (想看过程，这两个都能看)


```java
//最近公共祖先LCA（树上倍增做法）
/**
 * 预处理：depth[i]:当前点i的深度
 * 		  fa[i][j]:当前点i，向上走2^j步，所到达的节点
 * 		（用的是bfs算法，dfs可能会爆栈）
 * 
 * 步骤：（都是用倍增法，减少复杂度）
 * 	1. 低的节点走到同一深度
 * 		特判：如果刚好就是高的节点，那么这个点就是最近公共祖先
 * 	2. 同时向上跳，一直到最近公共祖先的下一层停止
 * 分析倍增法：
 * 		（如果这里看后续代码：涉及到二进制的都用了倍增法来凑）
 * 		关键点就是二进制拼凑
 * 			（设置完边界后，每次判断下一个格子，得到就是符合条件的最大值）
 * 		这里为了方便都是从大到小凑，
 * 			=>得到：步骤1：刚好差这么距离的多
 * 				   步骤2：符合条件的最大值
 * 		步骤1：就是凑出这个距离，不断凑出对应的最高位，最后就能凑出距离
 * 
 * 虚拟边界（哨兵）：
 * 		设置完之后就能少特判很多情况，自动就不符合
 * 		对于第0层或着超出的位置，值都为0
 */
import java.util.*;
import java.io.*;
public class Main{
	static final int N=(int)4e4+10,M=N<<1;//N对应点，M对应边
	//点比较少，所以直接用数组下表表示点了
	//邻接表
	static int idx;//边分配器
	static int[] h=new int[N],e=new int [M],ne=new int[M];
		//当前点最后一次出现位置，终点，上一次出现位置
	//注意初始化不能放在后面
	static void init() {
		Arrays.fill(h,-1);
	}
	static void add(int x,int y) {
		ne[idx]=h[x];
		e[idx]=y;
		h[x]=idx++;
	}
	
	//最近公共祖先
	static int H;//最大深度
		//涉及到二进制的地方都能优化下int(log2(点数))
		//直接15也行，更方便点
	static int[] depth=new int[N];
	static int[][] fa=new int[N][16];
			//2^15<4e4<2^16之间，后续都不需要超过这个点，因此15够用了
			//那些值为0，边界
	//1.初始化+预处理:bfs版
	static int[] q=new int[N];
	static void bfs(int root) {//其实就是bfs
		//bfs（更具普遍的模板，能松动就接着搜）
		Arrays.fill(depth,N);//初始较大话，这里其实感觉用st数组也没差
			//不要就是用来标重
		depth[0]=0;depth[root]=1;
		int hh=0,tt=-1;
		//数组模拟版
		q[++tt]=root;
		while(hh<=tt) {
			int t=q[hh++];
			for(int i=h[t];i!=-1;i=ne[i]) {
				int x=e[i];
				if(depth[x]>depth[t]+1) {//没走过（或者能被更新）
					depth[x]=depth[t]+1;
					q[++tt]=x;//别忘记入队了
					
					//同时处理fa，倍增基本上就是这样的，本质是dp
					fa[x][0]=t;
					for(int j=1;j<=H;++j)
						fa[x][j]=fa[fa[x][j-1]][j-1];
				}
			}
		}
	}
	/**
	 * 求节点a,b的最近公共祖先
	 * @param a
	 * @param b
	 * @return 返回祖先结点
	 * 说明：a开始时深度深
	 */
	static int lca(int a,int b) {
		//1.到同一层
		if(depth[a]<depth[b]) {//让a较深，统一处理
			int t=a;
			a=b;
			b=t;
		}
		for(int j=H;j>=0;--j) 
			if(depth[fa[a][j]]>=depth[b])//0会自动跳过
				a=fa[a][j];//二进制拼凑，自动拼出这个距离
		if(a==b)
			return b;
		//2.一起向上走，找最近公共祖先的下一层
		for(int j=H;j>=0;--j) 
			if(fa[a][j]!=fa[b][j]) {//因为从同一层开始跳，0会自动跳过
				a=fa[a][j];
				b=fa[b][j];
			}
			//注意要下个才是最近公共祖先
		return fa[a][0];
	}
	
	public static void main(String[] args) throws Exception{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		H=(int)(Math.log(n)/Math.log(2));//算出最多能走几步
		int root=0;
		init();
		
		for(int i=0;i<n;++i) {
			int a=sc.nextInt(), b=sc.nextInt();
			if(b==-1) 
				root=a;
			else {//无向边是特殊的无向边
				add(a,b);
				add(b,a);
			}
		}
		bfs(root);
		int m=sc.nextInt();
		while(m-- >0) {
			int x=sc.nextInt(),y=sc.nextInt();
			int t=lca(x,y);

			if(t==x)
				System.out.println(1);
			else if(t==y)
				System.out.println(2);
			else 
				System.out.println(0);
		}
	}
}
```

> **bug**:注意就是哪个虚拟边界的处理，0表示边界
>
> ​		**同时规定0在第0层，根节点在第1层**
>
> ​		

### tarjan离线求（dfs+并查集）:

时间复杂度：$O(点数+查询次数)$

[1171. 距离 - AcWing题库](https://www.acwing.com/problem/content/description/1173/)

给出$n$个点的一棵树，多次询问两点之间的最短距离。

注意：

-   边是**无向**的。
-   所有节点的编号是 $1,2,…,n$。

数据范围：$2 \le 点数 \le 10^4$,$1 \le 边数 \le 2 \times 10^4$,$0 < 询问次数 \le 100$,$1 \le x,y \le n$

----



思路配和着下面的题解看：

![tarjan离线求最近公共祖先.jpg](https://cdn.acwing.com/media/article/image/2024/03/23/246003_52df56f9e9-tarjan离线求最近公共祖先.jpg) 

> 这里求深度，可以合并到tarjan算法中

```java
//tarjan离线求lca
	//时间复杂度O(n+m)
	//主要的麻烦点还是离线处理，需要将所有的查询存下来
/**
 * （这里直接文字挺难描述的，需要配合图）
 * 本质上也是对【向上标记法的优化】
 * 算法：dfs+并查集
 * 将树上的点分为三种状态：
 * 		1.搜过且查询过
 * 		2.正在搜的分支
 * 		3.还未搜到的分支
 * 
 * 如何求：
 * 	当点y处在状态1，并且点x处在状态2分支上
 * 	那么这个公共祖先就在x所处的路径上：
 * 		这时就是点y相关的集合对应的根（会在x对应的这条路径上）
 * 		这个根就是最近公共祖先
 * 
 * 本题是利用最近公共祖先求树的最短距离：
 * 		d[x-y]=d[root-x]+d[root-y]-2*d[root-LCA(x,y)]
 * 所以还需要算一下深度
 * 
 * 这里随便取个根节点就行了
 * 		
 */
import java.util.*;
//离线做法需要存下查询，这里还没写完，看后面
	//y总用的vector表(刚好能对应)，这里用map表来
class Query{
	int y,id;
	public Query(int y, int id) {
		super();
		this.y = y;
		this.id = id;
	}
}
public class Main{
	static int N=(int)1e4+10,M=N<<1;
	static int n,m;
	//存下查询和对应的答案
	static int[] res=new int[M];
	static Map<Integer,List<Query>> q=new HashMap<>();
	/**
	 * 对参数的详细解释：
	 * 		res[id]：表示第id次查询的答案
	 * 		每次查询会分配一个id，表示当前是第id次查询，方便存入对应的答案下标中
	 * 		q这个字典表：
	 * 			key：对应的x这个结点
	 * 			value：对应跟x相关的查询操作
	 * 				其中的一个结点Query：
	 * 					y：x对应的另一个结点
	 * 					id:对应第id次查询
	 * 说明：由于不知道先后次序，所以<x,y>和<y,x>都是需要存的
	 * 		到时候只会标记用到的
	 * 特判：x==y时，不需要，虽然去查了也会是0
	 */
	
	//邻接表
	static int idx;
	static int[] h=new int[N],e=new int[M],w=new int[M],ne=new int[M];
		//无向边需要存下两个方向
	static void add(int x,int y,int z) {
		ne[idx]=h[x];
		e[idx]=y;
		w[idx]=z;
		h[x]=idx++;
	}
	
	/**(这里有点特)
	 * dfs求根到所有点的距离
	 * @param u:当前搜索结点
	 * @param fa:父节点
	 * 说明：树用st数组也行，
	 * 		但是这里是树，所以采用这样的遍历方式
	 * 		就是父节点走过了，就不在走了
	 */
	static int[] dist=new int[N];
	static void dfs(int u,int fa) {
		for(int i=h[u];i!=-1;i=ne[i]) {
			int v=e[i];
			if(v==fa) continue;
			
			dist[v]=dist[u]+w[i];
			dfs(v,u);
		}
	}
	
	//并查集
	static int[] p=new int [N];
	static void init() {//带上前面的邻接表一块初始话
		Arrays.fill(h,-1);
		for(int i=1;i<=n;++i)
			p[i]=i;
	}
	//找集合的祖宗
	static int find(int x) {
		if(p[x]!=x) {
			p[x]=find(p[x]);//找父亲
		}
		return p[x];
	}
	
	/**
	 * 求最近公共祖先
	 * @param u：当前要搜的结点
	 */
	static int[] st=new int[N];//对应结点的三种状态
		//0：没搜；1：正在搜；2：已搜完(且查询完)
			//正在搜这个状态主要是用来标重
	static void tarjan(int u) {
		st[u]=1;
		for(int i=h[u];i!=-1;i=ne[i]) {
			int v=e[i];
			if(st[v]==1) continue;
			tarjan(v);
			p[v]=u;//认u为新的祖宗
		}
		//查看所有关于u的查询
		if(q.containsKey(u)) {
			for(Query item:q.get(u)) {
				int y=item.y,id=item.id;
				if(st[y]==2) {
					res[id]=dist[y]+dist[u]-2*dist[find(y)];//这个距离公式要记住
				}
			}
		}
		st[u]=2;//记得标记
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		
		n=sc.nextInt();
		m=sc.nextInt();
		init();//初始话函数的位置
		for(int i=1;i<n;++i) {
			int x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();
			//两个方向
			add(x,y,z);
			add(y,x,z);
		}
		for(int i=0;i<m;++i) {
			int x=sc.nextInt(),y=sc.nextInt();
			//不能确定先找到的顺序
			if(!q.containsKey(x)) //这里不同于c++注意喽
				q.put(x,new ArrayList<>());
			q.get(x).add(new Query(y,i));
			if(!q.containsKey(y))
				q.put(y,new ArrayList<>());
			q.get(y).add(new Query(x,i));
		}
		
		//随便将1作为根节点
		dfs(1,-1);
		tarjan(1);
		//输出答案
		for(int i=0;i<m;++i) {
			System.out.println(res[i]);
		}
	}
}
```

#### 倍增做法：

```java
//倍增法求LCA
/**
 * 预处理：
 * 		fa[i,j]:结点i向上走2^j步对应的结点
 * 		depth[i]:当前结点深度
 * 步骤：
 * 		1.深度底的走到同一层
 * 		2.一起向上走，直到走到LCA(x,y)的下一层
 * 边界问题：当结点0，表示虚拟边界
 * 			有许多好处，自动退出循环
 * 
 * 本题还需要询问两点中的最短距离：
 * 		还需要一个dist数组，求每个点到根节点的距离
 * 		由于是树，相当特殊，因此能用公共祖先求
 * 		
 */
import java.util.*;
public class Main{
	static int N=(int)1e4+10,M=N<<1;
	static int n,m;
	
	//邻接表
	static int idx;
	static int[] h=new int[N],e=new int[M],w=new int[M],ne=new int[M];
		//无向边需要存下两个方向
	static void add(int x,int y,int z) {
		ne[idx]=h[x];
		e[idx]=y;
		w[idx]=z;
		h[x]=idx++;
	}
	
	static int[] depth=new int[N],dist=new int[N];
		//depth还有个作用就是用来标重
	static int[][] fa=new int[N][15];//log2(1e4)=13点多，只要用到13就够了
	static int H;//最多有多深
	//一起初始话
	static void init() {
		H=(int)(Math.log(n)/Math.log(2));//最多就是用到(int)log2(n)
		Arrays.fill(h,-1);
		Arrays.fill(depth,N);
	}
	//预处理:depth,fa,还有后面需要用到的dist
	static void bfs(int root) {
		Queue<Integer> q=new LinkedList<>();
		q.add(root);
		depth[root]=1;
		depth[0]=0;//这个前往别忘了
		while(!q.isEmpty()) {
			int x=q.remove();
			for(int i=h[x];i!=-1;i=ne[i]) {
				int y=e[i];
				if(depth[y]<=depth[x]+1)//走过了不在走
					continue;
				depth[y]=depth[x]+1;
				dist[y]=dist[x]+w[i];
				q.add(y);
				fa[y][0]=x;
				for(int j=1;j<=H;++j) 
					fa[y][j]=fa[fa[y][j-1]][j-1];
			}
		}
	}
	//最近公共祖先
	static int LCA(int x,int y) {
		if(depth[x]<depth[y]) {
			int t=x;
			x=y;
			y=t;
		}//让比较底的为x
		//1.先走到同一层
		for(int j=H;j>=0;--j) 
			if(depth[fa[x][j]]>=depth[y]) //注意：1.从大到小凑2.走之后比
				x=fa[x][j];//最后就是小于等于的最小值
		
		//特殊情况：已经是LCA了
		if(x==y) return x;
		
		//2.找到最近公共祖先的下一层
		for(int j=H;j>=0;--j) 
			if(fa[x][j]!=fa[y][j]){//刚好就是不等于的下一层
					//因为0这个虚拟边界，越界自动下一个
				x=fa[x][j];
				y=fa[y][j];
			}
		
		return fa[x][0];//在上一层才是最近公共祖先
	}
	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		m=sc.nextInt();
		init();//初始话函数的位置
		for(int i=1;i<n;++i) {
			int x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();
			//两个方向
			add(x,y,z);
			add(y,x,z);
		}
		bfs(1);//随便找个根
		for(int i=0;i<m;++i) {
			int x=sc.nextInt(),y=sc.nextInt();
			int lca=LCA(x,y);
			int d=dist[x]+dist[y]-2*dist[lca];
			System.out.println(d);
		}
	}
}
```

