后缀自动机是一种处理字符串问题的强大工具，它可以在$O(n)$的时间复杂度内构建出一个字符串的所有子串。构建好的后缀自动机有一些有趣的性质，后缀自动机每个节点代表的是当前字符串的一个子字符串集合，这些子字符串拥有一定长度的相同后缀。

对于这个问题，我们的目标是找出有多少个不同的子字符串，满足出现在整个符文串中所有位置的右端点异或值与X相同。所以我们需要对后缀自动机做一些额外的处理。

在构建后缀自动机的过程中，我们记录下每个状态所对应的子串的结束位置。当我们插入一个新的字符时，我们会创建新的状态，同时更新新状态的结束位置。

在构建完后缀自动机之后，我们需要计算出每个状态所对应的子串的所有出现位置的右端点的异或值。为了高效地计算这个值，我们可以按照状态的最大长度从大往小遍历所有状态，不断更新它的$Endpos$树上的父亲所在状态。这样对于每一个状态，它的右端点的异或值等于它的所有子状态的右端点的异或值异或上它自己的右端点。因为字符串总长度小于$200000$，所以异或值小于$262144$，我们可以利用一个数组来存储不同异或值的子串出现次数。

在计算出所有的异或值之后，我们就可以对每个查询进行处理了。对于每个查询，我们首先通过倍增的方法找到对应的后缀自动机的状态，然后得到这个状态的右端点的异或值，直接输出异或值对应的不同子串出现次数。

这个解法的时间复杂度是$O(n+m*log(n))$，其中$n$是字符串的长度。因为后缀自动机的大小是线性的，所以我们可以在$O(n)$的时间内构建出后缀自动机，并计算出所有的异或值。对于每个查询，我们通过倍增算法在$log(n)$的时间复杂度内处理，所以总的时间复杂度是$O(n+m*log(n))$。

这个解法的空间复杂度是$O(n)$，这是因为我们需要存储后缀自动机和每个状态的结束位置和异或值。
