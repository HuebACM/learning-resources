《深，基》贪心
（先去写写再来看）

这里总结一下：

贪心就是用局部最优解来推整体最优。
写贪心时务必必须肯定要将例子的所有情况列全，最好为四个以上。

第一部分：（一般的贪心）
是否能用贪心？
（书上是说是具有无后效性，但我感觉太过理论了，不是说理论不好，而是它不利于我们做题时的判断）
（书上说的第一种方法我感觉是有问题的）
法1：举反例（列好例子）
法2：数学归纳法（直接从本质出发，得到式子，或是找出当前最优会一直延续到最后）
法3（不是书上的）：这里着重介绍均等假设法，根据贪心策略，假设两个不一样，但是策略面前优先级相同的选择，看选择是否会对结果产生影响，不会则可行
资料来源（去看一下吧，人家讲得很好）：
https://cloud.tencent.com/developer/article/2083415
例：
1.以  书上P164例12-1  为例：
数据：m1=1,v1=6;m2=100,v2=600.    这时性价比都是一样的，优先级一样，对结果没影响，可用。
2.P166变题后：    同样的数据就对结果有影响了
3.P166例12-2   要排序，根据贪心策略，同样的数只能是相等，可行


第二部分（哈夫曼编码，又称最优前缀码，这里有点涉及数据结构）：

务必嘚先搞明白  p170例15-5合并果子  这题是基础。（可以先不用数据结构，但必须把方法学走）
简单讲：两个最小的堆合成新的一堆

然后p169例12-4 分卷子  和p172 例12-6 哈夫曼编码的制定  都是上面那题的逆向思维。

哈夫曼编码的制定（1.出现频率高的短2.前缀不能相同，会有歧义）  能力不太够，其实我也说不清为什么要这么做，sorry了。但嘚学会方法。
我只能根据答案给你解释一下（太菜了，没办法）：就是说这颗树能保证出现出现频率相同的路径长度（到根节点，就是那些字母）相同，频率高的长度段短。它能够保证最后的根节点的前缀不同，那些前面的根节点已经和后面不同了，已经分叉了（理解一下吧，讲得不清楚）


最后我抽象一下：
前提1.分两堆  需要贪心2.大的个体需要尽早分离
都可以试试往这上靠







