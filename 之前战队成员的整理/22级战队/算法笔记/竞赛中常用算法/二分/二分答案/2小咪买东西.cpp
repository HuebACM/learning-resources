//原题：
//https://ac.nowcoder.com/acm/contest/50639/K
//备注：这题没那么好写，而且不好想，可后面再写

    //感觉像二分答案，尝试一下//不太行
    //边界如何去判断
    //感觉关键点：该如何去挑k个，dfs递归函数，将所有组合搞出
    //这马做会超时
    //也可能有贪心
    //感觉又有点数论//不行应该是没有这种性质的
    //感觉变量太多了，需要排列组合，很难压住变量
    //唉，没想出来

    //碎碎念，不管他

     //确实有难度，我没做出来也挺正常的，一定嘚明白具体情况时哪个是变量
    
    //像很多种情况的最大值，一般使用二分答案（假设答案，看能否压住变量）
	//接下来是分析：
    //这题需要将题目的式子变一下
    //（说实话我的时候看题解的时候不是很理解为什么要这么排序
    //为了能让你我看懂，我从结果分析过去，我先不变）
    //二分中非常关键的一个问题是确定是左还是右区间
    //也就是通过  （总价值/总花费）与假设答案  的大小关系来确定的
    //若（总价值/总花费）>=假设答案
    //（这就是向右的情况，想想为什么在这取个等？而不是小于等于？）
    //（我也有点说不清，但你可以想“最大值麻，那肯定需要尽量去往右，等于不就多了种往右的情况”）
    //开始变式：  总价值-总花费*假设答案>=0 
    //也就是说只要存在着>=的情况那，答案还能更大,向右
	//（直接与往原式想，就是等价，理解了就别看这行后面那句）//（唉，理解了半天。呜，就这么想总价值和总花费肯定是配套，在这种情况下答案都还能向右，其他的更不用说）
    //最极端的情况：就是（总价值-总花费*假设答案）最大时，此时就能囊括其他，若最大都不大于，其他更不可能（变为最~最大值：二分答案的典型）
    
    //你会发现它竟然压住了变量：（好妙啊{{{(>_<)}}}）
    //因为加减乘是很好拆开的，此时从关注 总体->个体（分别求即可），找出里面的大值即可,不需要从总体去从中去选k个
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e4+10;
int c[maxn]={0},v[maxn]={0};//c是花费，v是价值
int n,k;//写前面免得函数参数写很多，记得复原
bool cmp(int a,int b){//从大小排
    return a>b;
}
bool check(int x){
    int a[maxn];
    for(int i=0;i<n;i++){
        a[i]=v[i]-x*c[i];
    }
    sort(a,a+n,cmp);
    long long com=0;//用来比较边界,这里没注意应该要长整型
    for(int i=0;i<k;i++){
        com+=a[i];
    }
    if(com>=0){
        return 1;
    }
    return 0;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int t;cin>>t;
    while(t--){
        memset(c,0,sizeof(c)); memset(v,0,sizeof(v));
        cin>>n>>k;
        for(int i=0;i<n;i++){
            cin>>c[i]>>v[i];
        }
        //二分答案
        int l=0,r=1e4;//答案区间：l因为向下取整所以能为0，r因为最大为1e4
        while(l<r){//向右模板
            int mid=(l+r+1)>>1;//向上取整
            if(check(mid)){
                l=mid;
            }else{
                r=mid-1;
            }
        }
        cout<<l<<endl;
    }
    return 0;
}