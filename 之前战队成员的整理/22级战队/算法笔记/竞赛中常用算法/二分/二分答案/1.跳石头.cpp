//我做的第一题所以比较详细，后面会略写了


//原题链接：
//https://www.luogu.com.cn/problem/P2678
    //本来想用创建结构体来标记数组中各个元素所对应的大小编号
    //会发现去掉某块后排名改变，且需要判断前后，变量太多，不可行，独立解题失败惹。
    //上面那种其实是想贪心的，但变量太多，需要判断的变量越少越好

    //上面是碎碎念，不用管


    //学成归来，嘻嘻嘻嘻
    //看到关键字最短~的最大值
    //还是嘚使用题解中的 二分查找：从答案中找，为避免超时对所有可能的答案开始二分。最大这里套用向右模板
    //可能解又分为可行解和不行解，可行解明显就是一个区间（所有符合条件的）
    //二分答案主要是找到这个区间，往右的模板会自动的找到可行解中的最优解（就是最大啦）
    //接下来写check函数
    //(
    //需要找移动后的最短跳跃距离，我们能改变的就是 移动多少块
    //显然我们对比的就是这个（用这个来确定边界，左还是右区间）
    //)
    //可能解（可能的最短距离）就是达到这个需要移动多少块（先不用管它等不等，只要用它来确定区间，反正最后会移动）
    //其中可行解就是只需移动m块（一段区间）
    //具体实现：采用模拟跳的过程（这样才能最好的控制变量，不用管前后）
    //跳一步，看下一步，如果小于就移走(别忘了记录)，移走后看下一步，大于跳，小于接着移
    //直到跳的距离大于等于，就跳过去
    
    //ok，基本框架完成，看了这麻多字可能会晕，我表达能力不行，而且这题本来就不好做
#include<bits/stdc++.h>
using namespace std;
int a[50010]={0};
int L,n,m;
bool check(int may){//模拟的是答案，别忘了
    int cnt=0;//记录移了几块
    //开始模拟跳跃过程
    int now=0,i=1;//now为当前步，i为下一步
    while(i<=n){
        if(may>a[i]-a[now]){
            i++;cnt++;//移走
        }else{
            now=i;//跳过去
            i=now+1;
        }
        if(cnt>m){//要移的太多，说明大了，往左
            return 0;break;//小小优化，写后头也行
        }
    }
    return 1;//注意是小于等，我们要那他向右又找
}
int main(){
    //可恶有一个样例点没过，有点问题
    //可恶呀，太傻了我，数组开小
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>L>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    n++;a[n]=L;//千万万别忘了，最后还有一块，呜呜呜呜
    //开始二分
    int l=1,r=L;//可能解的区间
    while(l<r){//向右模板
        int mid=(l+r+1)>>1;//“>>”位运算（稍快），这里相当于除2
        if(check(mid)){
            l=mid;//往右移
        }else{
            r=mid-1;//他们一定是有相邻的趋势，不这么做l!=r;
        }
    }
    cout<<l;
    return 0;
}