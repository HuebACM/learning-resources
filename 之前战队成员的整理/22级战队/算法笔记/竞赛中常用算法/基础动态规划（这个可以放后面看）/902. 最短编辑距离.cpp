/*
状态表示f[i,j]:
    1.集合：所有将a[1~i]变成b[1~j]的操作方式
    2.属性：min(这个需要特别注意一下初始化问题)
状态计算：（最后一个状态，为了能更好的控制变量，我们所有的操作都是对最后一个数操作）
    a[1~i-1] + a[i]    (只对a这个进行操作)
    b[1~j-1] + b[j]
    (当前状态，由于前面已经进行过操做，可以认为前面部分是相等的)
    (现在主要是对a[i]的操作)
    （1）a[i]!=b[j]
        1.删a[i]:也就是将a[1~i-1]变为b[1~j]
            f[i-1,j]+1
        2.插入（变为在a[i]后面增）：发现增加b[j]是最好的（为了变得更相似）
            f[i,j-1]+1
        3.替换（将a[i]改为b[j]是最好的）
            f[i-1,j-1]+1
    （2）当且仅当a[i]==b[j]
        f[i-1][j-1]
初始化：大概模拟一下发现：是从（i-1），（j-1）以及（i-1,j-1）方向运算过来的
        也就是要将第一行和第一列初始化：
            f[i,0]：不断删除i次变为b
            f[0,j]: 不断增加j次变为b
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    string a,b;//注意这步操作，从a[1]开始
    cin>>n>>a;
    a='0'+a;
    cin>>m>>b;
    b='0'+b;

    //初始化
    int f[1010][1010];
    for(int i=0;i<=n;i++){
        f[i][0]=i;
    }
    for(int j=0;j<=m;j++){
        f[0][j]=j;
    }

    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=min(f[i-1][j],f[i][j-1])+1;
            if(a[i]==b[j]){
                f[i][j]=min(f[i][j],f[i-1][j-1]);
            }else{
                f[i][j]=min(f[i][j],f[i-1][j-1]+1);
            }
        }
    }

    cout<<f[n][m];
    return 0;
}
