//原题：https://www.luogu.com.cn/problem/P1149



//24数据较小，基本能确定是枚举
//我一开始想的枚举，是想举出总数为n的所有可能
//但在组成数上难以解决（变量太多），失败惹
//1.
//怎么去控制住A B C的根数是一个大问题
//想想每个数的根数是确定的，可以去利用这个找到点突破口（我也没想到呀）
//确实也控制住了点变量，且不用去想数字的各种组合
//同时用存下标记法记录，方便下一步调用，和进行加减运算
//（还有个很重要的问题要解决：就是最大的数该取多大的）
//{（说实话真不好准确估计，组成时明显就是1或7，越多越好，7很难控制 选1更好）
//（111+0=111，此时根数为18，1111+0=1111，此时根数为22）
//也就是说很大的概率是在1111以下很多，感觉在900以下,大概取它711）}
//2.如何选ABC
//当然是一个一个选最好（当然遍历问题也不大）
//感觉此处还是优化会好点，不行就迷途知返

//唉，原本想记录A,B颠倒情况，不太行，会有一个值对应多个值的情况

#include<iostream>
using namespace std;
int n;
int a[1500]= {6,2,5,5,4,5,6,3,7,6}; //0-9所对应的根数
bool b[1010];//用来记录B用过吗
int ans=0;
int main() {
	cin>>n;
	n-=4;//减掉符号
	for(int i=10; i<=1500; i++) {
		a[i]=a[i%10]+a[i/10];//小小优化，百位也没关系，取余是个位，除是百位和十位
	}
	for(int i=0; i<=711; i++) {
		int ji=n-a[i];
		if(i!=0&&ji<4){
			continue;
		}
		for(int j=0;j<=711;j++){
			if(ji-a[j]<2){
				continue;
			}
			if(a[i]+a[j]+a[i+j]==n){
				ans++;
			}
		}
	}
	cout<<ans;

	return 0;
}