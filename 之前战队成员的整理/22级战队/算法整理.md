# 基础算法
## 快速排序(第k个数) 
```c++
//nth_element  但需要注意这个函数写的顺序比较特殊

//快排：就是以一个数为标兵，去不断分为两个区间
#include<bits/stdc++.h>
using namespace std;
//采用以第一个数为标兵
const int maxn=1e5+10;
int a[maxn];
int quick_sort(int l,int r,int k)
{
    if(l>=r)
    {
        return a[k];
    }
    int i=l-1,j=r+1,x=a[(l+r)>>1];
    while(i<j)
    {
        //左找大于等于
        do i++; while(a[i]<x);
        
        do j--; while(a[j]>x);
        if(i<j)
        {
            swap(a[i],a[j]);    
        }
    }
    if(j>=k)quick_sort(l,j,k);    
    else quick_sort(j+1,r,k);
}
int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    // cout<<quick_sort(0,n-1,k-1);
    
    nth_element(a,a+k-1,a+n);//这个函数书写顺序比较特殊
    //      将编号为k-1的复位
    cout<<a[k-1];
    return 0;
}
```
## 归并排序（求逆序对）
```c++
/*
归并排序：  
    主要思想：将两个有序的数列归并成一个

根据性质：
    i<j,只需找a[i]>a[j]

当两区间归并，i<j一定满足，因为这两区间是有序的，
很好统计左右两区间的逆序对
恰为：mid-i+1

（这里说实话，我不知道是否一定不重不漏）
不断循环这个过程，就是不断求左右区间的逆序对
*/
//需要算一下是否需要long long
#include<bits/stdc++.h>
using namespace std;
int n;
const int N=1e5+10;
int a[N];
typedef long long ll;
ll cnt;
void merge_sort(int l,int r){
    if(l>=r){
        return;
    }
    int mid=(l+r)>>1;
    //变得有序
    merge_sort(l,mid),merge_sort(mid+1,r);
    //归并过程
    int i=l,j=mid+1;
    int tmp[N],k=0;
    //小的放前
    while(i<=mid&&j<=r){
        if(a[j]<a[i]){
            //逆序对情况
            tmp[k++]=a[j++];
            cnt+=mid-i+1;
        }else{htt
            tmp[k++]=a[i++];
        }
    }
    //扫尾
    while(i<=mid){
        tmp[k++]=a[i++];
    }
    while(j<=r){
        tmp[k++]=a[j++];
    }
    //赋回
    for(i=l,k=0;i<=r;i++,k++){
        a[i]=tmp[k];
    }
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    merge_sort(0,n-1);
    cout<<cnt;
    
    return 0;
}
```
## 二分
![2.3.二分1.jpg](https://cdn.acwing.com/media/article/image/2023/04/11/246003_c33553f3d8-2.3.二分1.jpg) 
![2.3.二分2.jpg](https://cdn.acwing.com/media/article/image/2023/04/11/246003_cc0ce8e8d8-2.3.二分2.jpg) 
 **stl** 
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
#define endl '\n'
int main(){
    int n,q;
    cin>>n>>q;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    while(q--){
        int x;
        cin>>x;
        int l=lower_bound(a,a+n,x)-a;
        //找出现的第一个位置；若没有找到，找大于的第一个数
        int r=upper_bound(a,a+n,x)-a;
        //找大于的第一数
        if(l==r){
            cout<<"-1 -1"<<endl;
        }else{
            cout<<l<<" "<<r-1<<endl;
        }
    }
    
    return 0;
}
```
**二分模板**
```c++
/*
写二分的时候推荐按区间画一下图：
    （方便判断边界和取等问题）
    按两个判断区间分，要找的东西都在中间，
    左区间找右边（向右模板），右区间找找左边
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
#define endl '\n'

int main(){
    int n,q;
    cin>>n>>q;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    while(q--){
        int x;
        cin>>x;
        //左右模板都是要用的
        
        //先向左
        //这题其实都不用管边界问题
        int l=0,r=n-1;
        while(l<r){
            int mid=(l+r)>>1;//向下取整对应向左
            if(a[mid]>=x){
                r=mid;//区间向左缩
            }else{
                l=mid+1;//保证能重合且最好是在自己画的图的右区
            }
        }
        if(a[l]!=x){
            cout<<"-1 -1"<<endl;
        }else{
            cout<<l<<" ";
            r=n-1;
            //向右模板
            while(l<r){
                int mid=(l+r+1)>>1;//向上取整
                if(a[mid]<=x){
                    l=mid;
                }else{
                    r=mid-1;//保证重合
                }
            }
            cout<<r<<endl;
        }
    }
    
    return 0;
}
```
##  高精加和高精乘 
 **结构体封装** 
```c++
//这些都要特别注意一下0
#include<bits/stdc++.h>
using namespace std;
struct bigint{
    int a[200020];
    int len=0;
    /*
    bigint(int a){
        while(a){
            a[len++]=a%10;
            a/=10;
        }
        len--;
    }
    */
    bigint(string s){
        //注意最高为在前
        len=s.size()-1;
        for(int i=len,j=0;i>=0;i--,j++){
            a[i]=s[j]-'0';
        }
    }
    bigint(){}
    int &operator[](const int i){
        //简写，用bigint b;b.a[i]等价于b[i]
        //但一定要注意&
        return a[i];
    }
    void flat(int l){
        len=l;
        for(int i=0;i<=l;i++){
            a[i+1]+=a[i]/10;
            //注意是加等于，别跟犯一个错误，呜呜呜
            a[i]%=10;
        }
        while(a[len]==0){
            len--;
        }
    }
    void print(){
        for(int i=len;i>=0;i--){
            cout<<a[i];
        }
    }
};
//高精加
bigint operator+(bigint a,bigint b){
    bigint c;
    int l=max(a.len,b.len)+2;
    for(int i=0;i<=l;i++){
        c[i]=a[i]+b[i];
    }
    c.flat(l);
    return c;   
}
//高精乘
bigint operator*(bigint a,bigint b){
    bigint c;
    int l=a.len+b.len+3;
    for(int i=0;i<=a.len;i++){
        for(int j=0;j<=b.len;j++){
            c[i+j]+=a[i]*b[j];
        }
    }
    c.flat(l);
    return c;
}
int main(){
    string x,y;
    cin>>x>>y;
    bigint a(x),b(y);
    bigint c;
    c=a*b;
    c.print();    
    return 0;
}
```
**vector版**
```c++
#include<iostream>
#include<vector>
#include<bits/stdc++.h>
using namespace std;
void chushi(vector<int> &a,string &s){
    //需要个位放第一位最好
    //若从末尾开始存，很难加数
    for(int i=s.size()-1;i>=0;i--){
        a.push_back(s[i]-'0');
    }
}
vector<int> operator+(vector<int> &a,vector<int> &b){
    int t=0;//这个需要注意，用来记录进位
    vector<int> c;
    for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size()){
            t+=a[i];
        }
        if(i<b.size()){
            t+=b[i];
        }
        c.push_back(t%10);
        t/=10;
    }
    if(t){
        c.push_back(t);
    }
    return c;
}
int main(){
    
    string a,b;
    cin>>a>>b;
    vector<int> A,B;
    chushi(A,a);
    chushi(B,b);
    vector<int> C;
    C=A+B;
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    
    
    return 0;
}
```
## 高精减
```c++
//两整数相减
//为了方便计算，都转化为绝对值相减，符号进行特判
#include<iostream>
#include<vector>
using namespace std;

//判断正负，并保证是大数减小数(一定为正，后面在填符号)
bool cmp(string a,string b){
    int la=a.size(),lb=b.size();
    if(la!=lb){
        return la>lb;
    }else{
        return a>=b;//注意这里要有等号，相等时不为负数
    }
}

vector<int> operator-(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;//处理借位和减法
    for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size()){
            t+=a[i];
        }
        if(i<b.size()){
            t-=b[i];
        }
        c.push_back((t+10)%10);
        if(t<0){
            t=-1;//借位
        }else{
            t=0;
        }
    }
    while(c.back()==0&&c.size()!=1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a,b;
    cin>>a>>b;
    //为了方便计算，保证a>b
    bool fu=0;//符号的判定
    if(!cmp(a,b)){
        swap(a,b);
        fu=1;
    }
 
    vector<int> A,B;
    //初始化
    for(int i=a.size()-1;i>=0;i--){
        A.push_back(a[i]-'0');
    }
    for(int i=b.size()-1;i>=0;i--){
        B.push_back(b[i]-'0');
    }
    
    vector<int> C=A-B;
    
    if(fu){
        cout<<"-";
    }
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    
    return 0;
}
```
## 高精乘
```c++
//可能出现0*n,还是需要除前导0
#include<bits/stdc++.h>
using namespace std;
#define VI vector<int> //简写
VI operator*(VI &a,int b){
    VI c;
    int t=0;//处理乘法和进位
    for(int i=0;i<a.size();i++){
        t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    while(t){
        //也可写在for那边
        c.push_back(t%10);
        t/=10;
    }
    while(c.back()==0&&c.size()!=1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a;
    int B;
    cin>>a>>B;
    //初始化
    VI A;
    for(int i=a.size()-1;i>=0;i--){
        A.push_back(a[i]-'0');
    }
    auto C=A*B;//自动判断类型
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }  
    return 0;
}
```
## 高精除
```c++
/*
模拟一下除法，
会发现除法是从最高位开始，从最高位开始存确实会方便一点
但为了保证加减乘除的一致性，还是从最低位开始存

还需要除前导0
*/
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
#define VI vector<int>
//高精除
int r;//用来存余数
VI operator/(VI &a,int b){
    VI c;
    for(int i=a.size()-1;i>=0;i--){
        //会发现高位在前
        r=r*10+a[i];
        c.push_back(r/b);
        r%=b;
    }
    //翻转(保证从个位开始存，同时方便除0)
    reverse(c.begin(),c.end());
    while(c.back()==0&&c.size()>1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a;
    int B;
    cin>>a>>B;
    //初始化
    VI A;
    for(int i=a.size()-1;i>=0;i--){
        A.push_back(a[i]-'0');
    }
    VI C=A/B;
    //输出
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    cout<<endl<<r;
    return 0;
}
```
## 前缀和
![8.前缀和.jpg](https://cdn.acwing.com/media/article/image/2023/04/14/246003_232684f4da-8.前缀和.jpg) 
### 像这种最好都画画图
**一维**
```c++
//呜呜，一定要有判断是否需要开高精度的思想
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int sum[N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        //这种一般都是从1开始记录
        cin>>sum[i];
        sum[i]+=sum[i-1];
    }
    while(m--){
        int l,r;
        cin>>l>>r;
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;
}
```
----------
 **二维**
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
//不会爆int
int s[N][N];
int main(){
    int n,m,q;
    cin>>n>>m>>q;
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>s[i][j];
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    
    while(q--){
        int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        cout<<s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<<endl;
    }
    return 0;
}
```
## 差分
![9.差分1.jpg](https://cdn.acwing.com/media/article/image/2023/04/14/246003_88d21d26da-9.差分1.jpg) 
![9.差分2.jpg](https://cdn.acwing.com/media/article/image/2023/04/14/246003_8b6e5c7eda-9.差分2.jpg) 
**一维** 
```c++
//当然，y总那种更具有普遍性，有利于理解二维的
//差分数组在某个位置上加，相当于后面每个数都加
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
//可能会越界
typedef long long ll;
ll b[N];
int a[N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i]-a[i-1];//注意一下
    }
    while(m--){
        int l,r,c;
        cin>>l>>r>>c;
        b[l]+=c;
        b[r+1]-=c;
    }
    for(int i=1;i<=n;i++){
        b[i]+=b[i-1];
        cout<<b[i]<<" ";
    }
    return 0;
}
```
----------
 **二维**

```c++
 /*
先将数组想象为空，
插入（加）一个数就是将后面所有的数都加上这个数
也就是说，后面你需要消除这种变化
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int b[N][N];
//插入操作，想想可以添加数等价
void insert(int x1,int y1,int x2,int y2,int c){
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}
int main(){
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int c;
            cin>>c;
            insert(i,j,i,j,c);
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
    //求前缀和，就是原值
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            cout<<b[i][j]<<" ";
        }
        cout<<endl;
    } 
    return 0;
}
```
## 双指针
 **最长连续不重复子序列** 
```c++
/*
可恶，其实我题意疯狂理解错，
这里的连续不是1，2，3，4，的子序列
而是指在按原来的序列连续的不重复的串(是连在一块的)
例：
1 2 {2 3 5}
9 {3 6 9 5 10 1 2} 3 9
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N],cnt[N];//a用来记录原数组，cnt用来记录[j,i]个数的出现个数
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    int ans=1;
    for(int i=0,j=0;i<n;i++){
        //这里的i是右指针，j表示左指针
        cnt[a[i]]++;
        while(cnt[a[i]]>1){//判断是否重复
            //这里其实有个隐含条件：i>=j
            //因为区间只有一个数时，此时（i==j）一定满足不重复
            cnt[a[j]]--;//呜呜，注意一下这里(顺序和j)别写错了
            j++;
        }
        ans=max(ans,i-j+1);
    }
    cout<<ans<<endl;
    return 0;
}
```
 **数组元素的目标和** 
```
题：
给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。
数组下标从 0 开始。
请你求出满足 A[i]+B[j]=x 的数对 (i,j)。
数据保证有唯一解。
```

```c++
//哈哈，如果是以前的我可能会用二分函数暴力找
//不过我偏不，想试试双指针
/*
经过模拟发现
指针i指向第一个序列的左（往右）
指针j指向第二个序列的右（往左）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N],b[N];
int main(){
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<m;i++){
        cin>>b[i];
    }
    int i=0,j=m-1;
    for(;i<n;i++){
        while(a[i]+b[j]>x&&j>=0){
            j--;
        }
        if(a[i]+b[j]==x){
            break;
        }
    }
    cout<<i<<" "<<j;
    return 0;
}
```
## 二进制中1的个数
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int a;
        cin>>a;
        //法1 cout<<__builtin_popcount(a)<<" ";
        /*
        法2：
        int cnt=0;
        while(a){
            if(a&1){
                cnt++;
            }
            a>>=1;
        }
        */
        //法3：（lowbit函数）
        int cnt=0;
        while(a){
            //不断减去最末尾的1
            int lowbit=a&-a;
            a-=lowbit;
            cnt++;
        }
        cout<<cnt<<" ";
    }
    return 0;
}
```
## 离散化


```
题：
    求一个无限长的轴的上，某段区间的和
```
![离散1.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_a95ce207f3-离散1.jpg) 
![离散2.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_b561e651f3-离散2.jpg) 
```c++
/*
离散化：（我感觉更像是连续化doge）
    将原来稀疏的区间化为连续区间

本题是一段无限长的x轴，其中分布的点很分散，
这时候就可以将所有的点打包成一段区间，并将其中的缝隙去掉，
变成一个新的轴（从1开始，方便便后面的前缀和等操作），点是连续分布的

注意：我们离散的对象是x轴，变成一个新的轴（后面称为a轴了）

例：（将原来的(用到的)绝对坐标转化为了顺序坐标）
    点只分布x=-100,x=-20,x=10,x=60
    离散后a=1(映射x=-100),a=2(x=-20),a=3(10),a=4(60)
    
关键点：1.排序2.去重3.找原坐标所对应的离散化的点
*/
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;//添加操作和查询操作一共的x坐标数量

int arr[N],sum[N];
typedef pair<int,int> pii;
vector<int> alls;//a轴，离散化后的结果，存的是映射到的x坐标
vector<pii> add,query;//添加操作和询问操作

int find(int x){//找原坐标对应的离散后坐标
    //映射的x坐标是有序的，因此可以用二分
    //这里用左用右应该都行
    int l=0,r=alls.size()-1;
    while(l<r){
        int mid=(l+r)>>1;
        if(x<=alls[mid]){
            r=mid;
        }else{
            l=mid+1;
        }
    }
    return l+1;
    //这里要加1，因为vector默认从0开始存
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int x,c;
        cin>>x>>c;
        add.push_back({x,c});
        alls.push_back(x);
    }
    for(int i=0;i<m;i++){
        int l,r;
        cin>>l>>r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //排序
    sort(alls.begin(),alls.end());
    //去重
    alls.erase( unique(alls.begin(),alls.end()) , alls.end());
    //在离散后的坐标中插入值
    for(auto t:add){
        //t表示遍历add中所有的值，相当于alls[i]
        int a=find(t.first);
        arr[a]+=t.second;
    }
    //前缀和
    for(int i=1;i<=alls.size();i++){
        sum[i]+=sum[i-1]+arr[i];
    }
    //询问前缀和
    for(auto t:query){
        int l=find(t.first),r=find(t.second);
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;    
}
```
## 离散化


```
题：
    求一个无限长的轴的上，某段区间的和
```
![离散1.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_a95ce207f3-离散1.jpg) 
![离散2.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_b561e651f3-离散2.jpg) 
```c++
/*
离散化：（我感觉更像是连续化doge）
    将原来稀疏的区间化为连续区间

本题是一段无限长的x轴，其中分布的点很分散，
这时候就可以将所有的点打包成一段区间，并将其中的缝隙去掉，
变成一个新的轴（从1开始，方便便后面的前缀和等操作），点是连续分布的

注意：我们离散的对象是x轴，变成一个新的轴（后面称为a轴了）

例：（将原来的(用到的)绝对坐标转化为了顺序坐标）
    点只分布x=-100,x=-20,x=10,x=60
    离散后a=1(映射x=-100),a=2(x=-20),a=3(10),a=4(60)
    
关键点：1.排序2.去重3.找原坐标所对应的离散化的点
*/
#include<bits/stdc++.h>
using namespace std;

const int N=3e5+10;//添加操作和查询操作一共的x坐标数量

int arr[N],sum[N];
typedef pair<int,int> pii;
vector<int> alls;//a轴，离散化后的结果，存的是映射到的x坐标
vector<pii> add,query;//添加操作和询问操作

int find(int x){//找原坐标对应的离散后坐标

    //映射的x坐标是有序的，因此可以用二分
    //这里用左用右应该都行
    int l=0,r=alls.size()-1;
    while(l<r){
        int mid=(l+r)>>1;
        if(x<=alls[mid]){
            r=mid;
        }else{
            l=mid+1;
        }
    }
    
    return l+1;
    //这里要加1，因为vector默认从0开始存
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int x,c;
        cin>>x>>c;
        add.push_back({x,c});
        alls.push_back(x);
    }
    for(int i=0;i<m;i++){
        int l,r;
        cin>>l>>r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    //排序
    sort(alls.begin(),alls.end());
    //去重
    alls.erase( unique(alls.begin(),alls.end()) , alls.end());
    
    //在离散后的坐标中插入值
    for(auto t:add){
        //t表示遍历add中所有的值，相当于alls[i]
        int a=find(t.first);
        arr[a]+=t.second;
    }
    
    //前缀和
    for(int i=1;i<=alls.size();i++){
        sum[i]+=sum[i-1]+arr[i];
    }
    //询问前缀和
    for(auto t:query){
        int l=find(t.first),r=find(t.second);
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;
    
}
```
## 单链表
![单链表.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_ad4deb01f3-单链表.jpg) 
```c++
/*
单链表：(数组版)
    (每一个下标就表示一个节点)
    开始时指向-1，表示链表的最后一个元素
    头指针head，指向第一个元素，可以理解为这个链表的标志（名字之类）
    idx表示但前用到哪个元素（正要用但没开始）
    （然后我们一般是从0开始存）
    e[i]用来存节点i的值
    ne[i]表示节点i的下一个节点编号(指向)

（指向操作用head，ne[]完成）
头指针指向第一个节点，后面的元素指向下一个元素，最后的元素指向-1
(存值用e[i]来操作)
*/
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
//单链表
//初始
int head=-1,idx=0;//开始时head指向-1，这里idx指向1会更好一点
int e[N],ne[N];
//各种操作
//链表头插入
void add_to_head(int x){
    e[idx]=x;ne[idx]=head;head=idx++;
}
//在第k个后面插入x
void add(int k,int x){
    e[idx]=x;ne[idx]=ne[k];ne[k]=idx++;
}
//删除第k个数后面的数（从0开始），但题目是从1开始也就是说后面要-1
void remove(int k){
    if(k==-1){
        head=ne[head];
    }else{
        ne[k]=ne[ne[k]];//直接连下一个
    }
}

int main(){
    int n;
    cin>>n;
    while(n--){
        char c;
        cin>>c;
        if(c=='H'){
            int x;
            cin>>x;
            add_to_head(x);
        }else if(c=='D'){
            int k;
            cin>>k;
            remove(k-1);
        }else{
            int k,x;
            cin>>k>>x;
            add(k-1,x);
        }
    }
    for(int i=head;i!=-1;i=ne[i]){
        cout<<e[i]<<" ";
    }
    
    return 0;
}
```
## 双链表
![邻接表和双链表.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_d4706c7df3-邻接表和双链表.jpg) 
```c++
/*
双链表：既有前驱又有后继
        （单链表只有后继）
初始化：只有两个点互相连接，
        r[0]=1,l[1]=0,idx=2;
        （0号点和1号点分别代表左右端点，注意真正的第一个点是从2开始的）
        (实际中并没左右端点，你可以等价于单链表中-1)
         一定要注意从2开始
删除k号点：1.【右边的左边】等于【左边】
           2.【左边的右边】等于【右边】
在第k号点的右边插入：
        存值
        1.先更新插入点的后继
        2.在更新【k号点的后继】的前驱
        3.更新【k号点的后继】
    （后面的的操作都是用这个修改而来）
*/
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;

int l[N],r[N],idx,e[N];
void init(){
    r[0]=1;//左端点
    l[1]=0;//右端点
    idx=2;
}
void remove(int k){//删除
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
void add(int k,int x){
    e[idx]=x;
    l[idx]=k;r[idx]=r[k];
    l[r[k]]=idx;
    r[k]=idx++;
}
int main(){
    int m;
    cin>>m;
    init();//别忘了
    while(m--){
        string op;
        cin>>op;
        if(op=="L"){
            int x;
            cin>>x;
            add(0,x);
        }else if(op=="R"){
            int x;
            cin>>x;
            add(l[1],x);
        }else if(op=="D"){
            int k;
            cin>>k;//注意是从2开始
            remove(k+1);
        }else if(op=="IL"){
            int k,x;
            cin>>k>>x;
            add(l[k+1],x);//在k的左侧相当于在k前驱的右侧
        }else{
            int k,x;
            cin>>k>>x;
            add(k+1,x);
        }
    }
    for(int i=r[0];i!=1;i=r[i]){//做到右，右端点为1
        cout<<e[i]<<" ";      
    }
    return 0;
}
```
## 栈
**数组模拟版**
```c++
/*
栈就是先进先出
我这里就从1开始了
*/
#include<iostream>
using namespace std;
const int N=1e5+10;
int st[N],tt;//st就是模拟栈，tt是指针，指向栈顶
void push(int x){
    st[++tt]=x;
}
void pop(){
    tt--;
}
bool empty(){
    if(tt){//不是0就表示空
        return 0;
    }else{
        return 1;    
    }
}
int query(){
    return st[tt];
}
int main(){
    int m;
    cin>>m;
    while(m--){
        string op;
        cin>>op;
        if(op=="push"){
            int x;
            cin>>x;
            push(x);
        }else if(op=="query"){
            cout<<query()<<endl;
        }else if(op=="pop"){
            pop();
        }else{
            if(empty()){
                cout<<"YES";
            }else{
                cout<<"NO";
            }
            cout<<endl;
        }
    } 
    return 0;
}
```
**stl版**
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    stack<int> s;
    int m;
    cin>>m;
    while(m--){
        string op;
        cin>>op;
        if(op=="push"){
            int x;
            cin>>x;
            s.push(x);
        }else if(op=="query"){
            cout<<s.top()<<endl;
        }else if(op=="pop"){
            s.pop();
        }else{
            if(s.empty()){
                cout<<"YES";
            }else{
                cout<<"NO";
            }
            cout<<endl;
        }
    }
    return 0;
}
```
### 表达式求值
## 哈希表stl 

```c++
//初始
	unordered_map<char,int> h{{'+',1},{'-',1},{'*',3}};
			   //这里应该是pair类型
//插入
	h.emplace('/',100);
//修改value
	auto it=h.find('/');//找这个值的位置，返回的是指针，若没有返回end指针
	if(it!=h.end()){//当前值是否存在
		it->second=3;//访问当前地址的成员，等价于(*it).second;
//		(*it).second=3;
	}
//访问
	cout<<h['/']<<endl;
//删除，(不过是假删)，但是你用c++11遍历时并不会遍历到
	h.erase('/');


//遍历
	for(auto x:h){
		cout<<x.first<<" "<<x.second<<endl;
	}
	for(auto ite=h.begin();ite!=h.end();ite++){
		cout<<ite->first<<" "<<ite->second<<endl;
	}

```
![表达式求值.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_e2b476ccf3-表达式求值.jpg) 
```c++
/*
哎呀，这题花了好长的时间（但感觉还是挺有必要的）
需要一丁点哈希表的运用（不多，但还是去大概看了看哈希表stl）
（主要用在优先级的判断）
*/
/*
首先我要先忽略掉括号，因为括号比较特殊（能改变优点级）
（后面在看）
{
栈模拟二叉树（感觉这个也是不怎么好懂）：

当只有加减乘除的式子，
    （根据y总的视频）
    就是一个二叉树，叶子节点是数，节点是运算符
    （根节点就是最上面的那个）

    然后发现：1.节点下面都是叶子节点时
                （没有在连其他东西），才能够运算
              2.越往下面的节点优先级更高，
    根据这个特性来判断：
        当前运算符（节点）优先级>=上面节点的优先级，
        这时就能够运算了

    转化栈：
    1.需要两个栈：一个用来存数，一个又来存运算符
    2.判断栈顶优先级是否>=下个运算符，
        是就运算
    3.遇到'('做分隔符存入

加入括号要将括号中的式子全算完，才能够接着运算，
这时我们可以将'('当成分隔符，隔开前面的式子，到')'才能回复原在的运算
}

*/
#include<bits/stdc++.h>
using namespace std;

unordered_map<char,int> pr{{'+',1},{'-',1},{'*',2},{'/',2}};//优先级
stack<int> num;
stack<char> op;
void eval(){//计算
    int b=num.top();num.pop();
    int a=num.top();num.pop();//先进后出，前面在下面
    char c=op.top();op.pop();

    int res;
    if(c=='+'){
        res=a+b;
    }else if(c=='-'){
        res=a-b;
    }else if(c=='*'){
        res=a*b;
    }else{
        res=a/b;
    }

    num.push(res);
}
int main(){

    string s;
    cin>>s;
    for(int i=0;s[i];i++){
        if(isdigit(s[i])){//存数字
            int j=i,t=0;
            while(isdigit(s[j])){
            //判断是否为数字，等价于'0'<=s[j]<='9'
                t=s[j]-'0'+t*10;
                j++;
            }
            i=j-1;//注意要减1
            num.push(t);
        }else if(s[i]=='('){
            //遇到左括号时，做分隔符
            op.push(s[i]);
        }else if(s[i]==')'){
            //就括号中式子全部算完
            while(op.top()!='('){
                eval();
            }
            op.pop();
        }else{
            //下一个符号（节点）,看是否要运算
            /*
            这里为什么要while呢？
                （根据上面的特性，要都只把节点下面的树都遍历完，才能下一个运算）
                （上面这个太抽象，别看了）
                感觉就是为了满足同优先级从左到右算
                (不然后面会出优先级的问题)
                例如：1-2*3+4
                    先算2*3=6，然后发现左边的'+'和右边的'-'优先级相同，
                    所以先将左边的算了,
                    但是如果是if的话6+4会先算，再算1-（6+4）
                    最好结果为-14，显然有问题(习惯上就是左边的先算完在右边麻)
                    （这里仔细看一下）
            */
            while(op.size()&&op.top()!='('&&pr[op.top()]>=pr[s[i]]){\
            //注意，不然后溢出,先判断有没有符号
                eval();
            }
            op.push(s[i]);

        }

    }

    while(!op.empty()){
        eval();
    }
    cout<<num.top();
    return 0;
}
```
## 队列
**数组模拟**
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int q[N],hh,tt=-1;//第一个从1开始
int main(){
    int m;
    cin>>m;
    while(m--){
        string s;
        cin>>s;
        if(s=="push"){
            int x;
            cin>>x;
            q[++tt]=x;
        }else if(s=="empty"){
            if(hh<=tt){
                cout<<"NO\n";
            }else{
                cout<<"YES\n";
            }
        }else if(s=="query"){
            cout<<q[hh]<<endl;
        }else if(s=="pop"){
            hh++;
        }
    } 
    return 0;
}
```
**stl**
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int main(){
    int m;
    cin>>m;
    queue<int> q;
    while(m--){
        string s;
        cin>>s;
        if(s=="push"){
            int x;
            cin>>x;
            q.push(x);
        }else if(s=="empty"){
            if(!q.empty()){
                cout<<"NO\n";
            }else{
                cout<<"YES\n";
            }
        }else if(s=="query"){
            cout<<q.front()<<endl;
        }else if(s=="pop"){
            q.pop();
        }
    }
    return 0;
}
```
## 单调栈
```
题：找左边第一个比他小的数
```
```c++
/*
单调栈：栈内的元素具有严格的单调性

（感觉有点贪心思想）
对于相邻的数：
    1.当a[i-1]>=a[i],
      要找左边最小的数，显然a[i]会比a[i-1]好，放a[i]即可
    2.当a[i-1]<a[i]时，
      a[i]依然可能是左边最小的数
现在拓展到全局：
    当a[x]>=a[y],x<y
    放y显然更好，
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    stack<int> s;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        while(!s.empty()&&s.top()>=x){
            s.pop();
        }
        if(s.empty()){
            cout<<"-1 ";
        }else{
            cout<<s.top()<<" ";
        }
        s.push(x);
    }
    
    return 0;
}
```

## 单调队列
**滑动窗口**
```
题：一个长度为k的滑动的窗口，每次输出窗口的最大最小值
```

```c++
/*
单调队列：满足严格单调性的队列
    （但是稍有不同的是队头和队尾都是要维护的，因此用数组模拟会好点）
    （当然也有deque的库函数，但好像不是很有必要）
    （其实挺像单调栈的，但这里找的是最值）
对于这题的特性：
    当要找窗口最小值时，
    例如窗口的值为【3，-1，-3】
    由于-3在-1的后面，且比-3大，因此不可能最小值
    我们需要将一些冗余点（不可能的点）给去掉，
    因此采用单调队列
    （好处：队头就是最值，复杂度很低）
    维护：1.要加入一个新数时，把比他大的都可以去掉，其成为新的队尾
          2.队头还要看是否在窗口内部（需要下标）

然后这里队列会发现还需要用到下标，用下标表示数会比较方便
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N];
int q[N],hh=0,tt=-1;//数组模拟队列
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<n;i++){
        //队头是否在窗口内
        // cout<<i-k<<" "<<q[hh]<<endl;
        if(hh<=tt&&q[hh]<=i-k){//很多数据结构都是要是否为空的
            hh++;
        }
        //维护队尾
        while(hh<=tt&&a[q[tt]]>a[i]){
            tt--;
        }
        
        q[++tt]=i;//入队
        if(i>=k-1)cout<<a[q[hh]]<<" ";
        // cout<<hh<<" "<<tt<<" "<<a[q[hh]]<<" "<<a[q[tt]]<<endl;
    }
    cout<<endl;
    hh=0,tt=-1;//敲了，别忘了
    for(int i=0;i<n;i++){
        //队头是否在窗口内
        // cout<<i-k<<" "<<q[hh]<<endl;
        if(hh<=tt&&q[hh]<=i-k){//很多数据结构都是要是否为空的
            hh++;
        }
        //维护队尾
        while(hh<=tt&&a[q[tt]]<a[i]){
            tt--;
        }
        
        q[++tt]=i;//入队
        if(i>=k-1)cout<<a[q[hh]]<<" ";
        // cout<<hh<<" "<<tt<<" "<<a[q[hh]]<<" "<<a[q[tt]]<<endl;
    }
    return 0;
}
```
## 字符串匹配kmp
**string自带函数（但是会超时）(暴力)**

```c++
//肯定是要掌握的，平时应该够用了
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    string a,b;
    cin>>n>>a>>m>>b;
    int pos=b.find(a);
    while(pos!=-1){
        cout<<pos<<" ";
        pos=b.find(a,pos+1);
    }
    return 0;
}
```
## kmp算法
*操作图
![图解.jpg](https://cdn.acwing.com/media/article/image/2023/05/04/246003_71c7789dea-图解.jpg) 
《算法竞赛》
![1.jpg](https://cdn.acwing.com/media/article/image/2023/05/04/246003_798ec074ea-1.jpg) 
![2.jpg](https://cdn.acwing.com/media/article/image/2023/05/04/246003_81683328ea-2.jpg) 
![3.jpg](https://cdn.acwing.com/media/article/image/2023/05/04/246003_8bf33780ea-3.jpg) 
```c++
/*
(需要着重强调的暴力是i,j都会回溯，而kmp只需要回溯j)
kmp算法：
（这样描述其实不什么好懂，最好看一下画的那张图）
（移动j的过程，相当于移动P）
（这里模板的匹配窗口是S[i]和P[j+1]进行匹配）(这个一定要牢记)
1.S和P匹配的过程：
    1）S[i]==P[j+1]时
        这时候两个指针都往下走
        就是匹配窗口往下走
    2）S[i]！=P[j+1]
        这时两字符串匹配过的内容是已知的，上下是完全一样，
        这时候只要移动下面的P串进行匹配（前面的结论）
        只需要将最大相等的前缀移动到与后缀这next[j]
2.最大公共前后缀和next数组：（与上面类似，但只要看这个位置）
    （next数组是用来存最大公共前后缀的长度，
        同时是前缀的最后一位的位置）
    这里的对象只有P
    是P[1~i]的前缀和后缀的匹配
    上面的是后缀，而我们移动的是下面的前缀
    （跟上面不同是我们只要看这个窗口的结果就行了）
    现在是普遍的情况，假设这里前面的已经是匹配的了
    1）后缀[i]==前缀[j+1]时
        j++;
        next[i]=j;
    2)后缀[i]!=前缀[j+1]时
        这时我们需要移动前缀
        也就是将【前缀的前缀】移动到【前缀的后缀】查看匹配的的结果
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,N1=1e6+10;//next数组
int ne[N];//next数组
char p[N];
char s[N1];
int main(){
    int n,m;
    cin>>n>>p+1>>m>>s+1;//这个要会，从1开始记录
    //创建next数组
    for(int i=2,j=0;p[i];i++){//从2开始，1没有意义
        while(j&&p[j+1]!=p[i]){
            j=ne[j];//将前缀移到后缀这
        }
        if(p[j+1]==p[i]){
            j++;//匹配窗口往后（后面还有个i++）
        }
        ne[i]=j;//记录下前缀的最后一个位置
    }
    //开始真正的匹配过程S,P
    for(int i=1,j=0;s[i];i++){
        while(j&&p[j+1]!=s[i]){
            j=ne[j];//将前缀移到后缀这
        }
        if(p[j+1]==s[i]){
            j++;//移动匹配窗口  
        }
        // cout<<i<<" "<<j<<endl;
        if(j==n){
            //此时已经匹配完了，开始下一个的匹配
            cout<<i-j<<" ";
            j=ne[j];//还是将前缀移到后缀这
        }
    }
    return 0;
}
```
**trie字符串统计**
```
题：统计一个字符串（只用小写字母）出现了多少次
```
## 哈希表版
```c++
/*
用哈希表版的存下标记法(统计出现次数)，比较好做
（用来查东西非常好用）
现在还没学完，所以这里就用stl
用一个key去查value
unordered_map<>  ;
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    unordered_map<string,int> h;
    int n;
    cin>>n;
    while(n--){
        char op;
        cin>>op;
        if(op=='I'){
            string s;
            cin>>s;
            if(h.find(s)!=h.end()){
                h[s]++;
            }else{
                h.emplace(s,1);
            }
        }else{
            string s;
            cin>>s;
            cout<<h[s]<<endl;
        }
    }

    
    
    return 0;
}
```


## tire树版
![图模拟.jpg](https://cdn.acwing.com/media/article/image/2023/05/07/246003_f225899dec-图模拟.jpg) 

```c++
/*
字典树：
(这个算法其实挺抽象，建议用采用画图模拟的方式理解)
用法：高效的地存储和查找字符串集合的数据结构，不重不漏
缺点：时间复杂度很低，但是大部分情况浪费很多空间
（
  这个使用数组模拟的多叉树，
  同时其实本质上跟邻接表也也挺像的，都会指向下一次出现的节点
）

首先需要讲明的是：
    这里每个节点都表示是一个【字母】，而且这些节点是可以共用的
    从根节点（节点0）到这个节点的路径，表示的是一个单词或是前缀
int son[N][26];//用来指向[下一个节点]，同时也表示[下个节点状态],0~25对应a~z
    son[p][u]=i;
        p是当前节点编号;特别当p=0,为根节点，表示开头状态
        u是下一个节点的状态，对应字母【'a'+u】;
        i是下一个节点的下标;特别的i=0时，表示这个状态为空
int cnt[N];
    cnt[i]=x;
        表示以【节点i】结尾的单词有x个（结合上面的讲明）
int idx=0;
    跟链表的含义一样
    表示的是新节点的下标分配器
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//字典树创建
int son[N][26],cnt[N],idx;
void insert(string &s){
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u]){//没有就补创
            son[p][u]=++idx;//创建新的节点，注意++在前
        }
        p=son[p][u];//下一个节点
    }
    cnt[p]++;//到这个节点就能结束了
}
int query(string &s){//查询这个单词个数
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u]){//没有这个前缀就可以提早结束了
            return 0;
        }
        p=son[p][u];
    }
    return cnt[p];
}
int main(){
    int n;
    cin>>n;
    while(n--){
        char op;
        cin>>op;
        if(op=='I'){
            string s;
            cin>>s;
            insert(s);
        }else{
            string s;
            cin>>s;
            cout<<query(s)<<endl;
        }
    }
    return 0;
}
```
**最大异或和（tire树）**
```
题：给出n个整数，找出其中哪一对求异或和最大
```
```c++
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+10;
int a[M];
//创建字典树，方便查找
const int N=3.1e6+10;
    //因为一共有1e5个数，每个数的二进制位有31个，那么假设他恰好每次都是一条新的分支就是31*1e5,实际上是不可能的
int son[N][2];
    //son[p][u]=i:p表示当前节点下标；u表示下一个节点状态0/1；i表示下一个节点的下标
    //如果只看当前节点的话，表示0/1，若结合根节点的话，表示的一个31位二进制数的前缀或本身
int idx;
    //表示新节点的下标分配器
//这里不需要cnt[N],记录结束下标，因为每个数都是31位，到这个深度时都会自动结束
/*
这里是用每一位的最优解
这里是从二进制的最高位出发：
    假设二进制数有x=(001)2,剩下两个数(101)2和(010)2
    显然最高位对整体的影响会更大，从最低位出发找的就是(010)2了
*/
void insert(int x){//建trie树
    int p=0;//开始时，都是指向根节点
    for(int i=30;i>=0;i--){
    //这i>=0还可以写成(~i),因为根据计算机二进制表示只有-1是全为1的
        int u=x>>i&1;//左移的优先级比按位与高
        if(!son[p][u]){//没有这个节点就新建
            son[p][u]=++idx;
        }
        p=son[p][u];
    }
}
int query(int x){//寻找当前数字的最大异或对
    int res=0,p=0;
    for(int i=30;i>=0;i--){
        int u=!(x>>i&1);//取个非，就是当前的最优解
        if(son[p][u]){//如果存在,走下去
            res+=1<<i;
            p=son[p][u];
        }else{//不存在，只能勉为其难走另一条
            p=son[p][!u];
        }
    }
    return res;
    
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        insert(a[i]);
    }
    int ans=0;
    for(int i=0;i<n;i++){
        ans=max(ans,query(a[i]));
    }
    cout<<ans;
    
    
    return 0;
}
```
## 并查集
![并查集1.jpg](https://cdn.acwing.com/media/article/image/2023/05/12/246003_bf00e359f0-并查集1.jpg) 
![并查集2.jpg](https://cdn.acwing.com/media/article/image/2023/05/12/246003_c7d425acf0-并查集2.jpg) 
![并查集3.jpg](https://cdn.acwing.com/media/article/image/2023/05/12/246003_d0da1e72f0-并查集3.jpg) 
**食物链（带权值的并查集）**
```
题：三类动物 A,B,C。A  吃 B，B 吃 C，C 吃 A。给出几句话，以前的话为准，判断这些话是否为真
```
```c++
/*
非常巧妙的一题：
这题是带权值并查集：
    用到根节点的距离来表示与根节点的相对关系，同时就能够推出与其他点的关系

假设到根节点的距离取余3：
    1）余0时，表示与根节点同类
    2）余1时，表示吃根节点
    3）余2时，表示被根节点吃
点一点例：a余1，b余2，那么b能够吃掉a

判断是否为真话：
前面的是真话
1.如果不是同一个根节点上：
    则无法判断真伪，则当成真
2.是：
    判断其格子与根节点的关系
    
当为真话就加入这个集合内


这里需要特别强调的是：
    这里的权值是当前点到父节点的距离，
    当要用到时就会转化到根节点的距离（路径压缩，根节点成为新的父节点）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+10;
int n,k;
int ans;
//带权值的并查集
int p[N],d[N];//当前点，前面存的是父节点，后面存的是权值
void init(){//初始化,cnt开始时默认为0
    for(int i=1;i<=n;i++){
        p[i]=i;
    }
}
int find(int x){
    //找宗主，同时宗主成为新的父节点，会更新权值
    if(x!=p[x]){//父节点不是宗主，接着往下找
        int t=p[x];//先记录下父节点，因为一会儿会丢失
        p[x]=find(p[x]);//更新为宗主
        d[x]+=d[t];//回来时，父节点已经是指向宗主，权值也更新了
        //上面的操作要好好想清楚
    }
    return p[x];
}
int main(){
    cin>>n>>k;
    init();
    while(k--){
        int op,x,y;
        cin>>op>>x>>y;
        if(x>n||y>n){
            ans++;
            continue;
        }
        if(op==2&&x==y){
            ans++;
            continue;
        }
        int a=find(x),b=find(y);
        if(op==1){//判断同类
            
            if(a==b&&(d[x]-d[y])%3){//先判断为假的情况
                ans++;
            }else if(a!=b){//两个集合合并
                p[a]=b;//b成为了新的宗主
                d[a]=d[y]-d[x];//这里需要画图才能理解
            }
        }else{
            if(a==b&&(d[x]-d[y]-1)%3){//y能被x吃，说明其各自取余3后，x比y多1
                ans++;
            }else if(a!=b){
                p[a]=b;
                d[a]=1-d[x]+d[y];
            }
        }
    }
    cout<<ans;
    
    return 0;
}
```
# 图论
(有一些细节看小本笔记)
**最短路**
![最短路各个算法使用场景.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_cedc1e80f3-最短路各个算法使用场景.jpg) 
## Dijkstra求最短路 I
```c++
#include<bits/stdc++.h>
using namespace std;
int dist[510];//distance 最短路，距离起点的最短距离，需要更新,初始较大化
bool had[510]={0};//看是否已经遍历过,0表示没遍历过
int link[510][510];//记录每个连接的最小边，记录x->y的边长，link[x][y]，初始较大化

int n,m;
int dijkstra(){
    //每一个大循环其实就出一个贪心的结果
    for(int i=0;i<n;i++){
        int m=-1;//找出其中的那个点距离起点最小
        for(int j=1;j<=n;j++){
            if(!had[j]&&(m==-1||dist[m]>dist[j])){
                m=j;//更新最小且没用过的点
            }
        }
        had[m]=1;//这个已经用过了
        for(int j=1;j<=n;j++){//唉，小小注意一下，编号大点是可能到小点
            dist[j]=min(dist[j],dist[m]+link[m][j]);//更新，没有连接的自动过滤(加了个大值)
        }
    }
    if(dist[n]==168430090){//非法的答案
        return -1;
    }
    return dist[n];
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    //初始化
    memset(dist,10,sizeof(dist));//并不是赋值为10//赋值为168430090
    dist[1]=0;//起点1
    memset(link,10,sizeof(link));
    cin>>n>>m;
    while(m--){
        int x,y,z;
        cin>>x>>y>>z;
        link[x][y]=min(link[x][y],z);//由于存在重边
    }

    cout<<dijkstra();


	return 0;
}
```
## Dijkstra求最短路 II
```c++
//这个是对朴素dijkstra的优化，整体的思路大体一致，但是有很多的细节不同

#include<iostream>
#include<queue>
#include<vector>//上面这两个使用  调过优先级的  优先队列
#include<utility>//想使用pair类型，类似结构体
#include<cstring>
using namespace std;

typedef pair<int,int> pii;//一对：first,second

int n,m;
const int maxn=1.5e5+10;

/*为什么用链接表呢？
可以看看当前最短边的点，看它连了多少边
*/
//接下来是链表所需的参数
int e[maxn],l[maxn],fx[maxn],cnt;
//这里是邻接表
/*
这里分别对应每条边，从n开始
e表示当前边所表示y也就是终点end；l表示边长length；fx表示上一个起点为x的编号；cnt表示当前所对应的边
*/
int nx[maxn];//nx[i]表示当前起点为x（即为i）  的边所对应的编号，用来赋给fx，需要更新，一开始赋值为-1
//最后nx为起点x最后出现的边(也就是编号)
void add(int x,int y,int z){//链接表的形式
    e[cnt]=y,l[cnt]=z,fx[cnt]=nx[x],nx[x]=cnt,cnt++;
}//用更新每条边

int dist[maxn];//该点所对应的最短边，需要大化
int had[maxn]={0};//该点是否用过

int dijkstra(){
    priority_queue<pii,vector<pii>,greater<pii> > q;//改变优先级的优先队列，主要表现优先级最高一定在队首
//pair是先比first在比second
    q.push({0,1});//前者表示当前点到起点的长度，后者表示当前点
    //为什么这样呢，因为我们要找到最短边,而最短边就在最上方，尽管会有部分冗余的点，但是我们可以标记它是否走过
    while(!q.empty()){//直到全部边都走完
        auto tmp=q.top();//auto自动类型，用不用都没差
        int now=tmp.second;//当前点,x，说具体点x就是起点到y的中转点
        q.pop();//出队
        if(had[now]){//走过了就不走了
            continue;
        }
        had[now]=1;//走过了
        //接下来要更新其相连的点了
        for(int i=nx[now];i!=-1;i=fx[i]){//这里是邻接表，不断的去链接上一条边，直到-1，这样就能找到所有起点为now的边了
            int y=e[i],len=dist[now]+l[i];//起点->y的边长
            if(dist[y]>len){//最短边更新
                dist[y]=len;
                q.push({len,y});//压入
            }
        }

    }
    if(dist[n]>1e9){
        return -1;
    }
    return dist[n];
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    //初始化
    memset(nx,-1,sizeof(nx));//当前边都在-1，代表不存在这个边
    memset(dist,100,sizeof(dist));//较大化，便于取最小，且不容易溢出
    dist[1]=0;
    cin>>n>>m;
    while(m--){
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    cout<<dijkstra();
    return 0;
}
```
## bellman-ford
**有边数限制的最短路**
![bellman_ford.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_d1bd52a0f3-bellman_ford.jpg) 
```c++
存在负权边，且有可能为回路，只能经过k条边
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k;
struct edge{
    int x,y,z;
}edge[10010];
int dist[510];//最短边
int backup[510];//备份免得重复走
void bellman_ford(){
    memset(dist,100,sizeof(dist));
    dist[1]=0;
    for(int i=0;i<k;i++){
        memcpy(backup,dist,sizeof(backup));//只用上一步做得来更新，免得串联，就是更新后又按更新的走，这样可能走了不止k步
        for(int j=0;j<m;j++){
            int x=edge[j].x,y=edge[j].y,z=edge[j].z;
            dist[y]=min(dist[y],backup[x]+z);//这里需要注意一下，是跟dist[y]比
            // cout<<"x="<<x<<"   y="<<y<<"  dist[y]"<<dist[y]<<endl;
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    cin>>n>>m>>k;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        edge[i]={x,y,z};
    }
    bellman_ford();
    // cout<<dist[n]<<endl;
    if(dist[n]>1e8){
        cout<<"impossible";
    }else{
        cout<<dist[n];
    }
    return 0;
}
```
## spfa求最短路
![spfa.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_75dbc2ecf3-spfa.jpg) 
```c++
有负权边，但是无负权回路
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m;
const int maxn=1e5+10;
//邻接表：
int nx[maxn],fx[maxn],e[maxn],l[maxn],idx=0;
//nx（now——x）记录起点为x的最后一次出现的编号；fx是链接上一次出现的编号(初始化为-1，代表还未出现)；
//e（end）就是y啦；l表示边长；idx就是编号
void add(int x,int y,int z){//录入
    fx[idx]=nx[x];e[idx]=y;l[idx]=z;nx[x]=idx++;
}//注意fx和nx是关键

int dist[maxn];//最短路，初始较大化,dist[1]=0
int had[maxn]={0};//优化一下，队伍内没必要重复加入
void spfa(){
     //初始化
    memset(dist,100,sizeof(dist));
    dist[1]=0;

    queue<int> q;
    q.push(1);
    had[1]=1;//已经在队伍内了
    while(!q.empty()){//没路了就自动停了
        int t=q.front();
        q.pop();
        had[t]=0;//取出后就没有了
        for(int i=nx[t];i!=-1;i=fx[i]){
            int y=e[i],tl=dist[t]+l[i];
            // cout<<y<<" "<<"tl="<<tl;
            if(dist[y]>tl){//更小就更新
                dist[y]=tl;
                // cout<<dist[y]<<endl;
                if(!had[y]){
                    q.push(y);
                    had[y]=1;
                }
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    cin>>n>>m;
    memset(nx,-1,sizeof(nx));
    for(int i=0;i<m;i++){//邻接表
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    // for(int i=nx[1];i!=-1;i=fx[i]){
    //     cout<<i<<" ";
    // }
    spfa();
    // cout<<dist[n];
    if(dist[n]>1e9){
        cout<<"impossible";
    }else{
        cout<<dist[n];
    }
    return 0;
}
```
加一个数组，用来记录从起点到这走了几步，可以判断是否有负权边
## Floyd求最短路
```
可以具体查询，任意两点的最短路
```
``` c++
//这个算法涉及简单的动态规划，我现在暂时没学，只能简单且不严谨的解释，只帮助理解
//这个代码看起来虽然很像暴力枚举，但感觉并不是
//唉，虽然代码非常简单，但说实话我感觉并不好理解(可能是我比较笨吧)
/*1.首先嘚搞明白一点，根据对前面的算法学习:
        你会发现若这条最短路（1->5->9->3->30）经过了多个点，那其中任意两点都是最短路
        (这里应该算是贪心)
*/
/*2.然后将floyd算法简单模拟会发现：
        若任意一条经过多个点的最短路(a->b->c->d->e->f)；
        这个算法一定能够确定走了“相邻的”3个点的最短路（划重点是相邻的）；
        因为这个中间的点一定是从小到大确定的，所以先确定的一定是中间点小的；
        （前->中(小的)->后）
        这个最短边操作完后，其实就能忽略掉中间点；
        不断去循环上述的过程，最终一定能当做只剩两个点。
*/
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define f(i,n) for(int i=1;i<=n;i++)//宏定义，略写，因为涉及到较多的循环
int n,m;
int dist[210][210];//因为要去min，初始较大化，同时有个隐含条件就是x==y时，距离为0
void floyd(){
    f(i,n){//i就是中间点
        f(x,n){
            f(y,n){
                dist[x][y]=min(dist[x][y],dist[x][i]+dist[i][y]);
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    
    int k;
    cin>>n>>m>>k;
    //初始
    memset(dist,10,sizeof(dist));
    f(i,n){
        dist[i][i]=0;
    }
    f(i,m){
        int x,y,z;
        cin>>x>>y>>z;
        dist[x][y]=min(dist[x][y],z);//有重边
    }
    floyd();
    while(k--){
        int x,y;
        cin>>x>>y;
        if(dist[x][y]>4e6){
            cout<<"impossible\n";
        }else{
            cout<<dist[x][y]<<"\n";
        }
    }
    
    return 0;
}
```
## Prim算法求最小生成树(加点法)
```c++
//这个算法与dijkstra算法，很相似，但没必要学堆优化版的，后面有个算法可以替代
/*最小生成树就是用n-1个边连接n个点
思路：（贪心，关键是找与集合相连的最短边）
1.创建一个集合用来存点（最小生成树内的点）
2.dist用来存与这个集合相连的边（注意一下在集合内的点之间就不算相连了，had数组标记，同时也是在存点），
(dist[x]表示x点到这个集合的最短距离)
3.重复下述的过程(直到所有的点都在集合内  或是  有个点与集合断开时)：
    a.找到这些边的最短边（需循环所有边），其中相连的点t，记得标记一下——加入集合
    b.用这个点t去更新dist
*/
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int link[510][510];//存每条边，较大化
int dist[510];//把维护与集合相连的边，较大化
bool had[510];//标记点，顺带进集合
int ans=0;
bool prim(){
    //初始化：
    memset(dist,100,sizeof(dist));
    dist[1]=0;
    for(int i=0;i<n;i++){
        int t=-1;
        for(int j=1;j<=n;j++){
            if(!had[j]&&(t==-1||dist[t]>dist[j])){//找最短的边
                t=j;
            }
        }
        if(dist[t]>1e4){
            return 1;
        }
        ans+=dist[t];
        had[t]=1;//标记点
        for(int j=1;j<=n;j++){
            dist[j]=min(dist[j],link[t][j]);
        }

    }
    return 0;

}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);

	cin>>n>>m;
	memset(link,100,sizeof(link));
	for(int i=0;i<m;i++){
	    int u,v,w;
	    cin>>u>>v>>w;
	    link[u][v]=link[v][u]=min(link[u][v],w);//有重边，同时无向边是特殊的有向边
	}
    if(prim()){
        cout<<"impossible";
    }else{
        cout<<ans;
    }
	return 0;
}
```
## Kruskal算法求最小生成树(加边法)
```c++
/*
kruskal算法又称加边法，从最小边开始加，边里会有两个点，将这些点加入集合中
一个点可以连多个边，但是边不能是集合内的点
*/
/*
一开始原本想使用存下标记法，想用had数组标记在集合内（就是最小生成树）的点，
但发现根本就行不通，有的集合间并没有联通，这问题需要注意
*/
//这里标记联通的集合需要用到并查集，我这时候还没去学
//尽管并查集代码很短，但设计的无比巧妙
#pragma optimize(2)
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=2e5+10;
const int maxn1=1e5+10;
int n,m;
int p[maxn1];
struct Node{
    int x,y,z;
    bool operator<(const Node &other)const{//结构体的重载，便于排序
        return z<other.z;
    }
}node[maxn];
int cnt=0;//根据前面做的题你会知道，想相联n个点，那他必须为n-1条边
//并查集也是一种相联操作，没操作一次表示连一条边
long long ans=0;
//第二种
int find(int x){
    if(p[x]!=-1){
        p[x]=find(p[x]);//这里就是路径压缩
        //返回的同时更新p[x]，将走过的都为同个根节点
    }
    return x;//注意一下返回的是点
}
void kruskal(){
    sort(node,node+m);//从小到大排
    for(int i=0;i<m;i++){
        int x=node[i].x,y=node[i].y,z=node[i].z;
        int a=find(x),b=find(y);//找各自集合的最新的（根节点）
        //其中a表示旧的，b表示新节点
        if(a!=b){
            p[a]=b;//集合合并，b成为这个集合的新节点
            cnt++;//连了一条边
            ans+=z;
        }
    }
    if(cnt==n-1){
        cout<<ans;
    }else{
        cout<<"impossible";
    }
}
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        node[i]={x,y,z};
    }
    //第二种
    memset(p,-1,sizeof(p));
    kruskal();
    return 0;
}
```
**动态求连续区间和**
```
题意：1.能修改某个数2.求区间和
```
## 树状数组
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=100000;
int a[maxn],tr[maxn];
//其实是从1开始存的

//tr[x]中的一共有几个a[x,x-1,……,x-lowbit+1]
int lowbit(int x){
   return (x&-x); 
}
//修改操作
void add(int x,int y){
    //不断的找父节点
    for(int i=x;i<=n;i+=lowbit(i)){
        tr[i]+=y;
    }
}
//查询前缀和
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)){
        res+=tr[i];
    }
    return res;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        add(i,a[i]);//类似二维差分
    }
    while(m--){
        int k,x,y;
        cin>>k>>x>>y;
        if(k){
            add(x,y);
        }else{
            cout<<sum(y)-sum(x-1)<<endl;//前缀和思想
        }
    }
    return 0;
}
```
## 线段树
 ![1.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_1c2d594de4-1.jpg) 
![2.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_20d5b42de4-2.jpg) 
![3.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_2726c1fae4-3.jpg) 
![4.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_2c4c32d2e4-4.jpg) 
![5.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_30f6dbb5e4-5.jpg) 

```c++
/*
（这里不需要lazy—tag标记）（但感觉还是不什么好写）

线段树：（分治+二叉树）
（这里用结构体写，其实用一个数组也能写，但比较容易乱）
大概的思路是：
    将数组的元素（也是一个区间），两两合成一个新的区间，知道合成一个
    （这个与树状数组不同的是，覆盖了所有的区间，
      而树状数组(前缀和)将一些冗余区间给去掉，为了更快更方便的求和，因此丢失了部分功能）

父节点的左儿子为i<<1    i*2
        右儿子为i<<1|1  i*2+1
      
四个核心函数：1.区间（两儿子）合并
              2.建树
              3.查询区间和
              4.修改某个数
              
然后这里的下标是从上到下一层一层（左到右）标记
                （好好看一下图4.12，及上面标的序号）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int a[N];
//线段树
struct Node{//每个节点
    int l,r;
    int sum;
}tr[4*N];//看图4.12和第三张图
//1.区间合并（左右儿子合并）
void push_up(int u){//u是当前节点下标
//这里是分治后，找到儿子后一步步合并
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
    //           u*2          u*2+1
}
//2.建树
void build(int u,int l,int r){//l表示左边界，r表示有边界
    //注意这里与线段树不太一样，线段树用加入数维护比较方便
    //这里先找到叶子节点（只有一个元素），向上合并比较方便
    if(l==r){
        tr[u]={l,r,a[l]};
        return;
    }else{
        tr[u]={l,r};//别忘了,这里c++11才行
        
        //分两半(这里很像归并的过程),同时得到左右儿子的值
        int mid=(l+r)>>1;//想想问什么要加1
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);
        
        //合并
        push_up(u);
    }
}
//3.查询区间和(这里建议画图)
int query(int u,int l,int r){//l和r分别表示区间的边界
    //找能完全覆盖的区间，相加，就是区间和（从上到下）
    if(l<=tr[u].l&&tr[u].r<=r){
        return tr[u].sum;//判断这个节点是否被这个区间完全覆盖
    }else{
        int res=0;
        //用中点来分,左右都找这样就不会漏了
        int mid=(tr[u].l+tr[u].r)>>1;
            //这里不好分,需要注意下(主要出现的问题在边界上)
        if(l<=mid){//往左儿子找
            res+=query(u<<1,l,r);
        }
        if(r>=mid+1){//往右儿子找
            res+=query(u<<1|1,l,r);
        }
        return res;
    }
}
//4.修改某个值(有这个元素的整个分支都要修改)
void modify(int u,int x,int v){
    if(tr[u].l==tr[u].r){
        tr[u].sum+=v;
        return;
    }else{
        int mid=(tr[u].l+tr[u].r)>>1;
        //看x在那个部分，同时修改哪个部分
        if(mid>=x){//在左边，找左儿子
            modify(u<<1,x,v);
        }else{
            modify(u<<1|1,x,v);
        }
        //修改后的合并
        push_up(u);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    build(1,1,n);
    while(m--){
        int k,a,b;
        cin>>k>>a>>b;
        if(k){
            modify(1,a,b);
        }else{
            cout<<query(1,a,b)<<endl;
        }
    }
    return 0;
}
```
**货仓选址**
## 绝对值不等式
```
题：
在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。
现在需要在数轴上建立一家货仓，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。
```
```c++
//抽象：求一个点与所有的距离和最小
//暴力会超时
//可恶，模拟半天，没找到什么好方法

/*
最后需要数学:绝对不等式
对于两个数：
|a1-x|+|a2-x|>=|a1-a2|
(画画图就懂了)
（注意：x要取在中间，且边界a1,a2是能取到的）
多个数就大值与小值取两两分组
最好要在所有组的中间段，发现中位数恰好符合

取中位数：法1：sort
          法2：nth_element()  （快一点）
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int a[maxn];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    // sort(a,a+n);
    int k=n>>1;
    nth_element(a,a+k,a+n);
    int ans=0;
    for(int i=0;i<n;i++){
        ans+=fabs(a[i]-a[k]);
    }
    cout<<ans;
    return 0;
}
```
**X的因子链**
![x的因子链.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_37d3248ff3-x的因子链.jpg) 
![x的因子链2.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_3c8407f0f3-x的因子链2.jpg) 
```
题：
输入正整数 X，求 X 的大于的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，
以及满足最大长度的序列的个数。
例如：100=2*2*5*5
2，2*2，2*2*5，2*2*5*5
一个位置一个位置的排，但需要去重
```
## 线性筛 
```c++
//不过都要质因数分解，需要记录每个质数的个数
/*

递增序列：就是从质因数里选，一个个去乘
最长：就是质因数的个数n
最长的个数：(说实话不会，猜因该是跟质因数相乘有关)(学成归来)
    也就是将n个数进行排序，一个一个的加进去乘，
    n*(n-1)*(n-2)……*1=n!
    但是需要注意的由于会有相同的数（根据高中的排列组合）
    需要出与重复个数的阶乘
    
由于有多组数据，采用普通的质因数分解，会超时，
这里需要用欧拉筛来优化
(哎呀，这个学半天没弄明白)

功能非常强大（就是费脑子）：
    1.每个数严格只筛一次（埃式筛会出现2*3，3*2，有非常多的重复情况）
        （复杂度低，速度快）
    2.筛出质数数组
    3.同时也能用来判断是不是质数（只有1个时暴力就行，非常多的数肯定是这个好用）
    
基本原理就是：用最小质因数来筛（每个大于1的数一定会有一个最小质因数）

步骤：
    枚举（i:1~n）
    {
        1.若没被筛过（就是质数）
            加入质数数组
        2.从小到大枚举所有质数，满足i*质数<=n(最关键的一步)
            {
                筛出（i*prime[j]）;
                判断若刚好为是为i的最小质因数：break;
            }
            
    }  

如果只看代码，比较难理解的地方就是第2步
为什么说prime[j]一定是i*prime[j]的最小质因数呢？
    由于质数是从小到大枚举，且prime[j]<=i
    1.当prime[j]不是i的因子，
      然后需要强调的是i一定不会有比prime[j]小的质因子
      （因为我们已经判断过最小质因子了）
      （不会出现prime[1]=3 i=2*5*7 的情况）
      所以prime[j]就是最小质因子
    2.当prime[j]是i的最小质因子
      那么prime[j]就是i*prime[j]的最小质因子（这里自己想想吧，我知道什么说）
*/
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1.1e6+10;
//阶乘处理
ll a[25];
//线性筛法（欧拉筛）
int prime[N],cnt;//记录素数
bool st[N];//y总的是否筛过，我写的是能判断是不是素数的版本
int minp[N];//各个数的最小质因数
void get_prime(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]){
            //没被筛过就是素数，同时别忘了最小质因数就是本身
            prime[cnt++]=i;
            minp[i]=i;
        }
        for(int j=0;prime[j]*i<=n;j++){
            int t=prime[j]*i;
            st[t]=1;
            minp[t]=prime[j];
            if(i%prime[j]==0){
                break;
            }           
        }
    }
}

int main(){
    ll x;
    a[1]=1;//别忘了
    //阶乘数组
    for(int i=2;i<=20;i++){
        //之所以上界为20，是因为最小质因数最多就20个，其他的不会大于这个
        a[i]=a[i-1]*i;
    }
    get_prime(N-1);
    
    while(cin>>x){
        //数据量太大了，就连普通初始化都要很长时间
        int sum[1000],t=0;//记录一个质因数出现的个数
        int tot=0;//总共有几个
        while(x>1){
            int k=minp[x];//当前的最小质因数
            sum[t]=0;
            while(x%k==0){
                x/=k;
                sum[t]++;
                tot++;
            }
            t++;
        }
        ll ans=a[tot];//阶乘数组
        for(int i=0;i<t;i++){
            ans/=a[sum[i]];//去重
        }
        cout<<tot<<" "<<ans<<'\n';
    }
    return 0;
}
```